{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>t4-devkit</code>","text":"<p><code>t4-devkit</code> is a toolkit to load and operate T4 dataset.</p>"},{"location":"#feature-supports","title":"Feature supports","text":""},{"location":"#visualization","title":"Visualization","text":"<p><code>t4-devkit</code> provides a set of visualization tools to help you understand the data.</p> <p>More details, please refer to <code>t4viz</code> CLI or API usage.</p> Feature Task Support 3D 3D Boxes \u2705 PointCloud Segmentation Raw PointCloud \u2705 3D Trajectories \u2705 TF Links \u2705 2D 2D Boxes \u2705 Image Segmentation \u2705 Raw Image \u2705 Raw PointCloud on Image \u2705 Map Vector Map \u2705 Ego Position on Street View \u2705"},{"location":"#sanity-checks","title":"Sanity Checks","text":"<p><code>t4-devkit</code> provides a set of sanity checks to ensure the correctness of the data.</p> <p>More details, please refer to <code>t4sanity</code> CLI or API usage.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#for-users-install-via-github","title":"[For Users] Install via GitHub","text":"<p>Note that the following command installs the latest <code>main</code> branch:</p> <pre><code># e.g) with pip\npip install git+https://github.com/tier4/t4-devkit.git\n</code></pre> <p>By specifying <code>@&lt;TAG_OR_BRANCH&gt;</code>, you can install the particular version of <code>t4-devkit</code>:</p> <pre><code># e.g) with pip\npip install git+https://github.com/tier4/t4-devkit.git@main\n</code></pre>"},{"location":"install/#for-developers-install-from-source","title":"[For Developers] Install from source","text":"<p>You need to install <code>uv</code>. For details, please refer to OFFICIAL DOCUMENT.</p> <pre><code>git clone git@github.com:tier4/t4-devkit.git\ncd t4-devkit\nuv sync --python 3.10\n</code></pre> <p>The virtual environment can be activated with:</p> <pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"apis/common/","title":"<code>common</code>","text":""},{"location":"apis/dataclass/","title":"<code>dataclass</code>","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.label","title":"t4_devkit.dataclass.label","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.label.SemanticLabel","title":"SemanticLabel","text":"<p>A dataclass to represent semantic labels.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Label name.</p> </li> <li> <code>attributes</code>               (<code>list[str]</code>)           \u2013            <p>List of attribute names.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box","title":"t4_devkit.dataclass.box","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D","title":"Box3D","text":"<p>A class to represent 3D box.</p> <p>Attributes:</p> <ul> <li> <code>unix_time</code>               (<code>int</code>)           \u2013            <p>Unix timestamp.</p> </li> <li> <code>frame_id</code>               (<code>str</code>)           \u2013            <p>Coordinates frame ID where the box is with respect to.</p> </li> <li> <code>semantic_label</code>               (<code>SemanticLabel</code>)           \u2013            <p><code>SemanticLabel</code> object.</p> </li> <li> <code>confidence</code>               (<code>float</code>)           \u2013            <p>Confidence score of the box.</p> </li> <li> <code>uuid</code>               (<code>str | None</code>)           \u2013            <p>Unique box identifier.</p> </li> <li> <code>position</code>               (<code>Vector3</code>)           \u2013            <p>Box center position (x, y, z).</p> </li> <li> <code>rotation</code>               (<code>Quaternion</code>)           \u2013            <p>Box rotation quaternion.</p> </li> <li> <code>shape</code>               (<code>Shape</code>)           \u2013            <p><code>Shape</code> object.</p> </li> <li> <code>velocity</code>               (<code>Vector3 | None</code>)           \u2013            <p>Box velocity (vx, vy, vz).</p> </li> <li> <code>num_points</code>               (<code>int | None</code>)           \u2013            <p>The number of points inside the box.</p> </li> <li> <code>visibility</code>               (<code>VisibilityLevel</code>)           \u2013            <p>Box visibility.</p> </li> <li> <code>future</code>               (<code>Future | None</code>)           \u2013            <p>Box trajectory in the future of each mode.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # without future\n&gt;&gt;&gt; box3d = Box3D(\n...     unix_time=100,\n...     frame_id=\"base_link\",\n...     semantic_label=SemanticLabel(\"car\"),\n...     position=(1.0, 1.0, 1.0),\n...     rotation=(0.0, 0.0, 0.0, 1.0),\n...     shape=Shape(shape_type=ShapeType.BOUNDING_BOX, size=(1.0, 1.0, 1.0)),\n...     velocity=(1.0, 1.0, 1.0),\n...     confidence=1.0,\n...     uuid=\"car3d_0\",\n... )\n&gt;&gt;&gt; # with future\n&gt;&gt;&gt; box3d = box3d.with_future(\n...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0], [3.0, 3.0, 3.0]]],\n...     confidences=[1.0],\n... )\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.size","title":"size  <code>property</code>","text":"<pre><code>size: Vector3\n</code></pre> <p>Return the box size in the order of (width, length, height).</p> <p>Returns:</p> <ul> <li> <code>Vector3</code>           \u2013            <p>(width, length, height) values.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.with_future","title":"with_future","text":"<pre><code>with_future(\n    timestamps: ArrayLike,\n    confidences: ArrayLike,\n    waypoints: ArrayLike,\n) -&gt; Self\n</code></pre> <p>Return a self instance setting <code>future</code> attribute.</p> <p>Parameters:</p> <ul> <li> <code>timestamps</code>               (<code>ArrayLike</code>)           \u2013            <p>Array of future timestamps at each waypoint in the shape of (T).</p> </li> <li> <code>confidences</code>               (<code>ArrayLike</code>)           \u2013            <p>Array of confidences for each mode in the shape of (M).</p> </li> <li> <code>waypoints</code>               (<code>ArrayLike</code>)           \u2013            <p>Array of waypoints for each mode in the shape of (M, T, D).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self instance after setting <code>future</code>.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def with_future(\n    self,\n    timestamps: ArrayLike,\n    confidences: ArrayLike,\n    waypoints: ArrayLike,\n) -&gt; Self:\n    \"\"\"Return a self instance setting `future` attribute.\n\n    Args:\n        timestamps (ArrayLike): Array of future timestamps at each waypoint in the shape of (T).\n        confidences (ArrayLike): Array of confidences for each mode in the shape of (M).\n        waypoints (ArrayLike): Array of waypoints for each mode in the shape of (M, T, D).\n\n    Returns:\n        Self instance after setting `future`.\n    \"\"\"\n    self.future = Future(timestamps=timestamps, confidences=confidences, waypoints=waypoints)\n    return self\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.translate","title":"translate","text":"<pre><code>translate(x: Vector3Like) -&gt; None\n</code></pre> <p>Apply a translation.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Vector3Like</code>)           \u2013            <p>3D translation vector in the order of (x, y, z).</p> </li> </ul> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def translate(self, x: Vector3Like) -&gt; None:\n    \"\"\"Apply a translation.\n\n    Args:\n        x (Vector3Like): 3D translation vector in the order of (x, y, z).\n    \"\"\"\n    self.position += Vector3(x)\n\n    if self.future is not None:\n        self.future.translate(x)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.rotate","title":"rotate","text":"<pre><code>rotate(q: RotationLike) -&gt; None\n</code></pre> <p>Apply a rotation.</p> <p>Parameters:</p> <ul> <li> <code>q</code>               (<code>RotationLike</code>)           \u2013            <p>Rotation quaternion.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def rotate(self, q: RotationLike) -&gt; None:\n    \"\"\"Apply a rotation.\n\n    Args:\n        q (RotationLike): Rotation quaternion.\n    \"\"\"\n    q = to_quaternion(q)\n    self.position = np.dot(q.rotation_matrix, self.position)\n    self.rotation = q * self.rotation\n\n    if self.velocity is not None:\n        self.velocity = np.dot(q.rotation_matrix, self.velocity)\n\n    if self.future is not None:\n        self.future.rotate(q)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.corners","title":"corners","text":"<pre><code>corners(box_scale: float = 1.0) -&gt; NDArrayF64\n</code></pre> <p>Return the bounding box corners.</p> <p>Parameters:</p> <ul> <li> <code>box_scale</code>               (<code>float</code>, default:                   <code>1.0</code> )           \u2013            <p>Multiply size by this factor to scale the box.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>NDArrayF64</code>           \u2013            <p>First four corners are the ones facing forward. The last four are the ones facing backwards, in the shape of (8, 3).</p> </li> </ul> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def corners(self, box_scale: float = 1.0) -&gt; NDArrayF64:\n    \"\"\"Return the bounding box corners.\n\n    Args:\n        box_scale (float, optional): Multiply size by this factor to scale the box.\n\n    Returns:\n        First four corners are the ones facing forward. The last four are the ones facing backwards,\n            in the shape of (8, 3).\n    \"\"\"\n    width, length, height = self.size * box_scale\n\n    # 3D box corners (Convention: x points forward, y to the left, z up.)\n    x_corners = 0.5 * length * np.array([1, 1, 1, 1, -1, -1, -1, -1])\n    y_corners = 0.5 * width * np.array([1, -1, -1, 1, 1, -1, -1, 1])\n    z_corners = 0.5 * height * np.array([1, 1, -1, -1, 1, 1, -1, -1])\n    corners = np.vstack((x_corners, y_corners, z_corners))  # (3, 8)\n\n    # Rotate and translate\n    return np.dot(self.rotation.rotation_matrix, corners).T + self.position\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box2D","title":"Box2D","text":"<p>A class to represent 2D box.</p> <p>Attributes:</p> <ul> <li> <code>unix_time</code>               (<code>int</code>)           \u2013            <p>Unix timestamp.</p> </li> <li> <code>frame_id</code>               (<code>str</code>)           \u2013            <p>Coordinates frame ID where the box is with respect to.</p> </li> <li> <code>semantic_label</code>               (<code>SemanticLabel</code>)           \u2013            <p><code>SemanticLabel</code> object.</p> </li> <li> <code>confidence</code>               (<code>float</code>)           \u2013            <p>Confidence score of the box.</p> </li> <li> <code>uuid</code>               (<code>str | None</code>)           \u2013            <p>Unique box identifier.</p> </li> <li> <code>roi</code>               (<code>Roi | None</code>)           \u2013            <p><code>Roi</code> object.</p> </li> <li> <code>position</code>               (<code>Vector3 | None</code>)           \u2013            <p>3D position (x, y, z).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # without 3D position\n&gt;&gt;&gt; box2d = Box2D(\n...     unix_time=100,\n...     frame_id=\"camera\",\n...     semantic_label=SemanticLabel(\"car\"),\n...     roi=(100, 100, 50, 50),\n...     confidence=1.0,\n...     uuid=\"car2d_0\",\n... )\n&gt;&gt;&gt; # with 3D position\n&gt;&gt;&gt; box2d = box2d.with_position(position=(1.0, 1.0, 1.0))\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box2D.with_position","title":"with_position","text":"<pre><code>with_position(position: Vector3Like) -&gt; Self\n</code></pre> <p>Return a self instance setting <code>position</code> attribute.</p> <p>Parameters:</p> <ul> <li> <code>position</code>               (<code>Vector3Like</code>)           \u2013            <p>3D position.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self instance after setting <code>position</code>.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def with_position(self, position: Vector3Like) -&gt; Self:\n    \"\"\"Return a self instance setting `position` attribute.\n\n    Args:\n        position (Vector3Like): 3D position.\n\n    Returns:\n        Self instance after setting `position`.\n    \"\"\"\n    self.position = Vector3(position)\n    return self\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.distance_box","title":"distance_box","text":"<pre><code>distance_box(\n    box: BoxLike, tf_matrix: HomogeneousMatrix\n) -&gt; float | None\n</code></pre> <p>Return a box distance from <code>base_link</code>.</p> <p>Parameters:</p> <ul> <li> <code>box</code>               (<code>BoxLike</code>)           \u2013            <p>A box.</p> </li> <li> <code>tf_matrix</code>               (<code>HomogeneousMatrix</code>)           \u2013            <p>Transformation matrix.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>TypeError</code>             \u2013            <p>Expecting type of box is <code>Box2D</code> or <code>Box3D</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>float | None</code>           \u2013            <p>float | None: Return <code>None</code> if the type of box is <code>Box2D</code> and its <code>position</code> is <code>None</code>, otherwise returns distance from <code>base_link</code>.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def distance_box(box: BoxLike, tf_matrix: HomogeneousMatrix) -&gt; float | None:\n    \"\"\"Return a box distance from `base_link`.\n\n    Args:\n        box (BoxLike): A box.\n        tf_matrix (HomogeneousMatrix): Transformation matrix.\n\n    Raises:\n        TypeError: Expecting type of box is `Box2D` or `Box3D`.\n\n    Returns:\n        float | None: Return `None` if the type of box is `Box2D` and its `position` is `None`,\n            otherwise returns distance from `base_link`.\n    \"\"\"\n    if isinstance(box, Box2D) and box.position is None:\n        return None\n\n    if isinstance(box, Box2D):\n        position = tf_matrix.transform(box.position)\n    elif isinstance(box, Box3D):\n        position, _ = tf_matrix.transform(box.position, box.rotation)\n    else:\n        raise TypeError(f\"Unexpected box type: {type(box)}\")\n\n    return np.linalg.norm(position).item()\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud","title":"t4_devkit.dataclass.pointcloud","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.Stamp","title":"Stamp","text":"<p>A dataclass to represent timestamp.</p> <p>Attributes:</p> <ul> <li> <code>sec</code>               (<code>int</code>)           \u2013            <p>Seconds.</p> </li> <li> <code>nanosec</code>               (<code>int</code>)           \u2013            <p>Nanoseconds.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointcloudSourceInfo","title":"PointcloudSourceInfo","text":"<p>A dataclass to represent pointcloud source information.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>str</code>)           \u2013            <p>source identifier.</p> </li> <li> <code>idx_begin</code>               (<code>int</code>)           \u2013            <p>Begin index of points for the source in the concatenated pointcloud structure.</p> </li> <li> <code>length</code>               (<code>int</code>)           \u2013            <p>Length of points for the source in the concatenated pointcloud structure.</p> </li> <li> <code>stamp</code>               (<code>Stamp</code>)           \u2013            <p>Timestamp.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloudMetainfo","title":"PointCloudMetainfo","text":"<p>A dataclass to represent pointcloud metadata.</p> <p>Attributes:</p> <ul> <li> <code>stamp</code>               (<code>Stamp</code>)           \u2013            <p>Timestamp.</p> </li> <li> <code>sources</code>               (<code>list[PointcloudSourceInfo]</code>)           \u2013            <p>List of source information.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloudMetainfo.source_ids","title":"source_ids  <code>property</code>","text":"<pre><code>source_ids: list[str]\n</code></pre> <p>Get the list of source sensor IDs.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>list[str]: List of sensor names.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloudMetainfo.from_file","title":"from_file  <code>classmethod</code>","text":"<pre><code>from_file(filepath: str) -&gt; Self\n</code></pre> <p>Create an instance from a JSON file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>Path to the JSON file containing metadata.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code> (              <code>Self</code> )          \u2013            <p>PointCloudMetainfo instance.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@classmethod\ndef from_file(cls, filepath: str) -&gt; Self:\n    \"\"\"Create an instance from a JSON file.\n\n    Args:\n        filepath (str): Path to the JSON file containing metadata.\n\n    Returns:\n        Self: PointCloudMetainfo instance.\n    \"\"\"\n    data = load_json(filepath)\n    stamp = Stamp(**data[\"stamp\"])\n    sources = []\n    for source_data in data.get(\"sources\", []):\n        sources.append(PointcloudSourceInfo(**source_data))\n    return cls(stamp=stamp, sources=sources)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud","title":"PointCloud","text":"<p>Abstract base dataclass for pointcloud data.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud.num_dims","title":"num_dims  <code>abstractmethod</code> <code>staticmethod</code>","text":"<pre><code>num_dims() -&gt; int\n</code></pre> <p>Return the number of the point dimensions.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of the point dimensions.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef num_dims() -&gt; int:\n    \"\"\"Return the number of the point dimensions.\n\n    Returns:\n        int: The number of the point dimensions.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud.from_file","title":"from_file  <code>abstractmethod</code> <code>classmethod</code>","text":"<pre><code>from_file(filepath: str) -&gt; Self\n</code></pre> <p>Create an object from pointcloud file.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>File path of the pointcloud file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Self instance.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_file(cls, filepath: str) -&gt; Self:\n    \"\"\"Create an object from pointcloud file.\n\n    Args:\n        filepath (str): File path of the pointcloud file.\n\n    Returns:\n        Self instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud.num_points","title":"num_points","text":"<pre><code>num_points() -&gt; int\n</code></pre> <p>Return the number of points.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>description</p> </li> </ul> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>def num_points(self) -&gt; int:\n    \"\"\"Return the number of points.\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.points.shape[1]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.LidarPointCloud","title":"LidarPointCloud","text":"<p>A dataclass to represent lidar pointcloud.</p> <p>Attributes:</p> <ul> <li> <code>points</code>               (<code>NDArrayFloat</code>)           \u2013            <p>Points matrix in the shape of (4, N).</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.RadarPointCloud","title":"RadarPointCloud","text":"<p>A dataclass to represent radar pointcloud.</p> <p>Attributes:</p> <ul> <li> <code>points</code>               (<code>NDArrayFloat</code>)           \u2013            <p>Points matrix in the shape of (18, N).</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.SegmentationPointCloud","title":"SegmentationPointCloud","text":"<p>A dataclass to represent segmentation pointcloud.</p> <p>Attributes:</p> <ul> <li> <code>points</code>               (<code>NDArrayFloat</code>)           \u2013            <p>Points matrix in the shape of (4, N).</p> </li> <li> <code>labels</code>               (<code>NDArrayU8</code>)           \u2013            <p>Label matrix.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.shape","title":"t4_devkit.dataclass.shape","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.shape.ShapeType","title":"ShapeType","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.shape.ShapeType.from_name","title":"from_name  <code>classmethod</code>","text":"<pre><code>from_name(name: str) -&gt; Self\n</code></pre> <p>Return an enum object from the name of the member.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of enum member.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Enum object.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/shape.py</code> <pre><code>@classmethod\ndef from_name(cls, name: str) -&gt; Self:\n    \"\"\"Return an enum object from the name of the member.\n\n    Args:\n        name (str): Name of enum member.\n\n    Returns:\n        Enum object.\n    \"\"\"\n    name = name.upper()\n    assert name in cls.__members__, f\"Unexpected shape type: {name}.\"\n    return cls.__members__[name]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.shape.Shape","title":"Shape","text":"<p>A dataclass to represent the 3D box shape.</p> <p>Attributes:</p> <ul> <li> <code>shape_type</code>               (<code>ShapeType</code>)           \u2013            <p>Box shape type.</p> </li> <li> <code>size</code>               (<code>Vector3</code>)           \u2013            <p>Box size in the order of (width, length, height).</p> </li> <li> <code>footprint</code>               (<code>Polygon</code>)           \u2013            <p>Polygon of footprint.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\n...     shape_type=ShapeType.BOUNDING_BOX,\n...     size=[1.0, 1.0, 1.0]\n... )\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory","title":"t4_devkit.dataclass.trajectory","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath","title":"ObjectPath","text":"<p>A dataclass to represent object path including timestamps, confidences, and waypoints.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.num_mode","title":"num_mode  <code>property</code>","text":"<pre><code>num_mode: int\n</code></pre> <p>Return the number of trajectory modes.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of trajectory modes.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.num_timestamp","title":"num_timestamp  <code>property</code>","text":"<pre><code>num_timestamp: int\n</code></pre> <p>Return the number of timestamps.</p> <p>Returns:</p> <ul> <li> <code>int</code> (              <code>int</code> )          \u2013            <p>The number of timestamps.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return the shape of the waypoints matrix.</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>Shape of the matrix (M, T, D).</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.translate","title":"translate","text":"<pre><code>translate(x: Vector3Like) -&gt; None\n</code></pre> <p>Apply a translation.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>Vector3Like</code>)           \u2013            <p>3D translation vector.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>def translate(self, x: Vector3Like) -&gt; None:\n    \"\"\"Apply a translation.\n\n    Args:\n        x (Vector3Like): 3D translation vector.\n    \"\"\"\n    self.waypoints += Vector3(x)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.rotate","title":"rotate","text":"<pre><code>rotate(q: RotationLike) -&gt; None\n</code></pre> <p>Apply a rotation.</p> <p>Parameters:</p> <ul> <li> <code>q</code>               (<code>RotationLike</code>)           \u2013            <p>Rotation quaternion.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>def rotate(self, q: RotationLike) -&gt; None:\n    \"\"\"Apply a rotation.\n\n    Args:\n        q (RotationLike): Rotation quaternion.\n    \"\"\"\n    # NOTE: R * X = X * R^T\n    q = to_quaternion(q)\n    self.waypoints = np.dot(self.waypoints, q.rotation_matrix.T)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.Past","title":"Past","text":"<p>Represent the past trajectory features.</p> <p>Note that the expected shape of waypoints is (1, T, D).</p> <p>Attributes:</p> <ul> <li> <code>timestamps</code>               (<code>NDArrayInt</code>)           \u2013            <p>Sequence of timestamps (T,).</p> </li> <li> <code>confidences</code>               (<code>NDArrayFloat</code>)           \u2013            <p>Confidences array for the mode (1,).</p> </li> <li> <code>waypoints</code>               (<code>Trajectory</code>)           \u2013            <p>Waypoints matrix in the shape of (1, T, 3).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; past = Past(\n...     timestamps=[1.0, 2.0]\n...     confidences=[1.0],\n...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]],\n... )\n# Get the number of modes.\n&gt;&gt;&gt; len(past)\n1\n# Access the shape of waypoints matrix: (M, T, 3).\n&gt;&gt;&gt; past.shape\n(1, 2, 3)\n# Access waypoints as subscriptable.\n&gt;&gt;&gt; past[0] # for mode0\narray([[1., 1., 1.],\n       [2., 2., 2.]])\n&gt;&gt;&gt; past[0, 0] # point0 at mode0\narray([1., 1., 1.])\n# Access confidence and waypoints for each mode as iterable.\n&gt;&gt;&gt; for i, (timestamp, confidence, waypoints) in past:\n...     print(f\"Mode{i}: {timestamp}, {confidence}, {waypoints}\")\n...\nMode0: 1.0, 1.0, [[1. 1. 1.] [2. 2. 2.]]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.Future","title":"Future","text":"<p>Represent the future trajectory features.</p> <p>Note that the expected shape of waypoints is (M, T, D).</p> <p>Attributes:</p> <ul> <li> <code>timestamps</code>               (<code>NDArrayInt</code>)           \u2013            <p>Sequence of timestamps (T,).</p> </li> <li> <code>confidences</code>               (<code>NDArrayFloat</code>)           \u2013            <p>Confidences array for each mode (M,).</p> </li> <li> <code>waypoints</code>               (<code>Trajectory</code>)           \u2013            <p>Waypoints matrix in the shape of (M, T, 3).</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; future = Future(\n...     timestamps=[1.0, 2.0]\n...     confidences=[1.0],\n...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]],\n... )\n# Get the number of modes.\n&gt;&gt;&gt; len(future)\n1\n# Access the shape of waypoints matrix: (M, T, 3).\n&gt;&gt;&gt; future.shape\n(1, 2, 3)\n# Access waypoints as subscriptable.\n&gt;&gt;&gt; future[0] # for mode0\narray([[1., 1., 1.],\n       [2., 2., 2.]])\n&gt;&gt;&gt; future[0, 0] # point0 at mode0\narray([1., 1., 1.])\n# Access confidence and waypoints for each mode as iterable.\n&gt;&gt;&gt; for i, (timestamp, confidence, waypoints) in future:\n...     print(f\"Mode{i}: {timestamp}, {confidence}, {waypoints}\")\n...\nMode0: 1.0, 1.0, [[1. 1. 1.] [2. 2. 2.]]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform","title":"t4_devkit.dataclass.transform","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer","title":"TransformBuffer","text":"<p>A buffer class to store transformation matrices.</p> <p>Attributes:</p> <ul> <li> <code>buffer</code>               (<code>dict[tuple[str, str], HomogeneousMatrix]</code>)           \u2013            <p>Matrix buffer whose key is <code>(src, dst)</code>.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.set_transform","title":"set_transform","text":"<pre><code>set_transform(matrix: HomogeneousMatrix) -&gt; None\n</code></pre> <p>Set transform matrix to the buffer. Also, if its inverse transformation has not been registered, registers it too.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>HomogeneousMatrix</code>)           \u2013            <p>Transformation matrix.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def set_transform(self, matrix: HomogeneousMatrix) -&gt; None:\n    \"\"\"Set transform matrix to the buffer.\n    Also, if its inverse transformation has not been registered, registers it too.\n\n    Args:\n        matrix (HomogeneousMatrix): Transformation matrix.\n    \"\"\"\n    src = matrix.src\n    dst = matrix.dst\n    if (src, dst) not in self.buffer:\n        self.buffer[(src, dst)] = matrix\n\n    if (dst, src) not in self.buffer:\n        self.buffer[(dst, src)] = matrix.inv()\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.lookup_transform","title":"lookup_transform","text":"<pre><code>lookup_transform(\n    src: str, dst: str\n) -&gt; HomogeneousMatrix | None\n</code></pre> <p>Look up the transform matrix corresponding to the <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>str</code>)           \u2013            <p>Source frame ID.</p> </li> <li> <code>dst</code>               (<code>str</code>)           \u2013            <p>Destination frame ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HomogeneousMatrix | None</code>           \u2013            <p>Returns <code>HomogeneousMatrix</code> if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def lookup_transform(self, src: str, dst: str) -&gt; HomogeneousMatrix | None:\n    \"\"\"Look up the transform matrix corresponding to the `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        Returns `HomogeneousMatrix` if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    if src == dst:\n        return HomogeneousMatrix.as_identity(src)\n    return self.buffer[(src, dst)] if (src, dst) in self.buffer else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.do_translate","title":"do_translate","text":"<pre><code>do_translate(\n    src: str, dst: str, *args, **kwargs\n) -&gt; TranslateItemLike | None\n</code></pre> <p>Translate specified items with the matrix corresponding to <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>str</code>)           \u2013            <p>Source frame ID.</p> </li> <li> <code>dst</code>               (<code>str</code>)           \u2013            <p>Destination frame ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TranslateItemLike | None</code>           \u2013            <p>TranslateItemLike | None: Returns translated items if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def do_translate(self, src: str, dst: str, *args, **kwargs) -&gt; TranslateItemLike | None:\n    \"\"\"Translate specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        TranslateItemLike | None: Returns translated items if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    tf_matrix = self.lookup_transform(src, dst)\n    return tf_matrix.translate(*args, **kwargs) if tf_matrix is not None else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.do_rotate","title":"do_rotate","text":"<pre><code>do_rotate(\n    src: str, dst: str, *args, **kwargs\n) -&gt; RotateItemLike | None\n</code></pre> <p>Rotate specified items with the matrix corresponding to <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>str</code>)           \u2013            <p>Source frame ID.</p> </li> <li> <code>dst</code>               (<code>str</code>)           \u2013            <p>Destination frame ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RotateItemLike | None</code>           \u2013            <p>TranslateItemLike | None: Returns rotated items if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def do_rotate(self, src: str, dst: str, *args, **kwargs) -&gt; RotateItemLike | None:\n    \"\"\"Rotate specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        TranslateItemLike | None: Returns rotated items if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    tf_matrix = self.lookup_transform(src, dst)\n    return tf_matrix.rotate(*args, **kwargs) if tf_matrix is not None else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.do_transform","title":"do_transform","text":"<pre><code>do_transform(\n    src: str, dst: str, *args, **kwargs\n) -&gt; TransformItemLike | None\n</code></pre> <p>Transform specified items with the matrix corresponding to <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> <ul> <li> <code>src</code>               (<code>str</code>)           \u2013            <p>Source frame ID.</p> </li> <li> <code>dst</code>               (<code>str</code>)           \u2013            <p>Destination frame ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>TransformItemLike | None</code>           \u2013            <p>TranslateItemLike | None: Returns transformed items if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def do_transform(self, src: str, dst: str, *args, **kwargs) -&gt; TransformItemLike | None:\n    \"\"\"Transform specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        TranslateItemLike | None: Returns transformed items if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    tf_matrix = self.lookup_transform(src, dst)\n    return tf_matrix.transform(*args, **kwargs) if tf_matrix is not None else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix","title":"HomogeneousMatrix","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.shape","title":"shape  <code>property</code>","text":"<pre><code>shape: tuple[int, ...]\n</code></pre> <p>Return a shape of the homogeneous matrix.</p> <p>Returns:</p> <ul> <li> <code>tuple[int, ...]</code>           \u2013            <p>Return the shape of (4, 4).</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.yaw_pitch_roll","title":"yaw_pitch_roll  <code>property</code>","text":"<pre><code>yaw_pitch_roll: tuple[float, float, float]\n</code></pre> <p>Return yaw, pitch and roll.</p> NOTE <p>yaw: Rotation angle around the z-axis in [rad], in the range <code>[-pi, pi]</code>. pitch: Rotation angle around the y'-axis in [rad], in the range <code>[-pi/2, pi/2]</code>. roll: Rotation angle around the x\"-axis in [rad], in the range <code>[-pi, pi]</code>.</p> <p>Returns:</p> <ul> <li> <code>tuple[float, float, float]</code>           \u2013            <p>Yaw, pitch and roll in [rad].</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.rotation_matrix","title":"rotation_matrix  <code>property</code>","text":"<pre><code>rotation_matrix: Matrix3x3\n</code></pre> <p>Return a 3x3 rotation matrix.</p> <p>Returns:</p> <ul> <li> <code>Matrix3x3</code>           \u2013            <p>3x3 rotation matrix.</p> </li> </ul>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.as_identity","title":"as_identity  <code>classmethod</code>","text":"<pre><code>as_identity(frame_id: str) -&gt; Self\n</code></pre> <p>Construct a new object with identity.</p> <p>Parameters:</p> <ul> <li> <code>frame_id</code>               (<code>str</code>)           \u2013            <p>Frame ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Constructed self instance.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>@classmethod\ndef as_identity(cls, frame_id: str) -&gt; Self:\n    \"\"\"Construct a new object with identity.\n\n    Args:\n        frame_id (str): Frame ID.\n\n    Returns:\n        Constructed self instance.\n    \"\"\"\n    return cls(np.zeros(3), Quaternion(), frame_id, frame_id)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.from_matrix","title":"from_matrix  <code>classmethod</code>","text":"<pre><code>from_matrix(\n    matrix: Matrix4x4Like | HomogeneousMatrix,\n    src: str | None = None,\n    dst: str | None = None,\n) -&gt; Self\n</code></pre> <p>Construct a new object from a homogeneous matrix.</p> <p>Parameters:</p> <ul> <li> <code>matrix</code>               (<code>Matrix4x4Like | HomogeneousMatrix</code>)           \u2013            <p>4x4 homogeneous matrix.</p> </li> <li> <code>src</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Source frame ID. This must be specified only if the input matrix is <code>Matrix4x4Like</code>.</p> </li> <li> <code>dst</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Destination frame ID. This must be specified only if the input matrix is <code>Matrix4x4Like</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>Constructed self instance.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>@classmethod\ndef from_matrix(\n    cls,\n    matrix: Matrix4x4Like | HomogeneousMatrix,\n    src: str | None = None,\n    dst: str | None = None,\n) -&gt; Self:\n    \"\"\"Construct a new object from a homogeneous matrix.\n\n    Args:\n        matrix (Matrix4x4Like | HomogeneousMatrix): 4x4 homogeneous matrix.\n        src (str | None, optional): Source frame ID.\n            This must be specified only if the input matrix is `Matrix4x4Like`.\n        dst (str | None, optional): Destination frame ID.\n            This must be specified only if the input matrix is `Matrix4x4Like`.\n\n    Returns:\n        Constructed self instance.\n    \"\"\"\n    position, rotation = _extract_position_and_rotation_from_matrix(matrix)\n    if isinstance(matrix, np.ndarray):\n        assert matrix.shape == (4, 4)\n        assert src is not None and dst is not None\n        return cls(position, rotation, src, dst)\n    else:\n        return cls(position, rotation, matrix.src, matrix.dst)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.dot","title":"dot","text":"<pre><code>dot(other: HomogeneousMatrix) -&gt; HomogeneousMatrix\n</code></pre> <p>Return a dot product of myself and another.</p> <p>Parameters:</p> <ul> <li> <code>other</code>               (<code>HomogeneousMatrix</code>)           \u2013            <p><code>HomogeneousMatrix</code> object.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p><code>self.src</code> and <code>other.dst</code> must be the same frame ID.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>HomogeneousMatrix</code>           \u2013            <p>Result of a dot product.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def dot(self, other: HomogeneousMatrix) -&gt; HomogeneousMatrix:\n    \"\"\"Return a dot product of myself and another.\n\n    Args:\n        other (HomogeneousMatrix): `HomogeneousMatrix` object.\n\n    Raises:\n        ValueError: `self.src` and `other.dst` must be the same frame ID.\n\n    Returns:\n        Result of a dot product.\n    \"\"\"\n    if self.src != other.dst:\n        raise ValueError(f\"self.src != other.dst: self.src={self.src}, other.dst={other.dst}\")\n\n    ret_mat = self.matrix.dot(other.matrix)\n    position, rotation = _extract_position_and_rotation_from_matrix(ret_mat)\n    return HomogeneousMatrix(position, rotation, src=other.src, dst=self.dst)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.inv","title":"inv","text":"<pre><code>inv() -&gt; HomogeneousMatrix\n</code></pre> <p>Return a inverse matrix of myself.</p> <p>Returns:</p> <ul> <li> <code>HomogeneousMatrix</code>           \u2013            <p>Inverse matrix.</p> </li> </ul> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def inv(self) -&gt; HomogeneousMatrix:\n    \"\"\"Return a inverse matrix of myself.\n\n    Returns:\n        Inverse matrix.\n    \"\"\"\n    ret_mat = np.linalg.inv(self.matrix)\n    position, rotation = _extract_position_and_rotation_from_matrix(ret_mat)\n    return HomogeneousMatrix(position, rotation, src=self.src, dst=self.dst)\n</code></pre>"},{"location":"apis/filtering/","title":"<code>filtering</code>","text":""},{"location":"apis/filtering/#t4_devkit.filtering.compose","title":"t4_devkit.filtering.compose","text":""},{"location":"apis/filtering/#t4_devkit.filtering.compose.BoxFilter","title":"BoxFilter","text":"<pre><code>BoxFilter(params: FilterParams, tf_buffer: TransformBuffer)\n</code></pre> <p>A class composes multiple filtering functions.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>params</code>               (<code>FilterParams</code>)           \u2013            <p>Filtering parameters.</p> </li> <li> <code>tf_buffer</code>               (<code>TransformBuffer</code>)           \u2013            <p>Transformation buffer.</p> </li> </ul> Source code in <code>t4_devkit/filtering/compose.py</code> <pre><code>def __init__(self, params: FilterParams, tf_buffer: TransformBuffer) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        params (FilterParams): Filtering parameters.\n        tf_buffer (TransformBuffer): Transformation buffer.\n    \"\"\"\n    self.filters: list[BoxFilterFunction] = [\n        FilterByLabel.from_params(params),\n        FilterByUUID.from_params(params),\n        FilterByDistance.from_params(params),\n        FilterByRegion.from_params(params),\n        FilterBySpeed.from_params(params),\n        FilterByNumPoints.from_params(params),\n        FilterByVisibility.from_params(params),\n    ]\n\n    self.tf_buffer = tf_buffer\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional","title":"t4_devkit.filtering.functional","text":""},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByLabel","title":"FilterByLabel","text":"<pre><code>FilterByLabel(\n    labels: Sequence[str | SemanticLabel] | None = None,\n)\n</code></pre> <p>Filter a box by checking if the label of the box is included in specified labels.</p> <p>Note that, if <code>labels</code> is None all boxes pass through this filter.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>labels</code>               (<code>Sequence[str | SemanticLabel] | None</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of target labels. If <code>None</code>, this filter always returns <code>True</code>.</p> </li> </ul> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, labels: Sequence[str | SemanticLabel] | None = None) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        labels (Sequence[str | SemanticLabel] | None, optional): Sequence of target labels.\n            If `None`, this filter always returns `True`.\n    \"\"\"\n    super().__init__()\n    self.labels = labels\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByUUID","title":"FilterByUUID","text":"<pre><code>FilterByUUID(uuids: Sequence[str] | None = None)\n</code></pre> <p>Filter a box by checking if the uuid of the box is included in specified uuids.</p> <p>Note that, if <code>uuids</code> is None all boxes pass through this filter.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>uuids</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of target uuids. If <code>None</code>, this filter always returns <code>True</code>.</p> </li> </ul> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, uuids: Sequence[str] | None = None) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        uuids (Sequence[str] | None, optional): Sequence of target uuids.\n            If `None`, this filter always returns `True`.\n    \"\"\"\n    super().__init__()\n    self.uuids = uuids\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByDistance","title":"FilterByDistance","text":"<pre><code>FilterByDistance(min_distance: float, max_distance: float)\n</code></pre> <p>Filter a box by checking if the box is within the specified distance.</p> <p>Note that, the type box is <code>Box2D</code> and its <code>position</code> is None, these boxes pass through this filter.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>min_distance</code>               (<code>float</code>)           \u2013            <p>Minimum distance from the ego [m].</p> </li> <li> <code>max_distance</code>               (<code>float</code>)           \u2013            <p>Maximum distance from the ego [m].</p> </li> </ul> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_distance: float, max_distance: float) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_distance (float): Minimum distance from the ego [m].\n        max_distance (float): Maximum distance from the ego [m].\n    \"\"\"\n    super().__init__()\n    self.min_distance = min_distance\n    self.max_distance = max_distance\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByRegion","title":"FilterByRegion","text":"<pre><code>FilterByRegion(\n    min_xy: tuple[float, float], max_xy: tuple[float, float]\n)\n</code></pre> <p>Filter a box by checking if the box xy position is within the specified xy region.</p> <p>Note that, the type box is <code>Box2D</code> and its <code>position</code> is None, these boxes pass through this filter.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>min_xy</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Minimum xy position [m].</p> </li> <li> <code>max_xy</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Maximum xy position [m].</p> </li> </ul> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_xy: tuple[float, float], max_xy: tuple[float, float]) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_xy (tuple[float, float]): Minimum xy position [m].\n        max_xy (tuple[float, float]): Maximum xy position [m].\n    \"\"\"\n    super().__init__()\n    self.min_xy = min_xy\n    self.max_xy = max_xy\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterBySpeed","title":"FilterBySpeed","text":"<pre><code>FilterBySpeed(min_speed: float, max_speed: float)\n</code></pre> <p>Filter a 3D box by checking if the box speed is within the specified one.</p> <p>Note that, the type box is <code>Box2D</code>, or <code>Box3D</code> and its <code>velocity</code> is None, these boxes pass through this filter.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>min_speed</code>               (<code>float</code>)           \u2013            <p>Minimum speed [m/s].</p> </li> <li> <code>max_speed</code>               (<code>float</code>)           \u2013            <p>Maximum speed [m/s].</p> </li> </ul> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_speed: float, max_speed: float) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_speed (float): Minimum speed [m/s].\n        max_speed (float): Maximum speed [m/s].\n    \"\"\"\n    super().__init__()\n    self.min_speed = min_speed\n    self.max_speed = max_speed\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByNumPoints","title":"FilterByNumPoints","text":"<pre><code>FilterByNumPoints(min_num_points: int = 0)\n</code></pre> <p>Filter a 3D box by checking if the box includes points greater than the specified one.</p> <p>Note that, the type box is <code>Box2D</code>, or <code>Box3D</code> and its <code>num_points</code> is None, these boxes pass through this filter.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>min_num_points</code>               (<code>int</code>, default:                   <code>0</code> )           \u2013            <p>The minimum number of points that a box should include.</p> </li> </ul> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_num_points: int = 0) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_num_points (int, optional): The minimum number of points that a box should include.\n    \"\"\"\n    super().__init__()\n    self.min_num_points = min_num_points\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByVisibility","title":"FilterByVisibility","text":"<pre><code>FilterByVisibility(\n    visibility: VisibilityLevel = VisibilityLevel.NONE,\n)\n</code></pre> <p>A filter that excludes 3D boxes with lower visibility than a specified threshold.</p> <p>Boxes with <code>UNAVAILABLE</code> visibility are always passed through (i.e., not filtered).</p> <p>Initialize the filter with a visibility threshold.</p> <p>Parameters:</p> <ul> <li> <code>visibility</code>               (<code>VisibilityLevel</code>, default:                   <code>NONE</code> )           \u2013            <p>The minimum visibility level for a box to pass the filter.</p> </li> </ul> <p>Raises:</p> <ul> <li> <code>ValueError</code>             \u2013            <p>If the given visibility is not comparable (e.g., UNAVAILABLE).</p> </li> </ul> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, visibility: VisibilityLevel = VisibilityLevel.NONE) -&gt; None:\n    \"\"\"\n    Initialize the filter with a visibility threshold.\n\n    Args:\n        visibility (VisibilityLevel): The minimum visibility level for a box to pass the filter.\n\n    Raises:\n        ValueError: If the given visibility is not comparable (e.g., UNAVAILABLE).\n    \"\"\"\n    super().__init__()\n    if not visibility.is_comparable():\n        raise ValueError(f\"Comparable visibility must be set as threshold: {visibility}\")\n\n    self.visibility = visibility\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.parameter","title":"t4_devkit.filtering.parameter","text":""},{"location":"apis/filtering/#t4_devkit.filtering.parameter.FilterParams","title":"FilterParams","text":"<p>A dataclass to represent filtering parameters.</p> <p>Attributes:</p> <ul> <li> <code>labels</code>               (<code>Sequence[str | SemanticLabel] | None</code>)           \u2013            <p>Sequence of target labels.</p> </li> <li> <code>uuids</code>               (<code>Sequence[str] | None</code>)           \u2013            <p>Sequence of target uuids.</p> </li> <li> <code>min_distance</code>               (<code>float</code>)           \u2013            <p>Minimum distance from the ego [m].</p> </li> <li> <code>max_distance</code>               (<code>float</code>)           \u2013            <p>Maximum distance from the ego [m].</p> </li> <li> <code>min_xy</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Minimum xy position from the ego [m].</p> </li> <li> <code>min_xy</code>               (<code>tuple[float, float]</code>)           \u2013            <p>Maximum xy position from the ego [m].</p> </li> <li> <code>min_speed</code>               (<code>float</code>)           \u2013            <p>Minimum speed [m/s].</p> </li> <li> <code>max_speed</code>               (<code>float</code>)           \u2013            <p>Maximum speed [m/s].</p> </li> <li> <code>min_num_points</code>               (<code>int</code>)           \u2013            <p>The minimum number of points which the 3D box should include.</p> </li> <li> <code>visibility</code>               (<code>str | VisibilityLevel</code>)           \u2013            <p>Visibility threshold.</p> </li> </ul>"},{"location":"apis/helper/","title":"<code>helper</code>","text":""},{"location":"apis/helper/#t4_devkit.helper","title":"t4_devkit.helper","text":""},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper","title":"RenderingHelper","text":"<pre><code>RenderingHelper(t4: Tier4)\n</code></pre> <p>Help <code>Tier4</code> class with rendering tasks.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>t4</code>               (<code>Tier4</code>)           \u2013            <p><code>Tier4</code> instance.</p> </li> </ul> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def __init__(self, t4: Tier4) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        t4 (Tier4): `Tier4` instance.\n    \"\"\"\n    self._t4 = t4\n    self._label2id: dict[str, int] = {\n        category.name: idx for idx, category in enumerate(self._t4.category)\n    }\n\n    self._executor = concurrent.futures.ThreadPoolExecutor()\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper.render_scene","title":"render_scene","text":"<pre><code>render_scene(\n    *,\n    max_time_seconds: float = np.inf,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Render specified scene.</p> <p>Parameters:</p> <ul> <li> <code>max_time_seconds</code>               (<code>float</code>, default:                   <code>inf</code> )           \u2013            <p>Max time length to be rendered [s].</p> </li> <li> <code>future_seconds</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Future time in [s].</p> </li> <li> <code>save_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> </li> </ul> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def render_scene(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render specified scene.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n    \"\"\"\n    # search first sample data tokens\n    first_lidar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.LIDAR\n    ]\n    first_radar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.RADAR\n    ]\n    first_camera_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.CAMERA\n    ]\n\n    app_id = f\"scene@{self._t4.dataset_id}\"\n    viewer = self._init_viewer(app_id, render_ann=True, save_dir=save_dir)\n\n    self._render_map(viewer)\n\n    scene: Scene = self._t4.scene[0]\n    first_sample: Sample = self._t4.get(\"sample\", scene.first_sample_token)\n    max_timestamp_us = first_sample.timestamp + seconds2microseconds(max_time_seconds)\n\n    concurrent.futures.wait(\n        self._render_lidar_and_ego(\n            viewer=viewer,\n            first_lidar_tokens=first_lidar_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + self._render_radars(\n            viewer=viewer,\n            first_radar_tokens=first_radar_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + self._render_cameras(\n            viewer=viewer,\n            first_camera_tokens=first_camera_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + [\n            self._executor.submit(\n                self._render_annotation3ds(\n                    viewer=viewer,\n                    first_sample_token=scene.first_sample_token,\n                    max_timestamp_us=max_timestamp_us,\n                    future_seconds=future_seconds,\n                )\n            ),\n            self._executor.submit(\n                self._render_annotation2ds(\n                    viewer=viewer,\n                    first_sample_token=scene.first_sample_token,\n                    max_timestamp_us=max_timestamp_us,\n                )\n            ),\n        ]\n    )\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper.render_instance","title":"render_instance","text":"<pre><code>render_instance(\n    instance_token: str | Sequence[str],\n    *,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Render particular instance.</p> <p>Parameters:</p> <ul> <li> <code>instance_token</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>Instance token(s).</p> </li> <li> <code>future_seconds</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Future time in [s].</p> </li> <li> <code>save_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> </li> </ul> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def render_instance(\n    self,\n    instance_token: str | Sequence[str],\n    *,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render particular instance.\n\n    Args:\n        instance_token (str | Sequence[str]): Instance token(s).\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n\n    \"\"\"\n    instance_tokens = [instance_token] if isinstance(instance_token, str) else instance_token\n\n    first_sample: Sample | None = None\n    last_sample: Sample | None = None\n    for token in instance_tokens:\n        instance: Instance = self._t4.get(\"instance\", token)\n        first_ann: SampleAnnotation = self._t4.get(\n            \"sample_annotation\", instance.first_annotation_token\n        )\n        current_first_sample: Sample = self._t4.get(\"sample\", first_ann.sample_token)\n        if first_sample is None or current_first_sample.timestamp &lt; first_sample.timestamp:\n            first_sample = current_first_sample\n\n        last_ann: SampleAnnotation = self._t4.get(\n            \"sample_annotation\", instance.last_annotation_token\n        )\n        current_last_sample: Sample = self._t4.get(\"sample\", last_ann.sample_token)\n        if last_sample is None or current_last_sample.timestamp &gt; last_sample.timestamp:\n            last_sample = current_last_sample\n\n    max_timestamp_us = last_sample.timestamp\n\n    # search first sample data tokens\n    first_lidar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.LIDAR\n    ]\n    first_radar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.RADAR\n    ]\n    first_camera_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.CAMERA\n    ]\n\n    app_id = f\"instance@{self._t4.dataset_id}\"\n    viewer = self._init_viewer(app_id, render_ann=True, save_dir=save_dir)\n\n    self._render_map(viewer)\n\n    concurrent.futures.wait(\n        self._render_lidar_and_ego(\n            viewer=viewer,\n            first_lidar_tokens=first_lidar_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + self._render_radars(\n            viewer=viewer,\n            first_radar_tokens=first_radar_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + self._render_cameras(\n            viewer=viewer,\n            first_camera_tokens=first_camera_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + [\n            self._executor.submit(\n                self._render_annotation3ds(\n                    viewer=viewer,\n                    first_sample_token=first_sample.token,\n                    max_timestamp_us=max_timestamp_us,\n                    future_seconds=future_seconds,\n                    instance_tokens=instance_tokens,\n                )\n            ),\n            self._executor.submit(\n                self._render_annotation2ds(\n                    viewer=viewer,\n                    first_sample_token=first_sample.token,\n                    max_timestamp_us=max_timestamp_us,\n                    instance_tokens=instance_tokens,\n                )\n            ),\n        ],\n    )\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper.render_pointcloud","title":"render_pointcloud","text":"<pre><code>render_pointcloud(\n    *,\n    max_time_seconds: float = np.inf,\n    ignore_distortion: bool = True,\n    save_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Render pointcloud on 3D and 2D view.</p> <p>Parameters:</p> <ul> <li> <code>max_time_seconds</code>               (<code>float</code>, default:                   <code>inf</code> )           \u2013            <p>Max time length to be rendered [s].</p> </li> <li> <code>ignore_distortion</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to ignore distortion parameters.</p> </li> <li> <code>save_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> </li> </ul> TODO <p>Add an option of rendering radar channels.</p> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def render_pointcloud(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    ignore_distortion: bool = True,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render pointcloud on 3D and 2D view.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        ignore_distortion (bool, optional): Whether to ignore distortion parameters.\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n\n    TODO:\n        Add an option of rendering radar channels.\n    \"\"\"\n    # initialize viewer\n    app_id = f\"pointcloud@{self._t4.dataset_id}\"\n    viewer = self._init_viewer(app_id, render_ann=False, save_dir=save_dir)\n\n    self._render_map(viewer)\n\n    # search first lidar sample data token\n    first_lidar_token: str | None = None\n    for sensor in self._t4.sensor:\n        if sensor.modality != SensorModality.LIDAR:\n            continue\n        first_lidar_token = sensor.first_sd_token\n\n    if first_lidar_token is None:\n        raise ValueError(\"There is no 3D pointcloud data.\")\n\n    first_lidar_sample_data: Sample = self._t4.get(\"sample_data\", first_lidar_token)\n    max_timestamp_us = first_lidar_sample_data.timestamp + seconds2microseconds(\n        max_time_seconds\n    )\n\n    concurrent.futures.wait(\n        self._render_lidar_and_ego(\n            viewer=viewer,\n            first_lidar_tokens=[first_lidar_token],\n            max_timestamp_us=max_timestamp_us,\n        )\n        + self._render_points_on_cameras(\n            first_point_sample_data_token=first_lidar_token,\n            max_timestamp_us=max_timestamp_us,\n            min_dist=1.0,\n            ignore_distortion=ignore_distortion,\n        ),\n    )\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.TimeseriesHelper","title":"TimeseriesHelper","text":"<pre><code>TimeseriesHelper(t4: Tier4)\n</code></pre> <p>Help <code>Tier4</code> class with timeseries relevant operations.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>t4</code>               (<code>Tier4</code>)           \u2013            <p><code>Tier4</code> instance.</p> </li> </ul> Source code in <code>t4_devkit/helper/timeseries.py</code> <pre><code>def __init__(self, t4: Tier4) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        t4 (Tier4): `Tier4` instance.\n    \"\"\"\n    self._t4 = t4\n\n    self._sample_and_instance_to_ann3d: dict[tuple[str, str], str] = {\n        (ann.sample_token, ann.instance_token): ann.token for ann in self._t4.sample_annotation\n    }\n    self._sample_data_and_instance_to_ann2d: dict[tuple[str, str], str] = {\n        (ann.sample_data_token, ann.instance_token): ann.token for ann in self._t4.object_ann\n    }\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.TimeseriesHelper.get_sample_annotations_until","title":"get_sample_annotations_until","text":"<pre><code>get_sample_annotations_until(\n    instance_token: str, sample_token: str, seconds: float\n) -&gt; tuple[list[int], list[SampleAnnotation]]\n</code></pre> <p>Return a list of sample annotations until the specified seconds.</p> <p>If <code>seconds&gt;=0</code> explores future, otherwise past.</p> <p>Parameters:</p> <ul> <li> <code>instance_token</code>               (<code>str</code>)           \u2013            <p>Instance token of any sample annotations.</p> </li> <li> <code>sample_token</code>               (<code>str</code>)           \u2013            <p>Start sample token.</p> </li> <li> <code>seconds</code>               (<code>float</code>)           \u2013            <p>Time seconds until. If <code>&gt;=0</code> explore future, otherwise past.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[int], list[SampleAnnotation]]</code>           \u2013            <p>List of timestamps and associated sample annotation records of the specified instance.</p> </li> </ul> Source code in <code>t4_devkit/helper/timeseries.py</code> <pre><code>def get_sample_annotations_until(\n    self,\n    instance_token: str,\n    sample_token: str,\n    seconds: float,\n) -&gt; tuple[list[int], list[SampleAnnotation]]:\n    \"\"\"Return a list of sample annotations until the specified seconds.\n\n    If `seconds&gt;=0` explores future, otherwise past.\n\n    Args:\n        instance_token (str): Instance token of any sample annotations.\n        sample_token (str): Start sample token.\n        seconds (float): Time seconds until. If `&gt;=0` explore future, otherwise past.\n\n    Returns:\n        List of timestamps and associated sample annotation records of the specified instance.\n    \"\"\"\n    start_sample: Sample = self._t4.get(\"sample\", sample_token)\n\n    timestamps: list[int] = []\n    anns: list[SampleAnnotation] = []\n    is_successor = seconds &gt;= 0\n    current_sample_token = start_sample.next if is_successor else start_sample.prev\n    while current_sample_token != \"\":\n        current_sample: Sample = self._t4.get(\"sample\", current_sample_token)\n\n        if abs(microseconds2seconds(current_sample.timestamp - start_sample.timestamp)) &gt; abs(\n            seconds\n        ):\n            break\n\n        ann_token = self._sample_and_instance_to_ann3d.get(\n            (current_sample_token, instance_token)\n        )\n        if ann_token is not None:\n            timestamps.append(current_sample.timestamp)\n            anns.append(self._t4.get(\"sample_annotation\", ann_token))\n\n        current_sample_token = current_sample.next if is_successor else current_sample.prev\n\n    return timestamps, anns\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.TimeseriesHelper.get_object_anns_until","title":"get_object_anns_until","text":"<pre><code>get_object_anns_until(\n    instance_token: str,\n    sample_data_token: str,\n    seconds: float,\n) -&gt; tuple[list[int], list[ObjectAnn]]\n</code></pre> <p>Return a list of object anns until the specified seconds.</p> <p>If <code>seconds&gt;=0</code> explores future, otherwise past.</p> <p>Parameters:</p> <ul> <li> <code>instance_token</code>               (<code>str</code>)           \u2013            <p>Instance token of any object anns.</p> </li> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Start sample data token.</p> </li> <li> <code>seconds</code>               (<code>float</code>)           \u2013            <p>Time seconds until. If <code>&gt;=0</code> explore future, otherwise past.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[list[int], list[ObjectAnn]]</code>           \u2013            <p>List of timestamps and associated object annotation records of the specified instance.</p> </li> </ul> Source code in <code>t4_devkit/helper/timeseries.py</code> <pre><code>def get_object_anns_until(\n    self,\n    instance_token: str,\n    sample_data_token: str,\n    seconds: float,\n) -&gt; tuple[list[int], list[ObjectAnn]]:\n    \"\"\"Return a list of object anns until the specified seconds.\n\n    If `seconds&gt;=0` explores future, otherwise past.\n\n    Args:\n        instance_token (str): Instance token of any object anns.\n        sample_data_token (str): Start sample data token.\n        seconds (float): Time seconds until. If `&gt;=0` explore future, otherwise past.\n\n    Returns:\n        List of timestamps and associated object annotation records of the specified instance.\n    \"\"\"\n    start_sample_data: SampleData = self._t4.get(\"sample_data\", sample_data_token)\n\n    timestamps: list[int] = []\n    anns: list[ObjectAnn] = []\n    is_successor = seconds &gt;= 0\n    current_sample_data_token = (\n        start_sample_data.next if is_successor else start_sample_data.prev\n    )\n    while current_sample_data_token != \"\":\n        current_sample_data: SampleData = self._t4.get(\"sample_data\", current_sample_data_token)\n\n        if abs(\n            microseconds2seconds(current_sample_data.timestamp - start_sample_data.timestamp)\n        ) &gt; abs(seconds):\n            break\n\n        ann_token = self._sample_data_and_instance_to_ann2d.get(\n            (current_sample_data_token, instance_token)\n        )\n        if ann_token is not None:\n            timestamps.append(current_sample_data.timestamp)\n            anns.append(self._t4.get(\"object_ann\", ann_token))\n\n        current_sample_data_token = (\n            current_sample_data.next if is_successor else current_sample_data.prev\n        )\n\n    return timestamps, anns\n</code></pre>"},{"location":"apis/sanity/","title":"<code>sanity</code>","text":""},{"location":"apis/sanity/#t4_devkit.sanity","title":"t4_devkit.sanity","text":""},{"location":"apis/sanity/#t4_devkit.sanity.Checker","title":"Checker","text":"<p>Base class for sanity checkers.</p>"},{"location":"apis/sanity/#t4_devkit.sanity.Checker.can_skip","title":"can_skip","text":"<pre><code>can_skip(_: SanityContext) -&gt; Maybe[Reason]\n</code></pre> <p>Return a skip reason if the checker should be skipped.</p> Source code in <code>t4_devkit/sanity/checker.py</code> <pre><code>def can_skip(self, _: SanityContext) -&gt; Maybe[Reason]:\n    \"\"\"Return a skip reason if the checker should be skipped.\"\"\"\n    return Nothing\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Checker.check","title":"check  <code>abstractmethod</code>","text":"<pre><code>check(context: SanityContext) -&gt; list[Reason] | None\n</code></pre> <p>Return a list of reasons if the checker fails, or None if it passes.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>SanityContext</code>)           \u2013            <p>The sanity context.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Reason] | None</code>           \u2013            <p>A list of reasons if the checker fails, or None if it passes.</p> </li> </ul> Source code in <code>t4_devkit/sanity/checker.py</code> <pre><code>@abstractmethod\ndef check(self, context: SanityContext) -&gt; list[Reason] | None:\n    \"\"\"Return a list of reasons if the checker fails, or None if it passes.\n\n    Args:\n        context (SanityContext): The sanity context.\n\n    Returns:\n        A list of reasons if the checker fails, or None if it passes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.RuleGroup","title":"RuleGroup","text":""},{"location":"apis/sanity/#t4_devkit.sanity.RuleGroup.values","title":"values  <code>classmethod</code>","text":"<pre><code>values() -&gt; list[str]\n</code></pre> <p>Return a list of all rule group values.</p> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>@classmethod\ndef values(cls) -&gt; list[str]:\n    \"\"\"Return a list of all rule group values.\"\"\"\n    return [group.value for group in cls]\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.RuleGroup.to_group","title":"to_group  <code>classmethod</code>","text":"<pre><code>to_group(id: RuleID) -&gt; RuleGroup | None\n</code></pre> <p>Convert a rule ID to a rule group.</p> <p>Parameters:</p> <ul> <li> <code>id</code>               (<code>RuleID</code>)           \u2013            <p>The ID of the rule.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>RuleGroup | None</code>           \u2013            <p>The rule group if the rule ID belongs to any rule group, otherwise None.</p> </li> </ul> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>@classmethod\ndef to_group(cls, id: RuleID) -&gt; RuleGroup | None:\n    \"\"\"Convert a rule ID to a rule group.\n\n    Args:\n        id (RuleID): The ID of the rule.\n\n    Returns:\n        The rule group if the rule ID belongs to any rule group, otherwise None.\n    \"\"\"\n    for g in RuleGroup:\n        if g.value in id:\n            return g\n    return None\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.CheckerRegistry","title":"CheckerRegistry","text":""},{"location":"apis/sanity/#t4_devkit.sanity.CheckerRegistry.register","title":"register","text":"<pre><code>register() -&gt; Callable\n</code></pre> <p>Register a checker class.</p> <p>Returns:</p> <ul> <li> <code>Callable</code>           \u2013            <p>A decorator function that registers the checker class.</p> </li> </ul> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>def register(self) -&gt; Callable:\n    \"\"\"Register a checker class.\n\n    Returns:\n        A decorator function that registers the checker class.\n    \"\"\"\n\n    def _register_decorator(module: type[Checker]) -&gt; type[Checker]:\n        self._add_module(module)\n        return module\n\n    return _register_decorator\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.CheckerRegistry.build","title":"build","text":"<pre><code>build(\n    excludes: Sequence[str] | None = None,\n) -&gt; list[Checker]\n</code></pre> <p>Build a list of checkers from the registry.</p> <p>Parameters:</p> <ul> <li> <code>excludes</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of rule IDs or rule groups to exclude.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Checker]</code>           \u2013            <p>A list of checkers.</p> </li> </ul> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>def build(self, excludes: Sequence[str] | None = None) -&gt; list[Checker]:\n    \"\"\"Build a list of checkers from the registry.\n\n    Args:\n        excludes (Sequence[str] | None, optional): A list of rule IDs or rule groups to exclude.\n\n    Returns:\n        A list of checkers.\n    \"\"\"\n    if excludes is None:\n        excludes = []\n\n    return [\n        checker()\n        for group, values in self.items()\n        for id, checker in values.items()\n        if id not in excludes and group.value not in excludes\n    ]\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Status","title":"Status","text":"<p>Runtime outcome per checker.</p>"},{"location":"apis/sanity/#t4_devkit.sanity.Report","title":"Report","text":"<p>A report for a rule.</p> <p>Attributes:</p> <ul> <li> <code>id</code>               (<code>RuleID</code>)           \u2013            <p>The ID of the rule.</p> </li> <li> <code>name</code>               (<code>RuleName</code>)           \u2013            <p>The name of the rule.</p> </li> <li> <code>severity</code>               (<code>Severity</code>)           \u2013            <p>The severity of the rule.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>The description of the rule.</p> </li> <li> <code>status</code>               (<code>Status</code>)           \u2013            <p>The status of the report.</p> </li> <li> <code>reasons</code>               (<code>list[Reason] | None</code>)           \u2013            <p>The list of reasons for the report if the report is a failure or skipped.</p> </li> </ul>"},{"location":"apis/sanity/#t4_devkit.sanity.Report.is_passed","title":"is_passed","text":"<pre><code>is_passed(*, strict: bool = False) -&gt; bool\n</code></pre> <p>Check if the status is passed.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_passed(self, *, strict: bool = False) -&gt; bool:\n    \"\"\"Check if the status is passed.\"\"\"\n    return (\n        self.status == Status.PASSED\n        or self.is_skipped()\n        or (not strict and self.severity.is_warning())\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Report.is_failed","title":"is_failed","text":"<pre><code>is_failed(*, strict: bool = False) -&gt; bool\n</code></pre> <p>Check if the status is failed.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_failed(self, *, strict: bool = False) -&gt; bool:\n    \"\"\"Check if the status is failed.\"\"\"\n    return (self.status == Status.FAILED and self.severity.is_error()) or not (\n        self.is_passed(strict=strict) or self.is_skipped()\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Report.is_skipped","title":"is_skipped","text":"<pre><code>is_skipped() -&gt; bool\n</code></pre> <p>Check if the status is skipped.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_skipped(self) -&gt; bool:\n    \"\"\"Check if the status is skipped.\"\"\"\n    return self.status == Status.SKIPPED\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult","title":"SanityResult","text":"<p>The result of a Sanity check.</p> <p>Attributes:</p> <ul> <li> <code>dataset_id</code>               (<code>str</code>)           \u2013            <p>The ID of the dataset.</p> </li> <li> <code>version</code>               (<code>str | None</code>)           \u2013            <p>The version of the dataset.</p> </li> <li> <code>reports</code>               (<code>list[Report]</code>)           \u2013            <p>The list of reports.</p> </li> </ul>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult.from_context","title":"from_context  <code>classmethod</code>","text":"<pre><code>from_context(\n    context: SanityContext, reports: list[Report]\n) -&gt; Self\n</code></pre> <p>Create a SanityResult from a SanityContext and a list of reports.</p> <p>Parameters:</p> <ul> <li> <code>context</code>               (<code>SanityContext</code>)           \u2013            <p>The SanityContext to use.</p> </li> <li> <code>reports</code>               (<code>list[Report]</code>)           \u2013            <p>The list of reports to include in the result.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Self</code>           \u2013            <p>The created SanityResult.</p> </li> </ul> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>@classmethod\ndef from_context(cls, context: SanityContext, reports: list[Report]) -&gt; Self:\n    \"\"\"Create a SanityResult from a SanityContext and a list of reports.\n\n    Args:\n        context (SanityContext): The SanityContext to use.\n        reports (list[Report]): The list of reports to include in the result.\n\n    Returns:\n        The created SanityResult.\n    \"\"\"\n    return cls(\n        dataset_id=context.dataset_id.value_or(\"UNKNOWN\"),\n        version=context.version.value_or(None),\n        reports=reports,\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult.is_passed","title":"is_passed","text":"<pre><code>is_passed(*, strict: bool = False) -&gt; bool\n</code></pre> <p>Return True if all reports are passed, False otherwise.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to consider warnings as failures.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>True if all reports are passed, False otherwise.</p> </li> </ul> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_passed(self, *, strict: bool = False) -&gt; bool:\n    \"\"\"Return True if all reports are passed, False otherwise.\n\n    Args:\n        strict (bool): Whether to consider warnings as failures.\n\n    Returns:\n        True if all reports are passed, False otherwise.\n    \"\"\"\n    return all(report.is_passed(strict=strict) for report in self.reports)\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult.to_str","title":"to_str","text":"<pre><code>to_str(*, strict: bool = False) -&gt; str\n</code></pre> <p>Return a string representation of the result.</p> <p>Parameters:</p> <ul> <li> <code>strict</code>               (<code>bool</code>, default:                   <code>False</code> )           \u2013            <p>Whether to consider warnings as failures.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>A string representation of the result.</p> </li> </ul> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def to_str(self, *, strict: bool = False) -&gt; str:\n    \"\"\"Return a string representation of the result.\n\n    Args:\n        strict (bool): Whether to consider warnings as failures.\n\n    Returns:\n        A string representation of the result.\n    \"\"\"\n    string = f\"=== DatasetID: {self.dataset_id} ===\\n\"\n    for report in self.reports:\n        if not report.is_passed(strict=strict):\n            string += f\"\\033[31m  {report.id}:\\033[0m\\n\"\n            for reason in report.reasons or []:\n                string += f\"\\033[31m     - {reason}\\033[0m\\n\"\n        elif report.is_skipped():\n            string += f\"\\033[36m  {report.id}: [SKIPPED]\\033[0m\\n\"\n            for reason in report.reasons or []:\n                string += f\"\\033[36m     - {reason}\\033[0m\\n\"\n        elif report.severity.is_warning() and report.reasons:\n            string += f\"\\033[33m  {report.id}:\\033[0m\\n\"\n            for reason in report.reasons or []:\n                string += f\"\\033[33m     - {reason}\\033[0m\\n\"\n        else:\n            string += f\"\\033[32m  {report.id}: \u2705\\033[0m\\n\"\n    return string\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.print_sanity_result","title":"print_sanity_result","text":"<pre><code>print_sanity_result(\n    result: SanityResult, *, strict: bool = False\n) -&gt; None\n</code></pre> <p>Print detailed and summary results of a sanity check.</p> <p>Parameters:</p> <ul> <li> <code>result</code>               (<code>SanityResult</code>)           \u2013            <p>The result of a sanity check.</p> </li> </ul> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def print_sanity_result(result: SanityResult, *, strict: bool = False) -&gt; None:\n    \"\"\"Print detailed and summary results of a sanity check.\n\n    Args:\n        result (SanityResult): The result of a sanity check.\n    \"\"\"\n    # print detailed result\n    print(result.to_str(strict=strict))\n\n    # print summary result\n    passed = sum(1 for rp in result.reports if rp.is_passed(strict=strict))\n    failed = sum(1 for rp in result.reports if not rp.is_passed(strict=strict))\n    skipped = sum(1 for rp in result.reports if rp.is_skipped())\n\n    # just count the number of warnings\n    warnings = sum(1 for rp in result.reports if rp.severity.is_warning() and rp.reasons)\n\n    summary_rows = [[result.dataset_id, result.version, passed, failed, skipped, warnings]]\n\n    print(\n        tabulate(\n            summary_rows,\n            headers=[\"DatasetID\", \"Version\", \"Passed\", \"Failed\", \"Skipped\", \"Warnings\"],\n            tablefmt=\"pretty\",\n        ),\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.sanity_check","title":"sanity_check","text":"<pre><code>sanity_check(\n    data_root: str,\n    revision: str | None = None,\n    *,\n    excludes: Sequence[str] | None = None,\n) -&gt; SanityResult\n</code></pre> <p>Run sanity checks on the given data root.</p> <p>Parameters:</p> <ul> <li> <code>data_root</code>               (<code>str</code>)           \u2013            <p>The root directory of the data.</p> </li> <li> <code>revision</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>The revision to check. If None, the latest revision is used.</p> </li> <li> <code>excludes</code>               (<code>Sequence[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>A list of rule names or groups to exclude.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SanityResult</code>           \u2013            <p>A SanityResult object.</p> </li> </ul> Source code in <code>t4_devkit/sanity/run.py</code> <pre><code>def sanity_check(\n    data_root: str,\n    revision: str | None = None,\n    *,\n    excludes: Sequence[str] | None = None,\n) -&gt; SanityResult:\n    \"\"\"Run sanity checks on the given data root.\n\n    Args:\n        data_root (str): The root directory of the data.\n        revision (str | None, optional): The revision to check. If None, the latest revision is used.\n        excludes (Sequence[str] | None, optional): A list of rule names or groups to exclude.\n\n    Returns:\n        A SanityResult object.\n    \"\"\"\n    context = SanityContext.from_path(data_root, revision=revision)\n\n    checkers = CHECKERS.build(excludes=excludes)\n    reports = [checker(context) for checker in checkers]\n\n    return SanityResult.from_context(context, reports)\n</code></pre>"},{"location":"apis/tier4/","title":"TIER IV API","text":""},{"location":"apis/tier4/#t4_devkit.tier4","title":"t4_devkit.tier4","text":""},{"location":"apis/tier4/#t4_devkit.tier4.DBMetadata","title":"DBMetadata","text":"<p>A dataclass to represent dataset metadata.</p> <p>Attributes:</p> <ul> <li> <code>data_root</code>               (<code>str</code>)           \u2013            <p>Root directory path.</p> </li> <li> <code>dataset_id</code>               (<code>str</code>)           \u2013            <p>Unique dataset ID.</p> </li> <li> <code>version</code>               (<code>str | None</code>)           \u2013            <p>Dataset version.</p> </li> </ul>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4","title":"Tier4","text":"<pre><code>Tier4(\n    data_root: str,\n    revision: str | None = None,\n    verbose: bool = True,\n)\n</code></pre> <p>Database class for T4 dataset to help query and retrieve information from the database.</p> <p>Load database and creates reverse indexes and shortcuts.</p> <p>Parameters:</p> <ul> <li> <code>data_root</code>               (<code>str</code>)           \u2013            <p>Path to the root directory of dataset.</p> </li> <li> <code>revision</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>You can specify any specific version if you want. If None, search the latest one.</p> </li> <li> <code>verbose</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to display status during load.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from t4_devkit import Tier4\n&gt;&gt;&gt; t4 = Tier4(\"data/tier4\")\n======\nLoading T4 tables in `annotation`...\nReverse indexing...\nDone reverse indexing in 0.010 seconds.\n======\n21 category\n8 attribute\n4 visibility\n31 instance\n7 sensor\n7 calibrated_sensor\n2529 ego_pose\n1 log\n1 scene\n88 sample\n2529 sample_data\n1919 sample_annotation\n0 object_ann\n0 surface_ann\n0 keypoint\n1 map\nDone loading in 0.046 seconds.\n======\n</code></pre> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def __init__(\n    self,\n    data_root: str,\n    revision: str | None = None,\n    verbose: bool = True,\n) -&gt; None:\n    \"\"\"Load database and creates reverse indexes and shortcuts.\n\n    Args:\n        data_root (str): Path to the root directory of dataset.\n        revision (str | None, optional): You can specify any specific version if you want.\n            If None, search the latest one.\n        verbose (bool, optional): Whether to display status during load.\n\n    Examples:\n        &gt;&gt;&gt; from t4_devkit import Tier4\n        &gt;&gt;&gt; t4 = Tier4(\"data/tier4\")\n        ======\n        Loading T4 tables in `annotation`...\n        Reverse indexing...\n        Done reverse indexing in 0.010 seconds.\n        ======\n        21 category\n        8 attribute\n        4 visibility\n        31 instance\n        7 sensor\n        7 calibrated_sensor\n        2529 ego_pose\n        1 log\n        1 scene\n        88 sample\n        2529 sample_data\n        1919 sample_annotation\n        0 object_ann\n        0 surface_ann\n        0 keypoint\n        1 map\n        Done loading in 0.046 seconds.\n        ======\n\n    \"\"\"\n    self._metadata = load_metadata(data_root, revision)\n\n    if not osp.exists(self.data_root):\n        raise FileNotFoundError(f\"Database directory is not found: {self.data_root}\")\n\n    if self.version is None:\n        warnings.warn(\n            f\"DatasetID: {self.dataset_id} does't contain any versions.\", DeprecationWarning\n        )\n\n    start_time = time.time()\n    if verbose:\n        print(\"======\\nLoading T4 tables...\")\n\n    # assign tables explicitly\n    self.attribute: list[Attribute] = load_table(self.annotation_dir, SchemaName.ATTRIBUTE)\n    self.calibrated_sensor: list[CalibratedSensor] = load_table(\n        self.annotation_dir, SchemaName.CALIBRATED_SENSOR\n    )\n    self.category: list[Category] = load_table(self.annotation_dir, SchemaName.CATEGORY)\n    self.ego_pose: list[EgoPose] = load_table(self.annotation_dir, SchemaName.EGO_POSE)\n    self.instance: list[Instance] = load_table(self.annotation_dir, SchemaName.INSTANCE)\n    self.keypoint: list[Keypoint] = load_table(self.annotation_dir, SchemaName.KEYPOINT)\n    self.lidarseg: list[LidarSeg] = load_table(self.annotation_dir, SchemaName.LIDARSEG)\n    self.log: list[Log] = load_table(self.annotation_dir, SchemaName.LOG)\n    self.map: list[Map] = load_table(self.annotation_dir, SchemaName.MAP)\n    self.object_ann: list[ObjectAnn] = load_table(self.annotation_dir, SchemaName.OBJECT_ANN)\n    self.sample_annotation: list[SampleAnnotation] = load_table(\n        self.annotation_dir, SchemaName.SAMPLE_ANNOTATION\n    )\n    self.sample_data: list[SampleData] = load_table(self.annotation_dir, SchemaName.SAMPLE_DATA)\n    self.sample: list[Sample] = load_table(self.annotation_dir, SchemaName.SAMPLE)\n    self.scene: list[Scene] = load_table(self.annotation_dir, SchemaName.SCENE)\n    self.sensor: list[Sensor] = load_table(self.annotation_dir, SchemaName.SENSOR)\n    self.surface_ann: list[SurfaceAnn] = load_table(self.annotation_dir, SchemaName.SURFACE_ANN)\n    self.vehicle_state: list[VehicleState] = load_table(\n        self.annotation_dir, SchemaName.VEHICLE_STATE\n    )\n    self.visibility: list[Visibility] = load_table(self.annotation_dir, SchemaName.VISIBILITY)\n\n    # make reverse indexes for common lookups\n    self.__make_reverse_index__(verbose)\n\n    if verbose:\n        for schema in SchemaName:\n            print(f\"{len(self.get_table(schema))} {schema.value}\")\n        elapsed_time = time.time() - start_time\n        print(f\"Done loading in {elapsed_time:.3f} seconds.\\n======\")\n\n    # initialize helpers after finishing construction of Tier4\n    self._timeseries_helper = TimeseriesHelper(self)\n    self._rendering_helper = RenderingHelper(self)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.data_root","title":"data_root  <code>property</code>","text":"<pre><code>data_root: str\n</code></pre> <p>Return the path to dataset root directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.dataset_id","title":"dataset_id  <code>property</code>","text":"<pre><code>dataset_id: str\n</code></pre> <p>Return the dataset ID.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.version","title":"version  <code>property</code>","text":"<pre><code>version: str | None\n</code></pre> <p>Return the dataset version, or None if it is failed to lookup.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.annotation_dir","title":"annotation_dir  <code>property</code>","text":"<pre><code>annotation_dir: str\n</code></pre> <p>Return the path to annotation directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.map_dir","title":"map_dir  <code>property</code>","text":"<pre><code>map_dir: str\n</code></pre> <p>Return the path to map directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.bag_dir","title":"bag_dir  <code>property</code>","text":"<pre><code>bag_dir: str\n</code></pre> <p>Return the path to ROS bag directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_table","title":"get_table","text":"<pre><code>get_table(schema: str | SchemaName) -&gt; list[SchemaTable]\n</code></pre> <p>Return the list of dataclasses corresponding to the schema table.</p> <p>Parameters:</p> <ul> <li> <code>schema</code>               (<code>str | SchemaName</code>)           \u2013            <p>Name of schema table.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[SchemaTable]</code>           \u2013            <p>List of dataclasses.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_table(self, schema: str | SchemaName) -&gt; list[SchemaTable]:\n    \"\"\"Return the list of dataclasses corresponding to the schema table.\n\n    Args:\n        schema (str | SchemaName): Name of schema table.\n\n    Returns:\n        List of dataclasses.\n    \"\"\"\n    return getattr(self, SchemaName(schema))\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get","title":"get","text":"<pre><code>get(schema: str | SchemaName, token: str) -&gt; SchemaTable\n</code></pre> <p>Return a record identified by the associated token.</p> <p>Parameters:</p> <ul> <li> <code>schema</code>               (<code>str | SchemaName</code>)           \u2013            <p>Name of schema.</p> </li> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Token to identify the specific record.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SchemaTable</code>           \u2013            <p>Table record of the corresponding token.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get(self, schema: str | SchemaName, token: str) -&gt; SchemaTable:\n    \"\"\"Return a record identified by the associated token.\n\n    Args:\n        schema (str | SchemaName): Name of schema.\n        token (str): Token to identify the specific record.\n\n    Returns:\n        Table record of the corresponding token.\n    \"\"\"\n    return self.get_table(schema)[self.get_idx(schema, token)]\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_idx","title":"get_idx","text":"<pre><code>get_idx(schema: str | SchemaName, token: str) -&gt; int\n</code></pre> <p>Return the index of the record in a table in constant runtime.</p> <p>Parameters:</p> <ul> <li> <code>schema</code>               (<code>str | SchemaName</code>)           \u2013            <p>Name of schema.</p> </li> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Token of record.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>int</code>           \u2013            <p>The index of the record in table.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_idx(self, schema: str | SchemaName, token: str) -&gt; int:\n    \"\"\"Return the index of the record in a table in constant runtime.\n\n    Args:\n        schema (str | SchemaName): Name of schema.\n        token (str): Token of record.\n\n    Returns:\n        The index of the record in table.\n    \"\"\"\n    schema = SchemaName(schema)\n    if self._token2idx.get(schema) is None:\n        raise KeyError(f\"{schema} is not registered.\")\n    if self._token2idx[schema].get(token) is None:\n        raise KeyError(f\"{token} is not registered in {schema}.\")\n    return self._token2idx[schema][token]\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_sample_data_path","title":"get_sample_data_path","text":"<pre><code>get_sample_data_path(sample_data_token: str) -&gt; str\n</code></pre> <p>Return the file path to a raw data recorded in <code>sample_data</code>.</p> <p>Parameters:</p> <ul> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>sample_data</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>File path.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_sample_data_path(self, sample_data_token: str) -&gt; str:\n    \"\"\"Return the file path to a raw data recorded in `sample_data`.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n\n    Returns:\n        File path.\n    \"\"\"\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    return osp.join(self.data_root, sd_record.filename)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_sample_data","title":"get_sample_data","text":"<pre><code>get_sample_data(\n    sample_data_token: str,\n    *,\n    selected_ann_tokens: list[str] | None = None,\n    as_3d: bool = True,\n    as_sensor_coord: bool = True,\n    future_seconds: float = 0.0,\n    visibility: VisibilityLevel = VisibilityLevel.NONE,\n) -&gt; tuple[str, list[BoxLike], CameraIntrinsicLike | None]\n</code></pre> <p>Return the data path as well as all annotations related to that <code>sample_data</code>. Note that output boxes is w.r.t base link or sensor coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>sample_data</code>.</p> </li> <li> <code>selected_ann_tokens</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify if you want to extract only particular annotations.</p> </li> <li> <code>as_3d</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to return 3D or 2D boxes.</p> </li> <li> <code>as_sensor_coord</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to transform boxes as sensor origin coordinate system.</p> </li> <li> <code>visibility</code>               (<code>VisibilityLevel</code>, default:                   <code>NONE</code> )           \u2013            <p>If <code>sample_data</code> is an image, this sets required visibility for only 3D boxes.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>tuple[str, list[BoxLike], CameraIntrinsicLike | None]</code>           \u2013            <p>Data path, a list of boxes and 3x3 camera intrinsic matrix.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_sample_data(\n    self,\n    sample_data_token: str,\n    *,\n    selected_ann_tokens: list[str] | None = None,\n    as_3d: bool = True,\n    as_sensor_coord: bool = True,\n    future_seconds: float = 0.0,\n    visibility: VisibilityLevel = VisibilityLevel.NONE,\n) -&gt; tuple[str, list[BoxLike], CameraIntrinsicLike | None]:\n    \"\"\"Return the data path as well as all annotations related to that `sample_data`.\n    Note that output boxes is w.r.t base link or sensor coordinate system.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n        selected_ann_tokens (list[str] | None, optional):\n            Specify if you want to extract only particular annotations.\n        as_3d (bool, optional): Whether to return 3D or 2D boxes.\n        as_sensor_coord (bool, optional): Whether to transform boxes as sensor origin coordinate system.\n        visibility (VisibilityLevel, optional): If `sample_data` is an image,\n            this sets required visibility for only 3D boxes.\n\n    Returns:\n        Data path, a list of boxes and 3x3 camera intrinsic matrix.\n    \"\"\"\n    # Retrieve sensor &amp; pose records\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    cs_record: CalibratedSensor = self.get(\n        \"calibrated_sensor\", sd_record.calibrated_sensor_token\n    )\n    sensor_record: Sensor = self.get(\"sensor\", cs_record.sensor_token)\n    pose_record: EgoPose = self.get(\"ego_pose\", sd_record.ego_pose_token)\n\n    data_path = self.get_sample_data_path(sample_data_token)\n\n    if sensor_record.modality == SensorModality.CAMERA:\n        cam_intrinsic = cs_record.camera_intrinsic\n        img_size = (sd_record.width, sd_record.height)\n    else:\n        cam_intrinsic = None\n        img_size = None\n\n    # Retrieve all sample annotations and map to sensor coordinate system.\n    boxes: list[BoxLike]\n    if selected_ann_tokens is not None:\n        boxes = (\n            [\n                self.get_box3d(token, future_seconds=future_seconds)\n                for token in selected_ann_tokens\n            ]\n            if as_3d\n            else list(map(self.get_box2d, selected_ann_tokens))\n        )\n    else:\n        boxes = (\n            self.get_box3ds(sample_data_token, future_seconds=future_seconds)\n            if as_3d\n            else self.get_box2ds(sample_data_token)\n        )\n\n    if not as_3d:\n        return data_path, boxes, cam_intrinsic\n\n    # Make list of Box objects including coord system transforms.\n    box_list: list[Box3D] = []\n    for box in boxes:\n        # Move box to ego vehicle coord system.\n        box.translate(-pose_record.translation)\n        box.rotate(pose_record.rotation.inverse)\n        box.frame_id = \"base_link\"\n\n        if as_sensor_coord:\n            #  Move box to sensor coord system.\n            box.translate(-cs_record.translation)\n            box.rotate(cs_record.rotation.inverse)\n            box.frame_id = sensor_record.channel\n\n        if sensor_record.modality == SensorModality.CAMERA and not is_box_in_image(\n            box,\n            cam_intrinsic,\n            img_size,\n            visibility=visibility,\n        ):\n            continue\n        box_list.append(box)\n\n    return data_path, box_list, cam_intrinsic\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_semantic_label","title":"get_semantic_label","text":"<pre><code>get_semantic_label(\n    category_token: str,\n    attribute_tokens: list[str] | None = None,\n) -&gt; SemanticLabel\n</code></pre> <p>Return a SemanticLabel instance from specified <code>category_token</code> and <code>attribute_tokens</code>.</p> <p>Parameters:</p> <ul> <li> <code>category_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>Category</code> table.</p> </li> <li> <code>attribute_tokens</code>               (<code>list[str] | None</code>, default:                   <code>None</code> )           \u2013            <p>List of attribute tokens.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>SemanticLabel</code>           \u2013            <p>Instantiated SemanticLabel.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_semantic_label(\n    self,\n    category_token: str,\n    attribute_tokens: list[str] | None = None,\n) -&gt; SemanticLabel:\n    \"\"\"Return a SemanticLabel instance from specified `category_token` and `attribute_tokens`.\n\n    Args:\n        category_token (str): Token of `Category` table.\n        attribute_tokens (list[str] | None, optional): List of attribute tokens.\n\n    Returns:\n        Instantiated SemanticLabel.\n    \"\"\"\n    category: Category = self.get(\"category\", category_token)\n    attributes: list[str] = (\n        [self.get(\"attribute\", token).name for token in attribute_tokens]\n        if attribute_tokens is not None\n        else []\n    )\n\n    return SemanticLabel(category.name, attributes)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box3d","title":"get_box3d","text":"<pre><code>get_box3d(\n    sample_annotation_token: str,\n    *,\n    future_seconds: float = 0.0,\n) -&gt; Box3D\n</code></pre> <p>Return a Box3D class from a <code>sample_annotation</code> record.</p> <p>Parameters:</p> <ul> <li> <code>sample_annotation_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>sample_annotation</code>.</p> </li> <li> <code>future_seconds</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Future time in [s].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Box3D</code>           \u2013            <p>Instantiated Box3D.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box3d(self, sample_annotation_token: str, *, future_seconds: float = 0.0) -&gt; Box3D:\n    \"\"\"Return a Box3D class from a `sample_annotation` record.\n\n    Args:\n        sample_annotation_token (str): Token of `sample_annotation`.\n        future_seconds (float, optional): Future time in [s].\n\n    Returns:\n        Instantiated Box3D.\n    \"\"\"\n    ann: SampleAnnotation = self.get(\"sample_annotation\", sample_annotation_token)\n    instance: Instance = self.get(\"instance\", ann.instance_token)\n    sample: Sample = self.get(\"sample\", ann.sample_token)\n    visibility: Visibility = self.get(\"visibility\", ann.visibility_token)\n\n    # semantic label\n    semantic_label = self.get_semantic_label(\n        category_token=instance.category_token,\n        attribute_tokens=ann.attribute_tokens,\n    )\n\n    shape = Shape(shape_type=ShapeType.BOUNDING_BOX, size=ann.size)\n\n    # velocity\n    velocity = self.box_velocity(sample_annotation_token=sample_annotation_token)\n\n    box = Box3D(\n        unix_time=sample.timestamp,\n        frame_id=\"map\",\n        semantic_label=semantic_label,\n        position=ann.translation,\n        rotation=ann.rotation,\n        shape=shape,\n        velocity=velocity,\n        confidence=1.0,\n        uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n        num_points=ann.num_lidar_pts,\n        visibility=visibility.level,\n    )\n\n    if future_seconds &gt; 0.0:\n        # NOTE: Future trajectory is map coordinate frame\n        timestamps, anns = self._timeseries_helper.get_sample_annotations_until(\n            ann.instance_token, ann.sample_token, future_seconds\n        )\n        if len(anns) == 0:\n            return box\n        waypoints = [ann.translation for ann in anns]\n        return box.with_future(timestamps=timestamps, confidences=[1.0], waypoints=[waypoints])\n    else:\n        return box\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box2d","title":"get_box2d","text":"<pre><code>get_box2d(object_ann_token: str) -&gt; Box2D\n</code></pre> <p>Return a Box2D class from a <code>object_ann</code> record.</p> <p>Parameters:</p> <ul> <li> <code>object_ann_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>object_ann</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Box2D</code>           \u2013            <p>Instantiated Box2D.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box2d(self, object_ann_token: str) -&gt; Box2D:\n    \"\"\"Return a Box2D class from a `object_ann` record.\n\n    Args:\n        object_ann_token (str): Token of `object_ann`.\n\n    Returns:\n        Instantiated Box2D.\n    \"\"\"\n    ann: ObjectAnn = self.get(\"object_ann\", object_ann_token)\n    instance: Instance = self.get(\"instance\", ann.instance_token)\n    sample_data: SampleData = self.get(\"sample_data\", ann.sample_data_token)\n\n    semantic_label = self.get_semantic_label(\n        category_token=ann.category_token,\n        attribute_tokens=ann.attribute_tokens,\n    )\n\n    return Box2D(\n        unix_time=sample_data.timestamp,\n        frame_id=sample_data.channel,\n        semantic_label=semantic_label,\n        roi=ann.bbox,\n        confidence=1.0,\n        uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box3ds","title":"get_box3ds","text":"<pre><code>get_box3ds(\n    sample_data_token: str, *, future_seconds: float = 0.0\n) -&gt; list[Box3D]\n</code></pre> <p>Rerun a list of Box3D classes for all annotations of a particular <code>sample_data</code> record. It the <code>sample_data</code> is a keyframe, this returns annotations for the corresponding <code>sample</code>.</p> <p>Parameters:</p> <ul> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>sample_data</code>.</p> </li> <li> <code>future_seconds</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Future time in [s].</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Box3D]</code>           \u2013            <p>List of instantiated Box3D classes.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box3ds(self, sample_data_token: str, *, future_seconds: float = 0.0) -&gt; list[Box3D]:\n    \"\"\"Rerun a list of Box3D classes for all annotations of a particular `sample_data` record.\n    It the `sample_data` is a keyframe, this returns annotations for the corresponding `sample`.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n        future_seconds (float, optional): Future time in [s].\n\n    Returns:\n        List of instantiated Box3D classes.\n    \"\"\"\n    # Retrieve sensor &amp; pose records\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    curr_sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n\n    if curr_sample_record.prev == \"\" or sd_record.is_key_frame:\n        # If no previous annotations available, or if sample_data is keyframe just return the current ones.\n        boxes = [\n            self.get_box3d(token, future_seconds=future_seconds)\n            for token in curr_sample_record.ann_3ds\n        ]\n\n    else:\n        prev_sample_record: Sample = self.get(\"sample\", curr_sample_record.prev)\n\n        curr_ann_recs: list[SampleAnnotation] = [\n            self.get(\"sample_annotation\", token) for token in curr_sample_record.ann_3ds\n        ]\n        prev_ann_recs: list[SampleAnnotation] = [\n            self.get(\"sample_annotation\", token) for token in prev_sample_record.ann_3ds\n        ]\n\n        # Maps instance tokens to prev_ann records\n        prev_inst_map = {entry.instance_token: entry for entry in prev_ann_recs}\n\n        t0 = prev_sample_record.timestamp\n        t1 = curr_sample_record.timestamp\n        t = sd_record.timestamp\n\n        # There are rare situations where the timestamps in the DB are off so ensure that t0 &lt; t &lt; t1.\n        t = max(t0, min(t1, t))\n\n        boxes: list[Box3D] = []\n        for curr_ann in curr_ann_recs:\n            if curr_ann.instance_token in prev_inst_map:\n                # If the annotated instance existed in the previous frame, interpolate center &amp; orientation.\n                prev_ann = prev_inst_map[curr_ann.instance_token]\n\n                # Interpolate center.\n                position = [\n                    np.interp(t, [t0, t1], [c0, c1])\n                    for c0, c1 in zip(\n                        prev_ann.translation,\n                        curr_ann.translation,\n                        strict=True,\n                    )\n                ]\n\n                # Interpolate orientation.\n                rotation = Quaternion.slerp(\n                    q0=prev_ann.rotation,\n                    q1=curr_ann.rotation,\n                    amount=(t - t0) / (t1 - t0),\n                )\n\n                instance: Instance = self.get(\"instance\", curr_ann.instance_token)\n                semantic_label = self.get_semantic_label(\n                    instance.category_token, curr_ann.attribute_tokens\n                )\n                velocity = self.box_velocity(curr_ann.token)\n                visibility: Visibility = self.get(\"visibility\", curr_ann.visibility_token)\n\n                box = Box3D(\n                    unix_time=t,\n                    frame_id=\"map\",\n                    semantic_label=semantic_label,\n                    position=position,\n                    rotation=rotation,\n                    shape=Shape(ShapeType.BOUNDING_BOX, curr_ann.size),\n                    velocity=velocity,\n                    confidence=1.0,\n                    uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n                    num_points=curr_ann.num_lidar_pts,\n                    visibility=visibility.level,\n                )\n            else:\n                # If not, simply grab the current annotation.\n                box = self.get_box3d(curr_ann.token, future_seconds=future_seconds)\n            boxes.append(box)\n\n    return boxes\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box2ds","title":"get_box2ds","text":"<pre><code>get_box2ds(sample_data_token: str) -&gt; list[Box2D]\n</code></pre> <p>Rerun a list of Box2D classes for all annotations of a particular <code>sample_data</code> record. It the <code>sample_data</code> is a keyframe, this returns annotations for the corresponding <code>sample</code>.</p> <p>Parameters:</p> <ul> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>sample_data</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[Box2D]</code>           \u2013            <p>List of instantiated Box2D classes.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box2ds(self, sample_data_token: str) -&gt; list[Box2D]:\n    \"\"\"Rerun a list of Box2D classes for all annotations of a particular `sample_data` record.\n    It the `sample_data` is a keyframe, this returns annotations for the corresponding `sample`.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n\n    Returns:\n        List of instantiated Box2D classes.\n    \"\"\"\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n    return list(map(self.get_box2d, sample_record.ann_2ds))\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.box_velocity","title":"box_velocity","text":"<pre><code>box_velocity(\n    sample_annotation_token: str, max_time_diff: float = 1.5\n) -&gt; Vector3\n</code></pre> <p>Return the velocity of an annotation. If corresponding annotation has a true velocity, this returns it. Otherwise, this estimates the velocity by computing the difference between the previous and next frame. If it is failed to estimate the velocity, values are set to np.nan.</p> <p>Parameters:</p> <ul> <li> <code>sample_annotation_token</code>               (<code>str</code>)           \u2013            <p>Token of <code>sample_annotation</code>.</p> </li> <li> <code>max_time_diff</code>               (<code>float</code>, default:                   <code>1.5</code> )           \u2013            <p>Max allowed time difference between consecutive samples.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector3</code> (              <code>Vector3</code> )          \u2013            <p>Velocity in the order of (vx, vy, vz) in m/s.</p> </li> </ul> TODO <p>Currently, velocity coordinates is with respect to map, but if should be each box.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def box_velocity(self, sample_annotation_token: str, max_time_diff: float = 1.5) -&gt; Vector3:\n    \"\"\"Return the velocity of an annotation.\n    If corresponding annotation has a true velocity, this returns it.\n    Otherwise, this estimates the velocity by computing the difference\n    between the previous and next frame.\n    If it is failed to estimate the velocity, values are set to np.nan.\n\n    Args:\n        sample_annotation_token (str): Token of `sample_annotation`.\n        max_time_diff (float, optional): Max allowed time difference\n            between consecutive samples.\n\n    Returns:\n        Vector3: Velocity in the order of (vx, vy, vz) in m/s.\n\n    TODO:\n        Currently, velocity coordinates is with respect to map, but\n        if should be each box.\n    \"\"\"\n    current: SampleAnnotation = self.get(\"sample_annotation\", sample_annotation_token)\n\n    # If the real velocity is annotated, returns it\n    if current.velocity is not None:\n        return current.velocity\n\n    has_prev = current.prev != \"\"\n    has_next = current.next != \"\"\n\n    # Cannot estimate velocity for a single annotation.\n    if not has_prev and not has_next:\n        return np.array([np.nan, np.nan, np.nan])\n\n    first: SampleAnnotation = (\n        self.get(\"sample_annotation\", current.prev) if has_prev else current\n    )\n\n    last: SampleAnnotation = (\n        self.get(\"sample_annotation\", current.next) if has_next else current\n    )\n\n    pos_last = last.translation\n    pos_first = first.translation\n    pos_diff = pos_last - pos_first\n\n    last_sample: Sample = self.get(\"sample\", last.sample_token)\n    first_sample: Sample = self.get(\"sample\", first.sample_token)\n    time_last = 1e-6 * last_sample.timestamp\n    time_first = 1e-6 * first_sample.timestamp\n    time_diff = time_last - time_first\n\n    if has_next and has_prev:\n        # If doing centered difference, allow for up to double the max_time_diff.\n        max_time_diff *= 2\n\n    if time_diff &gt; max_time_diff:\n        # If time_diff is too big, don't return an estimate.\n        return np.array([np.nan, np.nan, np.nan])\n    else:\n        return pos_diff / time_diff\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.render_scene","title":"render_scene","text":"<pre><code>render_scene(\n    *,\n    max_time_seconds: float = np.inf,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Render specified scene.</p> <p>Parameters:</p> <ul> <li> <code>max_time_seconds</code>               (<code>float</code>, default:                   <code>inf</code> )           \u2013            <p>Max time length to be rendered [s].</p> </li> <li> <code>future_seconds</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Future time in [s].</p> </li> <li> <code>save_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory path to save the recording.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def render_scene(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render specified scene.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n    \"\"\"\n    self._rendering_helper.render_scene(\n        max_time_seconds=max_time_seconds,\n        future_seconds=future_seconds,\n        save_dir=save_dir,\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.render_instance","title":"render_instance","text":"<pre><code>render_instance(\n    instance_token: str | Sequence[str],\n    *,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Render particular instance.</p> <p>Parameters:</p> <ul> <li> <code>instance_token</code>               (<code>str | Sequence[str]</code>)           \u2013            <p>Instance token(s).</p> </li> <li> <code>future_seconds</code>               (<code>float</code>, default:                   <code>0.0</code> )           \u2013            <p>Future time in [s].</p> </li> <li> <code>save_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory path to save the recording.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def render_instance(\n    self,\n    instance_token: str | Sequence[str],\n    *,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render particular instance.\n\n    Args:\n        instance_token (str | Sequence[str]): Instance token(s).\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n    \"\"\"\n    self._rendering_helper.render_instance(\n        instance_token=instance_token,\n        future_seconds=future_seconds,\n        save_dir=save_dir,\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.render_pointcloud","title":"render_pointcloud","text":"<pre><code>render_pointcloud(\n    *,\n    max_time_seconds: float = np.inf,\n    ignore_distortion: bool = True,\n    save_dir: str | None = None,\n) -&gt; None\n</code></pre> <p>Render pointcloud on 3D and 2D view.</p> <p>Parameters:</p> <ul> <li> <code>max_time_seconds</code>               (<code>float</code>, default:                   <code>inf</code> )           \u2013            <p>Max time length to be rendered [s].</p> </li> <li> <code>save_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory path to save the recording.</p> </li> <li> <code>ignore_distortion</code>               (<code>bool</code>, default:                   <code>True</code> )           \u2013            <p>Whether to ignore distortion parameters.</p> </li> </ul> TODO <p>Add an option of rendering radar channels.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def render_pointcloud(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    ignore_distortion: bool = True,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render pointcloud on 3D and 2D view.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n        ignore_distortion (bool, optional): Whether to ignore distortion parameters.\n\n    TODO:\n        Add an option of rendering radar channels.\n    \"\"\"\n    self._rendering_helper.render_pointcloud(\n        max_time_seconds=max_time_seconds,\n        ignore_distortion=ignore_distortion,\n        save_dir=save_dir,\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.load_metadata","title":"load_metadata","text":"<pre><code>load_metadata(\n    db_root: str, revision: str | None = None\n) -&gt; DBMetadata\n</code></pre> <p>Load metadata of T4 dataset including root directory path, dataset ID, and version.</p> <p>Parameters:</p> <ul> <li> <code>db_root</code>               (<code>str</code>)           \u2013            <p>Path to root directory of database.</p> </li> <li> <code>revision</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Specify version of the dataset. If None, search the latest one.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>DBMetadata</code>           \u2013            <p>Metadata of T4 dataset.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def load_metadata(db_root: str, revision: str | None = None) -&gt; DBMetadata:\n    \"\"\"Load metadata of T4 dataset including root directory path, dataset ID, and version.\n\n    Args:\n        db_root (str): Path to root directory of database.\n        revision (str | None, optional): Specify version of the dataset.\n            If None, search the latest one.\n\n    Returns:\n        Metadata of T4 dataset.\n    \"\"\"\n    db_root_path = Path(db_root)\n    dataset_id = db_root_path.name\n\n    version_pattern = re.compile(r\".*/\\d+$\")\n    version_candidates = [\n        int(d.name) for d in db_root_path.iterdir() if version_pattern.match(d.as_posix())\n    ]\n\n    if revision is None:\n        if version_candidates:  # try to load the latest one\n            version = str(max(version_candidates))\n            data_root = db_root_path.joinpath(version).as_posix()\n        else:\n            version = None\n            data_root = db_root_path.as_posix()\n    else:\n        version = revision\n        data_root = db_root_path.joinpath(version).as_posix()\n\n    return DBMetadata(data_root=data_root, dataset_id=dataset_id, version=version)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.load_table","title":"load_table","text":"<pre><code>load_table(\n    annotation_dir: str, schema: SchemaName\n) -&gt; list[SchemaTable]\n</code></pre> <p>Load schema table from a JSON file.</p> <p>If the schema is optional and there is no corresponding JSON file in dataset, returns empty list.</p> <p>Parameters:</p> <ul> <li> <code>annotation_dir</code>               (<code>str</code>)           \u2013            <p>Path to the directory of JSON annotation schema files.</p> </li> <li> <code>schema</code>               (<code>SchemaName</code>)           \u2013            <p>An enum member of <code>SchemaName</code>.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[SchemaTable]</code>           \u2013            <p>Loaded table data saved in <code>.json</code>.</p> </li> </ul> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def load_table(annotation_dir: str, schema: SchemaName) -&gt; list[SchemaTable]:\n    \"\"\"Load schema table from a JSON file.\n\n    If the schema is optional and there is no corresponding JSON file in dataset,\n    returns empty list.\n\n    Args:\n        annotation_dir (str): Path to the directory of JSON annotation schema files.\n        schema (SchemaName): An enum member of `SchemaName`.\n\n    Returns:\n        Loaded table data saved in `.json`.\n    \"\"\"\n    filepath = osp.join(annotation_dir, schema.filename)\n    if not osp.exists(filepath) and schema.is_optional():\n        return []\n\n    if not osp.exists(filepath):\n        raise FileNotFoundError(f\"{schema.value} is mandatory.\")\n\n    return build_schema(schema, filepath)\n</code></pre>"},{"location":"apis/typing/","title":"<code>typing</code>","text":""},{"location":"apis/typing/#t4_devkit.typing","title":"t4_devkit.typing","text":""},{"location":"apis/typing/#t4_devkit.typing.Vector2Like","title":"Vector2Like  <code>module-attribute</code>","text":"<pre><code>Vector2Like = Union[\n    Vector2,\n    ArrayLike,\n    Sequence[float],\n    tuple[float, float],\n    list[float],\n]\n</code></pre> <p>Type alias for 2D vector inputs.</p> Accepts <ul> <li>Vector2 instances</li> <li>NumPy arrays with shape (2,)</li> <li>Lists: [x, y]</li> <li>Tuples: (x, y)</li> <li>Any sequence with 2 float elements</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Vector3Like","title":"Vector3Like  <code>module-attribute</code>","text":"<pre><code>Vector3Like = Union[\n    Vector3,\n    ArrayLike,\n    Sequence[float],\n    tuple[float, float, float],\n    list[float],\n]\n</code></pre> <p>Type alias for 3D vector inputs.</p> Accepts <ul> <li>Vector3 instances</li> <li>NumPy arrays with shape (3,)</li> <li>Lists: [x, y, z]</li> <li>Tuples: (x, y, z)</li> <li>Any sequence with 3 float elements</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Vector6Like","title":"Vector6Like  <code>module-attribute</code>","text":"<pre><code>Vector6Like = Union[\n    Vector6,\n    ArrayLike,\n    Sequence[float],\n    tuple[float, ...],\n    list[float],\n]\n</code></pre> <p>Type alias for 6D vector inputs.</p> Accepts <ul> <li>Vector6 instances</li> <li>NumPy arrays with shape (6,)</li> <li>Lists: [x1, x2, x3, x4, x5, x6]</li> <li>Tuples: (x1, x2, x3, x4, x5, x6)</li> <li>Any sequence with 6 float elements</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.QuaternionLike","title":"QuaternionLike  <code>module-attribute</code>","text":"<pre><code>QuaternionLike = Union[\n    Quaternion,\n    ArrayLike,\n    Sequence[float],\n    tuple[float, float, float, float],\n    list[float],\n]\n</code></pre> <p>Type alias for quaternion inputs.</p> Accepts <ul> <li>Quaternion instances</li> <li>NumPy arrays with shape (4,) - [w, x, y, z]</li> <li>Lists: [w, x, y, z]</li> <li>Tuples: (w, x, y, z)</li> <li>Any sequence with 4 float elements representing quaternion components</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.RotationLike","title":"RotationLike  <code>module-attribute</code>","text":"<pre><code>RotationLike = Union[QuaternionLike, ArrayLike]\n</code></pre> <p>Type alias for general rotation inputs.</p> Accepts <ul> <li>All QuaternionLike inputs</li> <li>3x3 rotation matrices as NumPy arrays</li> <li>Any array-like object representing rotations</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.RoiLike","title":"RoiLike  <code>module-attribute</code>","text":"<pre><code>RoiLike = Union[\n    Roi,\n    ArrayLike,\n    Sequence[float],\n    tuple[float, float, float, float],\n    list[float],\n]\n</code></pre> <p>Type alias for Region of Interest (ROI) inputs.</p> Accepts <ul> <li>Roi instances</li> <li>NumPy arrays with shape (4,)</li> <li>Lists: [xmin, ymin, xmax, ymax]</li> <li>Tuples: (xmin, ymin, xmax, ymax)</li> <li>Any sequence with 4 float elements representing bounding box coordinates</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.PointLike","title":"PointLike  <code>module-attribute</code>","text":"<pre><code>PointLike = Union[Vector2Like, Vector3Like]\n</code></pre> <p>Type alias for single point inputs (2D or 3D).</p>"},{"location":"apis/typing/#t4_devkit.typing.PointsLike","title":"PointsLike  <code>module-attribute</code>","text":"<pre><code>PointsLike = Union[\n    ArrayLike,\n    Sequence[Sequence[float]],\n    list[list[float]],\n    list[tuple[float, ...]],\n]\n</code></pre> <p>Type alias for multiple points inputs.</p> Accepts <ul> <li>NumPy arrays with shape (N, 2) or (N, 3)</li> <li>Lists of lists: [[x1, y1], [x2, y2], ...]</li> <li>Lists of tuples: [(x1, y1), (x2, y2), ...]</li> <li>Any nested sequence representing multiple points</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Matrix3x3Like","title":"Matrix3x3Like  <code>module-attribute</code>","text":"<pre><code>Matrix3x3Like = Union[\n    Matrix3x3,\n    ArrayLike,\n    Sequence[Sequence[float]],\n    list[list[float]],\n]\n</code></pre> <p>Type alias for 3x3 matrix inputs.</p> Accepts <ul> <li>NumPy arrays with shape (3, 3)</li> <li>Nested lists: [[a, b, c], [d, e, f], [g, h, i]]</li> <li>Any nested sequence representing a 3x3 matrix</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Matrix4x4Like","title":"Matrix4x4Like  <code>module-attribute</code>","text":"<pre><code>Matrix4x4Like = Union[\n    Matrix4x4,\n    ArrayLike,\n    Sequence[Sequence[float]],\n    list[list[float]],\n]\n</code></pre> <p>Type alias for 4x4 matrix inputs.</p> Accepts <ul> <li>NumPy arrays with shape (4, 4)</li> <li>Nested lists: 4x4 structure</li> <li>Any nested sequence representing a 4x4 matrix</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.TrajectoryLike","title":"TrajectoryLike  <code>module-attribute</code>","text":"<pre><code>TrajectoryLike = Union[\n    ArrayLike,\n    Sequence[Sequence[Sequence[float]]],\n    list[list[list[float]]],\n]\n</code></pre> <p>Type alias for trajectory inputs.</p> Accepts <ul> <li>NumPy arrays with shape (M, T, D) where:</li> <li>M = number of modes</li> <li>T = number of timesteps</li> <li>D = spatial dimensions (usually 3)</li> <li>Triple-nested sequences with same structure</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.CameraIntrinsicLike","title":"CameraIntrinsicLike  <code>module-attribute</code>","text":"<pre><code>CameraIntrinsicLike = Union[\n    CameraIntrinsic,\n    ArrayLike,\n    Sequence[Sequence[float]],\n    list[list[float]],\n]\n</code></pre> <p>Type alias for camera parameter inputs.</p> Accepts <ul> <li>CameraIntrinsic instances</li> <li>NumPy arrays with shape (3, 3)</li> <li>Nested sequences of float values</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.CameraDistortionLike","title":"CameraDistortionLike  <code>module-attribute</code>","text":"<pre><code>CameraDistortionLike = Union[\n    CameraDistortion,\n    ArrayLike,\n    Sequence[float],\n    list[float],\n]\n</code></pre> <p>Type alias for camera distortion inputs.</p> Accepts <ul> <li>CameraDistortion instances</li> <li>NumPy arrays with shape (5,)</li> <li>Sequence of float values</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.ScalarLike","title":"ScalarLike  <code>module-attribute</code>","text":"<pre><code>ScalarLike = Union[int, float, number]\n</code></pre> <p>Type alias for scalar numeric inputs.</p> Accepts <ul> <li>Python int or float</li> <li>NumPy scalar types</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.CameraIntrinsic","title":"CameraIntrinsic","text":"<p>A 3x3 camera intrinsic matrix with validation.</p> <p>This class ensures that the input array is a 3x3 matrix and raises a ValueError if it is not. It can be constructed from a 3x3 array or 9 elements array.</p> <p>Note that for non-camera, the array can be empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; i = CameraIntrinsic(np.eye(3))                          # OK\n&gt;&gt;&gt; i = CameraIntrinsic([1, 0, 0, 0, 1, 0, 0, 0, 1])        # OK\n&gt;&gt;&gt; i = CameraIntrinsic([[1, 0, 0], [0, 1, 0], [0, 0, 1]])  # OK\n&gt;&gt;&gt; i = CameraIntrinsic([])                                 # OK\n&gt;&gt;&gt; i = CameraIntrinsic(np.eye(2))                          # ValueError\n&gt;&gt;&gt; i = CameraIntrinsic([1, 0, 0, 0, 1, 0, 0, 0])           # ValueError\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.CameraDistortion","title":"CameraDistortion","text":"<p>A 1D array representing camera lens distortion coefficients.</p> <p>This class represents the distortion parameters for a camera lens following the OpenCV distortion model. It supports arrays of length 4, 5, 8, 12, or 14 elements, corresponding to different distortion models.</p> <p>The distortion coefficients follow the OpenCV convention: (k1, k2, p1, p2[, k3[, k4, k5, k6[, s1, s2, s3, s4[, \u03c4x, \u03c4y]]]])</p> Coefficient meanings <ul> <li>k1, k2, k3, k4, k5, k6: Radial distortion coefficients</li> <li>p1, p2: Tangential distortion coefficients</li> <li>s1, s2, s3, s4: Thin prism distortion coefficients</li> <li>\u03c4x, \u03c4y: Tilted sensor distortion coefficients</li> </ul> Supported array lengths <ul> <li>4 elements: (k1, k2, p1, p2) - Basic radial and tangential</li> <li>5 elements: (k1, k2, p1, p2, k3) - Extended radial distortion</li> <li>8 elements: (k1, k2, p1, p2, k3, k4, k5, k6) - Rational model</li> <li>12 elements: (k1, k2, p1, p2, k3, k4, k5, k6, s1, s2, s3, s4) - With thin prism</li> <li>14 elements: (k1, k2, p1, p2, k3, k4, k5, k6, s1, s2, s3, s4, \u03c4x, \u03c4y) - Full model</li> </ul> <p>Note that for non-camera, the array can be empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = CameraDistortion([0, 0, 0, 0])                     # 4 elements: basic model\n&gt;&gt;&gt; d = CameraDistortion([0, 0, 0, 0, 0])                  # 5 elements: with k3\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5])                  # 5 elements: valid coefficients\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8])         # 8 elements: rational model\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])  # 12 elements: with thin prism\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])  # 14 elements: full model\n&gt;&gt;&gt; d = CameraDistortion([])                               # Empty array for non-camera\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3])                        # ValueError: invalid length\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6])               # ValueError: invalid length\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Matrix3x3","title":"Matrix3x3","text":"<p>A 3x3 matrix with validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; matrix = Matrix3x3([[1, 2, 3], [4, 5, 6], [7, 8, 9]])   # OK\n&gt;&gt;&gt; matrix = Matrix3x3(np.eye(3))                           # OK\n&gt;&gt;&gt; matrix = Matrix3x3([[1, 2], [4, 5], [7, 8]])            # ValueError\n&gt;&gt;&gt; matrix = Matrix3x3(np.eye(2))                           # ValueError\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Matrix4x4","title":"Matrix4x4","text":"<p>A 4x4 matrix with validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; matrix = Matrix4x4([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) # OK\n&gt;&gt;&gt; matrix = Matrix4x4(np.eye(4))                                                       # OK\n&gt;&gt;&gt; matrix = Matrix4x4([[1, 2], [4, 5], [7, 8]])                                        # ValueError\n&gt;&gt;&gt; matrix = Matrix4x4(np.eye(2))                                                       # ValueError\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Quaternion","title":"Quaternion","text":"<p>A quaternion class that wraps the PyQuaternion class.</p> <p>This wrapper exists to provide a consistent and explicit quaternion representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; q = Quaternion(1, 2, 3, 4)\n&gt;&gt;&gt; q\nQuaternion(1.000000, 2.000000, 3.000000, 4.000000)\n&gt;&gt;&gt; q.conjugate()\nQuaternion(1.000000, -2.000000, -3.000000, -4.000000)\n&gt;&gt;&gt; q.norm()\n5.477226\n&gt;&gt;&gt; q.inverse()\nQuaternion(0.181818, -0.363636, -0.545455, -0.727273)\n&gt;&gt;&gt; q * q.inverse()\nQuaternion(1.000000, 0.000000, 0.000000, 0.000000)\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Roi","title":"Roi","text":"<p>A 4-element tuple representing a region of interest (ROI).</p> <p>This class ensures that the array always has the correct shape and value order. It can be constructed from any array-like object that can be converted to a tuple of length 4, or from individual numeric arguments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; roi = Roi(10, 20, 30, 40)   # OK\n&gt;&gt;&gt; roi = Roi((10, 20, 30, 40)) # OK\n&gt;&gt;&gt; roi = Roi([10, 20, 30, 40]) # OK\n&gt;&gt;&gt; roi = Roi([10, 20])         # ValueError: ROI must be 4-elements\n&gt;&gt;&gt; roi = Roi([40, 30, 20, 10]) # ValueError: ROI must be xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Roi.offset","title":"offset  <code>property</code>","text":"<pre><code>offset: tuple[ScalarLike, ScalarLike]\n</code></pre> <p>Return the xy offset from the image origin at the top left corner.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.size","title":"size  <code>property</code>","text":"<pre><code>size: tuple[ScalarLike, ScalarLike]\n</code></pre> <p>Return the width and height of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.width","title":"width  <code>property</code>","text":"<pre><code>width: ScalarLike\n</code></pre> <p>Return the width of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.height","title":"height  <code>property</code>","text":"<pre><code>height: ScalarLike\n</code></pre> <p>Return the height of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.center","title":"center  <code>property</code>","text":"<pre><code>center: tuple[ScalarLike, ScalarLike]\n</code></pre> <p>Return the center position of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.area","title":"area  <code>property</code>","text":"<pre><code>area: ScalarLike\n</code></pre> <p>Return the area of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Vector2","title":"Vector2","text":"<p>A 2-element numpy array with validation.</p> <p>This class ensures that the array always has exactly 2 elements. It can be constructed from any array-like object that can be converted to a 2-element numpy array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = Vector2([1, 2])             # OK\n&gt;&gt;&gt; v = Vector2(np.array([1, 2]))   # OK\n&gt;&gt;&gt; v = Vector2(1, 2)               # OK\n&gt;&gt;&gt; v = Vector2([1, 2, 3])          # ValueError\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Vector3","title":"Vector3","text":"<p>A 3-element numpy array with validation.</p> <p>This class ensures that the array always has exactly 3 elements. It can be constructed from any array-like object that can be converted to a 3-element numpy array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = Vector3([1, 2, 3])              # OK\n&gt;&gt;&gt; v = Vector3(np.array([1, 2, 3]))    # OK\n&gt;&gt;&gt; v = Vector3(1, 2, 3)                # OK\n&gt;&gt;&gt; v = Vector3([1, 2])                 # ValueError\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Vector6","title":"Vector6","text":"<p>A 6-element numpy array with validation.</p> <p>This class ensures that the array always has exactly 6 elements. It can be constructed from any array-like object that can be converted to a 6-element numpy array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = Vector6([1, 2, 3, 4, 5, 6])             # OK\n&gt;&gt;&gt; v = Vector6(np.array([1, 2, 3, 4, 5, 6]))   # OK\n&gt;&gt;&gt; v = Vector6(1, 2, 3, 4, 5, 6)               # OK\n&gt;&gt;&gt; v = Vector6([1, 2])                         # ValueError\n</code></pre>"},{"location":"apis/viewer/","title":"<code>viewer</code>","text":""},{"location":"apis/viewer/#t4_devkit.viewer","title":"t4_devkit.viewer","text":""},{"location":"apis/viewer/#t4_devkit.viewer.ViewerBuilder","title":"ViewerBuilder","text":"<pre><code>ViewerBuilder()\n</code></pre> <p>Builder for creating a RerunViewer instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n&gt;&gt;&gt; viewer = (\n        ViewerBuilder()\n        .with_spatial3d()\n        .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n        .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n        .with_streetmap(latlon=[48.8566, 2.3522])\n        .build(app_id=\"my_viewer\")\n    )\n</code></pre> Source code in <code>t4_devkit/viewer/builder.py</code> <pre><code>def __init__(self) -&gt; None:\n    self._config = ViewerConfig()\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.PointCloudColorMode","title":"PointCloudColorMode","text":"<p>Color mode of point cloud.</p>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer","title":"RerunViewer","text":"<pre><code>RerunViewer(\n    app_id: str,\n    config: ViewerConfig = ViewerConfig(),\n    save_dir: str | None = None,\n)\n</code></pre> <p>A viewer class that renders some components powered by rerun.</p> <p>Construct a new object.</p> <p>Parameters:</p> <ul> <li> <code>app_id</code>               (<code>str</code>)           \u2013            <p>Application ID.</p> </li> <li> <code>config</code>               (<code>ViewerConfig</code>, default:                   <code>ViewerConfig()</code> )           \u2013            <p>Configuration of the viewer.</p> </li> <li> <code>save_dir</code>               (<code>str | None</code>, default:                   <code>None</code> )           \u2013            <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n&gt;&gt;&gt; viewer = (\n        ViewerBuilder()\n        .with_spatial3d()\n        .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n        .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n        .with_streetmap(latlon=[48.8566, 2.3522])\n        .build(app_id=\"my_viewer\")\n    )\n</code></pre> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>def __init__(\n    self,\n    app_id: str,\n    config: ViewerConfig = ViewerConfig(),\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        app_id (str): Application ID.\n        config (ViewerConfig): Configuration of the viewer.\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n\n    Examples:\n        &gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n        &gt;&gt;&gt; viewer = (\n                ViewerBuilder()\n                .with_spatial3d()\n                .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n                .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n                .with_streetmap(latlon=[48.8566, 2.3522])\n                .build(app_id=\"my_viewer\")\n            )\n    \"\"\"\n    self.app_id = app_id\n    self.config = config\n    self.blueprint = self.config.to_blueprint()\n\n    rr.init(\n        application_id=self.app_id,\n        recording_id=None,\n        spawn=save_dir is None,\n        default_enabled=True,\n        strict=True,\n        default_blueprint=self.blueprint,\n    )\n\n    # NOTE: rr.save() must be invoked before logging\n    if save_dir is not None:\n        self._start_saving(save_dir=save_dir)\n\n    rr.log(self.config.map_entity, rr.ViewCoordinates.RIGHT_HAND_Z_UP, static=True)\n\n    rr.log(\n        self.config.map_entity,\n        rr.AnnotationContext(\n            [\n                rr.AnnotationInfo(id=label_id, label=label)\n                for label, label_id in self.label2id.items()\n            ]\n        ),\n        static=True,\n    )\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_box3ds","title":"render_box3ds","text":"<pre><code>render_box3ds(\n    seconds: float, boxes: Sequence[Box3D]\n) -&gt; None\n</code></pre><pre><code>render_box3ds(\n    seconds: float,\n    frame_id: str,\n    centers: Sequence[Vector3Like],\n    rotations: Sequence[RotationLike],\n    sizes: Sequence[Vector3Like],\n    class_ids: Sequence[int],\n    velocities: Sequence[Vector3Like] | None = None,\n    uuids: Sequence[str] | None = None,\n    futures: Sequence[Future] | None = None,\n) -&gt; None\n</code></pre> <pre><code>render_box3ds(*args, **kwargs) -&gt; None\n</code></pre> <p>Render 3D boxes.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_box3ds(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render 3D boxes.\"\"\"\n    if len(args) + len(kwargs) == 2:\n        self._render_box3ds_with_boxes(*args, **kwargs)\n    else:\n        self._render_box3ds_with_elements(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_box2ds","title":"render_box2ds","text":"<pre><code>render_box2ds(\n    seconds: float, boxes: Sequence[Box2D]\n) -&gt; None\n</code></pre><pre><code>render_box2ds(\n    seconds: float,\n    camera: str,\n    rois: Sequence[RoiLike],\n    class_ids: Sequence[int],\n    uuids: Sequence[str] | None = None,\n) -&gt; None\n</code></pre> <pre><code>render_box2ds(*args, **kwargs) -&gt; None\n</code></pre> <p>Render 2D boxes.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial2d\ndef render_box2ds(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render 2D boxes.\"\"\"\n    if len(args) + len(kwargs) == 2:\n        self._render_box2ds_with_boxes(*args, **kwargs)\n    else:\n        self._render_box2ds_with_elements(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_segmentation2d","title":"render_segmentation2d","text":"<pre><code>render_segmentation2d(\n    seconds: float,\n    camera: str,\n    masks: Sequence[NDArrayU8],\n    class_ids: Sequence[int],\n    uuids: Sequence[str | None] | None = None,\n) -&gt; None\n</code></pre> <p>Render 2D segmentation image.</p> <p>Parameters:</p> <ul> <li> <code>seconds</code>               (<code>float</code>)           \u2013            <p>Timestamp in [sec].</p> </li> <li> <code>camera</code>               (<code>str</code>)           \u2013            <p>Name of camera channel.</p> </li> <li> <code>masks</code>               (<code>Sequence[NDArrayU8]</code>)           \u2013            <p>Sequence of segmentation mask of each instance, each mask is the shape of (W, H).</p> </li> <li> <code>class_ids</code>               (<code>Sequence[int]</code>)           \u2013            <p>Sequence of label ids.</p> </li> <li> <code>uuids</code>               (<code>Sequence[str | None] | None</code>, default:                   <code>None</code> )           \u2013            <p>Sequence of each instance ID.</p> </li> </ul> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial2d\ndef render_segmentation2d(\n    self,\n    seconds: float,\n    camera: str,\n    masks: Sequence[NDArrayU8],\n    class_ids: Sequence[int],\n    uuids: Sequence[str | None] | None = None,\n) -&gt; None:\n    \"\"\"Render 2D segmentation image.\n\n    Args:\n        seconds (float): Timestamp in [sec].\n        camera (str): Name of camera channel.\n        masks (Sequence[NDArrayU8]): Sequence of segmentation mask of each instance,\n            each mask is the shape of (W, H).\n        class_ids (Sequence[int]): Sequence of label ids.\n        uuids (Sequence[str | None] | None, optional): Sequence of each instance ID.\n    \"\"\"\n    rr.set_time_seconds(self.config.timeline, seconds)\n\n    batch = BatchSegmentation2D()\n    if uuids is None:\n        uuids = [None] * len(masks)\n    for mask, class_id, uuid in zip(masks, class_ids, uuids, strict=True):\n        batch.append(mask, class_id, uuid)\n\n    rr.log(\n        format_entity(self.config.ego_entity, camera, \"segmentation\"),\n        batch.as_segmentation_image(),\n    )\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_pointcloud","title":"render_pointcloud","text":"<pre><code>render_pointcloud(\n    seconds: float,\n    channel: str,\n    pointcloud: PointCloudLike,\n    color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n) -&gt; None\n</code></pre> <p>Render pointcloud.</p> <p>Parameters:</p> <ul> <li> <code>seconds</code>               (<code>float</code>)           \u2013            <p>Timestamp in [sec].</p> </li> <li> <code>channel</code>               (<code>str</code>)           \u2013            <p>Name of the pointcloud sensor channel.</p> </li> <li> <code>pointcloud</code>               (<code>PointCloudLike</code>)           \u2013            <p>Inherence object of <code>PointCloud</code>.</p> </li> <li> <code>color_mode</code>               (<code>PointCloudColorMode</code>, default:                   <code>DISTANCE</code> )           \u2013            <p>Color mode for pointcloud.</p> </li> </ul> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_pointcloud(\n    self,\n    seconds: float,\n    channel: str,\n    pointcloud: PointCloudLike,\n    color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n) -&gt; None:\n    \"\"\"Render pointcloud.\n\n    Args:\n        seconds (float): Timestamp in [sec].\n        channel (str): Name of the pointcloud sensor channel.\n        pointcloud (PointCloudLike): Inherence object of `PointCloud`.\n        color_mode (PointCloudColorMode, optional): Color mode for pointcloud.\n    \"\"\"\n    # TODO(ktro2828): add support of rendering pointcloud on images\n    rr.set_time_seconds(self.config.timeline, seconds)\n\n    colors = pointcloud_color(pointcloud, color_mode=color_mode)\n    rr.log(\n        format_entity(self.config.ego_entity, channel),\n        rr.Points3D(pointcloud.points[:3].T, colors=colors),\n    )\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_image","title":"render_image","text":"<pre><code>render_image(\n    seconds: float, camera: str, image: str | NDArrayU8\n) -&gt; None\n</code></pre> <p>Render an image.</p> <p>Parameters:</p> <ul> <li> <code>seconds</code>               (<code>float</code>)           \u2013            <p>Timestamp in [sec].</p> </li> <li> <code>camera</code>               (<code>str</code>)           \u2013            <p>Name of the camera channel.</p> </li> <li> <code>image</code>               (<code>str | NDArrayU8</code>)           \u2013            <p>Image tensor or path of the image file.</p> </li> </ul> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial2d\ndef render_image(self, seconds: float, camera: str, image: str | NDArrayU8) -&gt; None:\n    \"\"\"Render an image.\n\n    Args:\n        seconds (float): Timestamp in [sec].\n        camera (str): Name of the camera channel.\n        image (str | NDArrayU8): Image tensor or path of the image file.\n    \"\"\"\n    rr.set_time_seconds(self.config.timeline, seconds)\n\n    if isinstance(image, str):\n        rr.log(format_entity(self.config.ego_entity, camera), rr.ImageEncoded(path=image))\n    else:\n        rr.log(format_entity(self.config.ego_entity, camera), rr.Image(image))\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_ego","title":"render_ego","text":"<pre><code>render_ego(ego_pose: EgoPose) -&gt; None\n</code></pre><pre><code>render_ego(\n    seconds: float,\n    translation: Vector3Like,\n    rotation: RotationLike,\n    geocoordinate: Vector3Like | None = None,\n) -&gt; None\n</code></pre> <pre><code>render_ego(*args, **kwargs) -&gt; None\n</code></pre> <p>Render an ego pose.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_ego(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render an ego pose.\"\"\"\n    if len(args) + len(kwargs) == 1:\n        self._render_ego_with_schema(*args, **kwargs)\n    else:\n        self._render_ego_without_schema(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_calibration","title":"render_calibration","text":"<pre><code>render_calibration(\n    sensor: Sensor,\n    calibration: CalibratedSensor,\n    resolution: Vector2Like | None = None,\n) -&gt; None\n</code></pre><pre><code>render_calibration(\n    channel: str,\n    modality: str | SensorModality,\n    translation: Vector3Like,\n    rotation: RotationLike,\n    camera_intrinsic: CameraIntrinsicLike | None = None,\n    resolution: Vector2Like | None = None,\n) -&gt; None\n</code></pre> <pre><code>render_calibration(*args, **kwargs) -&gt; None\n</code></pre> <p>Render a sensor calibration.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_calibration(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render a sensor calibration.\"\"\"\n    if len(args) + len(kwargs) &lt;= 3:\n        self._render_calibration_with_schema(*args, **kwargs)\n    else:\n        self._render_calibration_without_schema(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_map","title":"render_map","text":"<pre><code>render_map(filepath: str) -&gt; None\n</code></pre> <p>Render vector map.</p> <p>Parameters:</p> <ul> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>Path to OSM file.</p> </li> </ul> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_filepath\n@_check_spatial3d\ndef render_map(self, filepath: str) -&gt; None:\n    \"\"\"Render vector map.\n\n    Args:\n        filepath (str): Path to OSM file.\n    \"\"\"\n    parser = LaneletParser(filepath, verbose=False)\n\n    root_entity = format_entity(self.config.map_entity, \"vector_map\")\n    render_lanelets(parser, root_entity)\n    render_traffic_elements(parser, root_entity)\n    render_ways(parser, root_entity)\n\n    render_geographic_borders(parser, f\"{self.config.geocoordinate_entity}/vector_map\")\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig","title":"ViewerConfig","text":""},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig.to_blueprint","title":"to_blueprint","text":"<pre><code>to_blueprint() -&gt; rrb.BlueprintLike\n</code></pre> <p>Return the recording blueprint.</p> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def to_blueprint(self) -&gt; rrb.BlueprintLike:\n    \"\"\"Return the recording blueprint.\"\"\"\n    views = []\n    if self.spatial3ds:\n        views.append(rrb.Horizontal(*self.spatial3ds, column_shares=[3, 1]))\n    if self.spatial2ds:\n        views.append(rrb.Grid(*self.spatial2ds))\n\n    return rrb.Vertical(*views, row_shares=[4, 2])\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig.has_spatial3d","title":"has_spatial3d","text":"<pre><code>has_spatial3d() -&gt; bool\n</code></pre> <p>Return <code>True</code> if the configuration contains 3D view space.</p> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def has_spatial3d(self) -&gt; bool:\n    \"\"\"Return `True` if the configuration contains 3D view space.\"\"\"\n    return len(self.spatial3ds) &gt; 0\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig.has_spatial2d","title":"has_spatial2d","text":"<pre><code>has_spatial2d() -&gt; bool\n</code></pre> <p>Return <code>True</code> if the configuration contains 2D view space.</p> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def has_spatial2d(self) -&gt; bool:\n    \"\"\"Return `True` if the configuration contains 2D view space.\"\"\"\n    return len(self.spatial2ds) &gt; 0\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.pointcloud_color","title":"pointcloud_color","text":"<pre><code>pointcloud_color(\n    pointcloud: PointCloudLike,\n    color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n) -&gt; NDArrayF64\n</code></pre> <p>Return color map depending on the specified color mode.</p> <p>Parameters:</p> <ul> <li> <code>pointcloud</code>               (<code>PointCloudLike</code>)           \u2013            <p>Any inheritance of <code>PointCloud</code> class.</p> </li> <li> <code>color_mode</code>               (<code>PointCloudColorMode</code>, default:                   <code>DISTANCE</code> )           \u2013            <p>Color mode for pointcloud.</p> </li> </ul> Source code in <code>t4_devkit/viewer/color.py</code> <pre><code>def pointcloud_color(\n    pointcloud: PointCloudLike,\n    color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n) -&gt; NDArrayF64:\n    \"\"\"Return color map depending on the specified color mode.\n\n    Args:\n        pointcloud (PointCloudLike): Any inheritance of `PointCloud` class.\n        color_mode (PointCloudColorMode, optional): Color mode for pointcloud.\n    \"\"\"\n    match color_mode:\n        case PointCloudColorMode.DISTANCE:\n            values = np.linalg.norm(pointcloud.points[:3].T, axis=1)\n        case PointCloudColorMode.INTENSITY:\n            values = pointcloud.points[3]\n        case _:\n            raise ValueError(f\"Unsupported color mode: {color_mode}\")\n\n    return _normalize_color(values)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.calculate_geodetic_point","title":"calculate_geodetic_point","text":"<pre><code>calculate_geodetic_point(\n    position: Vector3Like, origin: Vector2Like\n) -&gt; Vector2\n</code></pre> <p>Transform a position in a map coordinate system to a position in a geodetic coordinate system.</p> <p>Parameters:</p> <ul> <li> <code>position</code>               (<code>Vector3Like</code>)           \u2013            <p>3D position in a map coordinate system.</p> </li> <li> <code>origin</code>               (<code>Vector2Like</code>)           \u2013            <p>Map origin position in a geodetic coordinate system, which is (latitude, longitude).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>Vector2</code>           \u2013            <p>Transformed position in a geodetic coordinate system, which is (latitude, longitude).</p> </li> </ul> Source code in <code>t4_devkit/viewer/geography.py</code> <pre><code>def calculate_geodetic_point(position: Vector3Like, origin: Vector2Like) -&gt; Vector2:\n    \"\"\"Transform a position in a map coordinate system to a position in a geodetic coordinate system.\n\n    Args:\n        position (Vector3Like): 3D position in a map coordinate system.\n        origin (Vector2Like): Map origin position in a geodetic coordinate system,\n            which is (latitude, longitude).\n\n    Returns:\n        Transformed position in a geodetic coordinate system, which is (latitude, longitude).\n    \"\"\"\n    x, y, _ = Vector3(position)\n    bearing = math.atan2(x, y)\n    distance = math.hypot(x, y)\n\n    latitude, longitude = np.radians(Vector2(origin))\n    angular_distance = distance / EARTH_RADIUS_METERS\n\n    target_latitude = math.asin(\n        math.sin(latitude) * math.cos(angular_distance)\n        + math.cos(latitude) * math.sin(angular_distance) * math.cos(bearing)\n    )\n    target_longitude = longitude + math.atan2(\n        math.sin(bearing) * math.sin(angular_distance) * math.cos(latitude),\n        math.cos(angular_distance) - math.sin(latitude) * math.sin(target_latitude),\n    )\n\n    return Vector2(math.degrees(target_latitude), math.degrees(target_longitude))\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.format_entity","title":"format_entity","text":"<pre><code>format_entity(*entities: Sequence[str]) -&gt; str\n</code></pre> <p>Format entity path.</p> <p>Parameters:</p> <ul> <li> <code>*entities</code>               (<code>Sequence[str]</code>, default:                   <code>()</code> )           \u2013            <p>Entity path(s).</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Formatted entity path.</p> </li> </ul> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_entity(\"map\")\n\"map\"\n&gt;&gt;&gt; format_entity(\"map\", \"map/base_link\")\n\"map/base_link\"\n&gt;&gt;&gt; format_entity(\"map\", \"map/base_link\", \"camera\")\n\"map/base_link/camera\"\n</code></pre> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def format_entity(*entities: Sequence[str]) -&gt; str:\n    \"\"\"Format entity path.\n\n    Args:\n        *entities: Entity path(s).\n\n    Returns:\n        Formatted entity path.\n\n    Examples:\n        &gt;&gt;&gt; format_entity(\"map\")\n        \"map\"\n        &gt;&gt;&gt; format_entity(\"map\", \"map/base_link\")\n        \"map/base_link\"\n        &gt;&gt;&gt; format_entity(\"map\", \"map/base_link\", \"camera\")\n        \"map/base_link/camera\"\n    \"\"\"\n    if not entities:\n        return \"\"\n\n    flattened = []\n    for entity in entities:\n        for part in entity.split(\"/\"):\n            if part and flattened and flattened[-1] == part:\n                continue\n            flattened.append(part)\n    return \"/\".join(flattened)\n</code></pre>"},{"location":"apis/schema/","title":"<code>schema</code>","text":"<ul> <li>Schema Names</li> <li>Schema Tables</li> <li>Other Items for Schema Tables</li> <li>Schema Registry</li> <li>Serialize Schema</li> </ul>"},{"location":"apis/schema/name/","title":"Schema Names","text":"<p>Under the hood, <code>t4-devkit</code> declares an enum called <code>SchemaName</code>. This enum includes names of each schema table that should be contained in the T4 dataset as <code>.json</code> file.</p> <p>Note that some schema tables are not mandatory, such as <code>object_ann.json</code> and <code>surface_ann.json</code>. For these tables, the method called <code>is_optional()</code> returns <code>True</code> and it is OK that these corresponding <code>.json</code> files are not contained in T4 dataset:</p> <pre><code>from t4_devkit.schema import SchemaName\n\n&gt;&gt;&gt; SchemaName.OBJECT_ANN.is_optional()\nTrue\n</code></pre>"},{"location":"apis/schema/name/#t4_devkit.schema.name","title":"t4_devkit.schema.name","text":""},{"location":"apis/schema/name/#t4_devkit.schema.name.SchemaName","title":"SchemaName","text":"<p>An enum to represent schema filenames.</p> <p>Attributes:</p> <ul> <li> <code>ATTRIBUTE</code>           \u2013            <p>Property of an instance that can change while the category remains the same.</p> </li> <li> <code>CALIBRATED_SENSOR</code>           \u2013            <p>Definition of a particular sensor as calibrated on a vehicle.</p> </li> <li> <code>CATEGORY</code>           \u2013            <p>Object categories.</p> </li> <li> <code>EGO_POSE</code>           \u2013            <p>Ego vehicle pose at at particular timestamp.</p> </li> <li> <code>INSTANCE</code>           \u2013            <p>An object instance.</p> </li> <li> <code>LOG</code>           \u2013            <p>Information about the log from which the data aws extracted.</p> </li> <li> <code>MAP</code>           \u2013            <p>Map data that is stored as binary semantic masks from a top-down view.</p> </li> <li> <code>SAMPLE</code>           \u2013            <p>A sample is an annotated keyframe at specific Hz.</p> </li> <li> <code>SAMPLE_ANNOTATION</code>           \u2013            <p>A bounding box defining the position of an object seen in a sample.</p> </li> <li> <code>SAMPLE_DATA</code>           \u2013            <p>A sensor data e.g. image, pointcloud or radar return.</p> </li> <li> <code>SCENE</code>           \u2013            <p>A scene is a specific long sequence of consecutive frames extracted from a log.</p> </li> <li> <code>SENSOR</code>           \u2013            <p>A specific sensor type.</p> </li> <li> <code>VISIBILITY</code>           \u2013            <p>The visibility of instance is the fraction of annotation visible in all images.</p> </li> <li> <code>LIDARSEG</code>               (<code>optional</code>)           \u2013            <p>The annotation of 3D point cloud segmentation.</p> </li> <li> <code>OBJECT_ANN</code>               (<code>optional</code>)           \u2013            <p>The annotation of a foreground object in an image.</p> </li> <li> <code>SURFACE_ANN</code>               (<code>optional</code>)           \u2013            <p>The annotation of a background object in an image.</p> </li> <li> <code>KEYPOINT</code>               (<code>optional</code>)           \u2013            <p>The annotation of pose keypoints of an object in an image.</p> </li> <li> <code>VEHICLE_STATE</code>               (<code>optional</code>)           \u2013            <p>The annotation of ego vehicle states.</p> </li> </ul>"},{"location":"apis/schema/name/#t4_devkit.schema.name.SchemaName.filename","title":"filename  <code>property</code>","text":"<pre><code>filename: str\n</code></pre> <p>Return the annotation json filename.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>Annotation json filename.</p> </li> </ul>"},{"location":"apis/schema/name/#t4_devkit.schema.name.SchemaName.is_optional","title":"is_optional","text":"<pre><code>is_optional() -&gt; bool\n</code></pre> <p>Indicates if this schema name is optional.</p> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return True if this schema is optional.</p> </li> </ul> Source code in <code>t4_devkit/schema/name.py</code> <pre><code>def is_optional(self) -&gt; bool:\n    \"\"\"Indicates if this schema name is optional.\n\n    Returns:\n        Return True if this schema is optional.\n    \"\"\"\n    return self in (\n        SchemaName.LIDARSEG,\n        SchemaName.OBJECT_ANN,\n        SchemaName.SURFACE_ANN,\n        SchemaName.KEYPOINT,\n        SchemaName.VEHICLE_STATE,\n    )\n</code></pre>"},{"location":"apis/schema/other/","title":"Other Items for Tables","text":"<p>Following classes are sub items composed of each schema tables.</p>"},{"location":"apis/schema/other/#sampledata","title":"<code>SampleData</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat","title":"FileFormat","text":"<p>An enum to represent file formats.</p> <p>Attributes:</p> <ul> <li> <code>JPG</code>           \u2013            <p>JPG format for image data.</p> </li> <li> <code>PNG</code>           \u2013            <p>PNG format for image data.</p> </li> <li> <code>PCD</code>           \u2013            <p>PCD format for pointcloud data.</p> </li> <li> <code>BIN</code>           \u2013            <p>BIN format.</p> </li> <li> <code>PCDBIN</code>           \u2013            <p>PCD.BIN format for pointcloud data.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@unique\nclass FileFormat(str, Enum):\n    \"\"\"An enum to represent file formats.\n\n    Attributes:\n        JPG: JPG format for image data.\n        PNG: PNG format for image data.\n        PCD: PCD format for pointcloud data.\n        BIN: BIN format.\n        PCDBIN: PCD.BIN format for pointcloud data.\n    \"\"\"\n\n    JPG = \"jpg\"\n    PNG = \"png\"\n    PCD = \"pcd\"\n    BIN = \"bin\"\n    PCDBIN = \"pcd.bin\"\n\n    @staticmethod\n    def is_member(item: str) -&gt; bool:\n        \"\"\"Indicate whether the input item is the one of members of FileFormat.\n\n        Args:\n            item (str): Any file format name.\n\n        Returns:\n            Return True if the item is included.\n        \"\"\"\n        return item in FileFormat.values()\n\n    @staticmethod\n    def values() -&gt; list[str]:\n        \"\"\"Return a list of values of members.\n\n        Returns:\n            List of values.\n        \"\"\"\n        return [v.value for v in FileFormat]\n\n    def as_ext(self) -&gt; str:\n        \"\"\"Return the value as file extension.\n\n        Returns:\n            File extension.\n        \"\"\"\n        return f\".{self.value}\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat.is_member","title":"is_member  <code>staticmethod</code>","text":"<pre><code>is_member(item)\n</code></pre> <p>Indicate whether the input item is the one of members of FileFormat.</p> <p>Parameters:</p> <ul> <li> <code>item</code>               (<code>str</code>)           \u2013            <p>Any file format name.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>bool</code>           \u2013            <p>Return True if the item is included.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@staticmethod\ndef is_member(item: str) -&gt; bool:\n    \"\"\"Indicate whether the input item is the one of members of FileFormat.\n\n    Args:\n        item (str): Any file format name.\n\n    Returns:\n        Return True if the item is included.\n    \"\"\"\n    return item in FileFormat.values()\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat.values","title":"values  <code>staticmethod</code>","text":"<pre><code>values()\n</code></pre> <p>Return a list of values of members.</p> <p>Returns:</p> <ul> <li> <code>list[str]</code>           \u2013            <p>List of values.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@staticmethod\ndef values() -&gt; list[str]:\n    \"\"\"Return a list of values of members.\n\n    Returns:\n        List of values.\n    \"\"\"\n    return [v.value for v in FileFormat]\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat.as_ext","title":"as_ext","text":"<pre><code>as_ext()\n</code></pre> <p>Return the value as file extension.</p> <p>Returns:</p> <ul> <li> <code>str</code>           \u2013            <p>File extension.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>def as_ext(self) -&gt; str:\n    \"\"\"Return the value as file extension.\n\n    Returns:\n        File extension.\n    \"\"\"\n    return f\".{self.value}\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.SensorModality","title":"SensorModality","text":"<p>An enum to represent sensor modalities.</p> <p>Attributes:</p> <ul> <li> <code>LIDAR</code>           \u2013            <p>Lidar sensor.</p> </li> <li> <code>CAMERA</code>           \u2013            <p>Camera sensor.</p> </li> <li> <code>RADAR</code>           \u2013            <p>Radar sensor.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/sensor.py</code> <pre><code>@unique\nclass SensorModality(str, Enum):\n    \"\"\"An enum to represent sensor modalities.\n\n    Attributes:\n        LIDAR: Lidar sensor.\n        CAMERA: Camera sensor.\n        RADAR: Radar sensor.\n    \"\"\"\n\n    LIDAR = \"lidar\"\n    CAMERA = \"camera\"\n    RADAR = \"radar\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel","title":"VisibilityLevel","text":"<p>An enum to represent visibility levels.</p> <p>Attributes:</p> <ul> <li> <code>FULL</code>           \u2013            <p>No occlusion for the object.</p> </li> <li> <code>MOST</code>           \u2013            <p>Object is occluded, but by less than 50%.</p> </li> <li> <code>PARTIAL</code>           \u2013            <p>Object is occluded, but by more than 50%.</p> </li> <li> <code>NONE</code>           \u2013            <p>Object is 90-100% occluded and no points/pixels are visible in the label.</p> </li> <li> <code>UNAVAILABLE</code>           \u2013            <p>Visibility level is not specified.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@unique\nclass VisibilityLevel(str, Enum):\n    \"\"\"An enum to represent visibility levels.\n\n    Attributes:\n        FULL: No occlusion for the object.\n        MOST: Object is occluded, but by less than 50%.\n        PARTIAL: Object is occluded, but by more than 50%.\n        NONE: Object is 90-100% occluded and no points/pixels are visible in the label.\n        UNAVAILABLE: Visibility level is not specified.\n    \"\"\"\n\n    FULL = \"full\"\n    MOST = \"most\"\n    PARTIAL = \"partial\"\n    NONE = \"none\"\n    UNAVAILABLE = \"unavailable\"\n\n    @classmethod\n    def from_value(cls, level: str) -&gt; Self:\n        \"\"\"Load member from its value.\"\"\"\n        if level not in cls.__members__.values():\n            return cls._from_alias(level)\n        return cls(level)\n\n    @staticmethod\n    def _from_alias(level: str) -&gt; Self:\n        \"\"\"Load member from alias format of level.\n\n        Args:\n            level (str): Level of visibility.\n        \"\"\"\n        if level == \"v0-40\":\n            return VisibilityLevel.NONE\n        elif level == \"v40-60\":\n            return VisibilityLevel.PARTIAL\n        elif level == \"v60-80\":\n            return VisibilityLevel.MOST\n        elif level == \"v80-100\":\n            return VisibilityLevel.FULL\n        else:\n            warnings.warn(\n                f\"level: {level} is not supported, Visibility.UNAVAILABLE will be assigned.\"\n            )\n            return VisibilityLevel.UNAVAILABLE\n\n    def rank(self) -&gt; int:\n        \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n        ranking = {\n            \"full\": 4,\n            \"most\": 3,\n            \"partial\": 2,\n            \"none\": 1,\n            \"unavailable\": None,\n        }\n        return ranking[self.value]\n\n    def is_comparable(self) -&gt; bool:\n        \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n        return self.rank() is not None\n\n    def _check_comparability(self, other: VisibilityLevel) -&gt; None:\n        if not (self.is_comparable() and other.is_comparable()):\n            raise ValueError(f\"Cannot compare unknown visibility levels: {self}, {other}\")\n\n    def __lt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt; other.rank()\n\n    def __le__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt;= other.rank()\n\n    def __gt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt; other.rank()\n\n    def __ge__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt;= other.rank()\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.from_value","title":"from_value  <code>classmethod</code>","text":"<pre><code>from_value(level)\n</code></pre> <p>Load member from its value.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@classmethod\ndef from_value(cls, level: str) -&gt; Self:\n    \"\"\"Load member from its value.\"\"\"\n    if level not in cls.__members__.values():\n        return cls._from_alias(level)\n    return cls(level)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.rank","title":"rank","text":"<pre><code>rank()\n</code></pre> <p>Return an integer rank for comparison (higher is more visible).</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def rank(self) -&gt; int:\n    \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n    ranking = {\n        \"full\": 4,\n        \"most\": 3,\n        \"partial\": 2,\n        \"none\": 1,\n        \"unavailable\": None,\n    }\n    return ranking[self.value]\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.is_comparable","title":"is_comparable","text":"<pre><code>is_comparable()\n</code></pre> <p>Return True if the visibility level has a defined rank.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def is_comparable(self) -&gt; bool:\n    \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n    return self.rank() is not None\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask","title":"RLEMask","text":"<p>A dataclass to represent segmentation mask compressed by RLE.</p> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>list[int, int]</code>)           \u2013            <p>Size of image ordering (width, height).</p> </li> <li> <code>counts</code>               (<code>str</code>)           \u2013            <p>RLE compressed mask data.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>@define\nclass RLEMask:\n    \"\"\"A dataclass to represent segmentation mask compressed by RLE.\n\n    Attributes:\n        size (list[int, int]): Size of image ordering (width, height).\n        counts (str): RLE compressed mask data.\n    \"\"\"\n\n    size: list[int, int] = field(validator=validators.deep_iterable(validators.instance_of(int)))\n    counts: str = field(validator=validators.instance_of(str))\n\n    @property\n    def width(self) -&gt; int:\n        return self.size[0]\n\n    @property\n    def height(self) -&gt; int:\n        return self.size[1]\n\n    def decode(self) -&gt; NDArrayU8:\n        \"\"\"Decode segmentation mask.\n\n        Returns:\n            Decoded mask in shape of (H, W).\n        \"\"\"\n        counts = base64.b64decode(self.counts)\n        data = {\"counts\": counts, \"size\": self.size}\n        return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask.decode","title":"decode","text":"<pre><code>decode()\n</code></pre> <p>Decode segmentation mask.</p> <p>Returns:</p> <ul> <li> <code>NDArrayU8</code>           \u2013            <p>Decoded mask in shape of (H, W).</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>def decode(self) -&gt; NDArrayU8:\n    \"\"\"Decode segmentation mask.\n\n    Returns:\n        Decoded mask in shape of (H, W).\n    \"\"\"\n    counts = base64.b64decode(self.counts)\n    data = {\"counts\": counts, \"size\": self.size}\n    return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.ShiftState","title":"ShiftState","text":"<p>An enum to represent gear shift state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass ShiftState(str, Enum):\n    \"\"\"An enum to represent gear shift state.\"\"\"\n\n    PARK = \"PARK\"\n    REVERSE = \"REVERSE\"\n    NEUTRAL = \"NEUTRAL\"\n    HIGH = \"HIGH\"\n    FORWARD = \"FORWARD\"\n    LOW = \"LOW\"\n    NONE = \"NONE\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.IndicatorState","title":"IndicatorState","text":"<p>An enum to represent indicator state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass IndicatorState(str, Enum):\n    \"\"\"An enum to represent indicator state.\"\"\"\n\n    ON = \"on\"\n    OFF = \"off\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.Indicators","title":"Indicators","text":"<p>A dataclass to represent state of each indicator.</p> <p>Attributes:</p> <ul> <li> <code>left</code>               (<code>IndicatorState</code>)           \u2013            <p>State of the left indicator.</p> </li> <li> <code>right</code>               (<code>IndicatorState</code>)           \u2013            <p>State of the right indicator.</p> </li> <li> <code>hazard</code>               (<code>IndicatorState</code>)           \u2013            <p>State of the hazard lights.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass Indicators:\n    \"\"\"A dataclass to represent state of each indicator.\n\n    Attributes:\n        left (IndicatorState): State of the left indicator.\n        right (IndicatorState): State of the right indicator.\n        hazard (IndicatorState): State of the hazard lights.\n    \"\"\"\n\n    left: IndicatorState = field(converter=IndicatorState)\n    right: IndicatorState = field(converter=IndicatorState)\n    hazard: IndicatorState = field(converter=IndicatorState)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AdditionalInfo","title":"AdditionalInfo","text":"<p>A dataclass to represent additional state information of the ego vehicle.</p> <p>Attributes:</p> <ul> <li> <code>speed</code>               (<code>float | None</code>)           \u2013            <p>Speed of the ego vehicle.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass AdditionalInfo:\n    \"\"\"A dataclass to represent additional state information of the ego vehicle.\n\n    Attributes:\n        speed (float | None): Speed of the ego vehicle.\n    \"\"\"\n\n    speed: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AutolabelModel","title":"AutolabelModel","text":"<p>A dataclass to represent a model used in autolabeling.</p> <p>Attributes:</p> <ul> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Name of the model used for annotation. Can include version information.</p> </li> <li> <code>score</code>               (<code>float</code>)           \u2013            <p>Label score for the annotation from this model (range: 0.0\u20131.0).</p> </li> <li> <code>uncertainty</code>               (<code>float | None</code>)           \u2013            <p>Model-reported uncertainty for the annotation (range: 0.0\u20131.0). Lower values imply higher confidence.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/autolabel_metadata.py</code> <pre><code>@define\nclass AutolabelModel:\n    \"\"\"A dataclass to represent a model used in autolabeling.\n\n    Attributes:\n        name (str): Name of the model used for annotation. Can include version information.\n        score (float): Label score for the annotation from this model (range: 0.0\u20131.0).\n        uncertainty (float | None, optional): Model-reported uncertainty for the annotation (range: 0.0\u20131.0).\n            Lower values imply higher confidence.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    score: float = field(\n        validator=[\n            validators.instance_of(float),\n            validators.and_(validators.ge(0.0), validators.le(1.0)),\n        ]\n    )\n    uncertainty: float | None = field(\n        default=None,\n        validator=validators.optional(\n            (validators.instance_of(float), validators.and_(validators.ge(0.0), validators.le(1.0)))\n        ),\n    )\n\n    @staticmethod\n    def to_autolabel_model(x: list[dict | AutolabelModel] | None) -&gt; list[AutolabelModel] | None:\n        \"\"\"Convert input to a list of AutolabelModel instances.\n\n        Args:\n            x (list[dict | AutolabelModel] | None): Input to convert. Can be None, a list of dicts, or a list of AutolabelModel instances.\n\n        Returns:\n            list[AutolabelModel] | None: Converted list of AutolabelModel instances or None.\n        \"\"\"\n        if x is None:\n            return None\n        if isinstance(x, list):\n            return [AutolabelModel(**model) if isinstance(model, dict) else model for model in x]\n        raise TypeError(\"Input must be None or a list of [dicts or AutolabelModel] instances.\")\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AutolabelModel.to_autolabel_model","title":"to_autolabel_model  <code>staticmethod</code>","text":"<pre><code>to_autolabel_model(x)\n</code></pre> <p>Convert input to a list of AutolabelModel instances.</p> <p>Parameters:</p> <ul> <li> <code>x</code>               (<code>list[dict | AutolabelModel] | None</code>)           \u2013            <p>Input to convert. Can be None, a list of dicts, or a list of AutolabelModel instances.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[AutolabelModel] | None</code>           \u2013            <p>list[AutolabelModel] | None: Converted list of AutolabelModel instances or None.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/autolabel_metadata.py</code> <pre><code>@staticmethod\ndef to_autolabel_model(x: list[dict | AutolabelModel] | None) -&gt; list[AutolabelModel] | None:\n    \"\"\"Convert input to a list of AutolabelModel instances.\n\n    Args:\n        x (list[dict | AutolabelModel] | None): Input to convert. Can be None, a list of dicts, or a list of AutolabelModel instances.\n\n    Returns:\n        list[AutolabelModel] | None: Converted list of AutolabelModel instances or None.\n    \"\"\"\n    if x is None:\n        return None\n    if isinstance(x, list):\n        return [AutolabelModel(**model) if isinstance(model, dict) else model for model in x]\n    raise TypeError(\"Input must be None or a list of [dicts or AutolabelModel] instances.\")\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AutolabelMixin","title":"AutolabelMixin","text":"<p>Mixin class for schema tables that use autolabel metadata with automatic annotation.</p> Source code in <code>t4_devkit/schema/tables/autolabel_metadata.py</code> <pre><code>@define(slots=False)\nclass AutolabelMixin:\n    \"\"\"Mixin class for schema tables that use autolabel metadata with automatic annotation.\"\"\"\n\n    automatic_annotation: bool = field(\n        default=False, validator=validators.instance_of(bool), kw_only=True\n    )\n    autolabel_metadata: list[AutolabelModel] | None = field(\n        default=None,\n        converter=AutolabelModel.to_autolabel_model,\n        validator=validators.optional(\n            validators.deep_iterable(validators.instance_of(AutolabelModel))\n        ),\n        kw_only=True,\n    )\n\n    def __attrs_post_init__(self) -&gt; None:\n        \"\"\"Post-initialization validation for autolabel consistency.\"\"\"\n        # if automatic_annotation=True, autolabel_metadata must exist\n        if self.automatic_annotation and self.autolabel_metadata is None:\n            raise TypeError(\"autolabel_metadata must be provided when automatic_annotation is True\")\n        # if automatic_annotation=False, autolabel_metadata must not exist\n        if not self.automatic_annotation and self.autolabel_metadata is not None:\n            raise TypeError(\"autolabel_metadata must be None when automatic_annotation is False\")\n</code></pre>"},{"location":"apis/schema/other/#sensor","title":"<code>Sensor</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.SensorModality","title":"SensorModality","text":"<p>An enum to represent sensor modalities.</p> <p>Attributes:</p> <ul> <li> <code>LIDAR</code>           \u2013            <p>Lidar sensor.</p> </li> <li> <code>CAMERA</code>           \u2013            <p>Camera sensor.</p> </li> <li> <code>RADAR</code>           \u2013            <p>Radar sensor.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/sensor.py</code> <pre><code>@unique\nclass SensorModality(str, Enum):\n    \"\"\"An enum to represent sensor modalities.\n\n    Attributes:\n        LIDAR: Lidar sensor.\n        CAMERA: Camera sensor.\n        RADAR: Radar sensor.\n    \"\"\"\n\n    LIDAR = \"lidar\"\n    CAMERA = \"camera\"\n    RADAR = \"radar\"\n</code></pre>"},{"location":"apis/schema/other/#objectannsurfaceann","title":"<code>ObjectAnn</code>/<code>SurfaceAnn</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask","title":"RLEMask","text":"<p>A dataclass to represent segmentation mask compressed by RLE.</p> <p>Attributes:</p> <ul> <li> <code>size</code>               (<code>list[int, int]</code>)           \u2013            <p>Size of image ordering (width, height).</p> </li> <li> <code>counts</code>               (<code>str</code>)           \u2013            <p>RLE compressed mask data.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>@define\nclass RLEMask:\n    \"\"\"A dataclass to represent segmentation mask compressed by RLE.\n\n    Attributes:\n        size (list[int, int]): Size of image ordering (width, height).\n        counts (str): RLE compressed mask data.\n    \"\"\"\n\n    size: list[int, int] = field(validator=validators.deep_iterable(validators.instance_of(int)))\n    counts: str = field(validator=validators.instance_of(str))\n\n    @property\n    def width(self) -&gt; int:\n        return self.size[0]\n\n    @property\n    def height(self) -&gt; int:\n        return self.size[1]\n\n    def decode(self) -&gt; NDArrayU8:\n        \"\"\"Decode segmentation mask.\n\n        Returns:\n            Decoded mask in shape of (H, W).\n        \"\"\"\n        counts = base64.b64decode(self.counts)\n        data = {\"counts\": counts, \"size\": self.size}\n        return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask.decode","title":"decode","text":"<pre><code>decode()\n</code></pre> <p>Decode segmentation mask.</p> <p>Returns:</p> <ul> <li> <code>NDArrayU8</code>           \u2013            <p>Decoded mask in shape of (H, W).</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>def decode(self) -&gt; NDArrayU8:\n    \"\"\"Decode segmentation mask.\n\n    Returns:\n        Decoded mask in shape of (H, W).\n    \"\"\"\n    counts = base64.b64decode(self.counts)\n    data = {\"counts\": counts, \"size\": self.size}\n    return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#visibility","title":"<code>Visibility</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel","title":"VisibilityLevel","text":"<p>An enum to represent visibility levels.</p> <p>Attributes:</p> <ul> <li> <code>FULL</code>           \u2013            <p>No occlusion for the object.</p> </li> <li> <code>MOST</code>           \u2013            <p>Object is occluded, but by less than 50%.</p> </li> <li> <code>PARTIAL</code>           \u2013            <p>Object is occluded, but by more than 50%.</p> </li> <li> <code>NONE</code>           \u2013            <p>Object is 90-100% occluded and no points/pixels are visible in the label.</p> </li> <li> <code>UNAVAILABLE</code>           \u2013            <p>Visibility level is not specified.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@unique\nclass VisibilityLevel(str, Enum):\n    \"\"\"An enum to represent visibility levels.\n\n    Attributes:\n        FULL: No occlusion for the object.\n        MOST: Object is occluded, but by less than 50%.\n        PARTIAL: Object is occluded, but by more than 50%.\n        NONE: Object is 90-100% occluded and no points/pixels are visible in the label.\n        UNAVAILABLE: Visibility level is not specified.\n    \"\"\"\n\n    FULL = \"full\"\n    MOST = \"most\"\n    PARTIAL = \"partial\"\n    NONE = \"none\"\n    UNAVAILABLE = \"unavailable\"\n\n    @classmethod\n    def from_value(cls, level: str) -&gt; Self:\n        \"\"\"Load member from its value.\"\"\"\n        if level not in cls.__members__.values():\n            return cls._from_alias(level)\n        return cls(level)\n\n    @staticmethod\n    def _from_alias(level: str) -&gt; Self:\n        \"\"\"Load member from alias format of level.\n\n        Args:\n            level (str): Level of visibility.\n        \"\"\"\n        if level == \"v0-40\":\n            return VisibilityLevel.NONE\n        elif level == \"v40-60\":\n            return VisibilityLevel.PARTIAL\n        elif level == \"v60-80\":\n            return VisibilityLevel.MOST\n        elif level == \"v80-100\":\n            return VisibilityLevel.FULL\n        else:\n            warnings.warn(\n                f\"level: {level} is not supported, Visibility.UNAVAILABLE will be assigned.\"\n            )\n            return VisibilityLevel.UNAVAILABLE\n\n    def rank(self) -&gt; int:\n        \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n        ranking = {\n            \"full\": 4,\n            \"most\": 3,\n            \"partial\": 2,\n            \"none\": 1,\n            \"unavailable\": None,\n        }\n        return ranking[self.value]\n\n    def is_comparable(self) -&gt; bool:\n        \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n        return self.rank() is not None\n\n    def _check_comparability(self, other: VisibilityLevel) -&gt; None:\n        if not (self.is_comparable() and other.is_comparable()):\n            raise ValueError(f\"Cannot compare unknown visibility levels: {self}, {other}\")\n\n    def __lt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt; other.rank()\n\n    def __le__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt;= other.rank()\n\n    def __gt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt; other.rank()\n\n    def __ge__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt;= other.rank()\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.from_value","title":"from_value  <code>classmethod</code>","text":"<pre><code>from_value(level)\n</code></pre> <p>Load member from its value.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@classmethod\ndef from_value(cls, level: str) -&gt; Self:\n    \"\"\"Load member from its value.\"\"\"\n    if level not in cls.__members__.values():\n        return cls._from_alias(level)\n    return cls(level)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.rank","title":"rank","text":"<pre><code>rank()\n</code></pre> <p>Return an integer rank for comparison (higher is more visible).</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def rank(self) -&gt; int:\n    \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n    ranking = {\n        \"full\": 4,\n        \"most\": 3,\n        \"partial\": 2,\n        \"none\": 1,\n        \"unavailable\": None,\n    }\n    return ranking[self.value]\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.is_comparable","title":"is_comparable","text":"<pre><code>is_comparable()\n</code></pre> <p>Return True if the visibility level has a defined rank.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def is_comparable(self) -&gt; bool:\n    \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n    return self.rank() is not None\n</code></pre>"},{"location":"apis/schema/other/#vehiclestate","title":"<code>VehicleState</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.ShiftState","title":"ShiftState","text":"<p>An enum to represent gear shift state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass ShiftState(str, Enum):\n    \"\"\"An enum to represent gear shift state.\"\"\"\n\n    PARK = \"PARK\"\n    REVERSE = \"REVERSE\"\n    NEUTRAL = \"NEUTRAL\"\n    HIGH = \"HIGH\"\n    FORWARD = \"FORWARD\"\n    LOW = \"LOW\"\n    NONE = \"NONE\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.IndicatorState","title":"IndicatorState","text":"<p>An enum to represent indicator state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass IndicatorState(str, Enum):\n    \"\"\"An enum to represent indicator state.\"\"\"\n\n    ON = \"on\"\n    OFF = \"off\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.Indicators","title":"Indicators","text":"<p>A dataclass to represent state of each indicator.</p> <p>Attributes:</p> <ul> <li> <code>left</code>               (<code>IndicatorState</code>)           \u2013            <p>State of the left indicator.</p> </li> <li> <code>right</code>               (<code>IndicatorState</code>)           \u2013            <p>State of the right indicator.</p> </li> <li> <code>hazard</code>               (<code>IndicatorState</code>)           \u2013            <p>State of the hazard lights.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass Indicators:\n    \"\"\"A dataclass to represent state of each indicator.\n\n    Attributes:\n        left (IndicatorState): State of the left indicator.\n        right (IndicatorState): State of the right indicator.\n        hazard (IndicatorState): State of the hazard lights.\n    \"\"\"\n\n    left: IndicatorState = field(converter=IndicatorState)\n    right: IndicatorState = field(converter=IndicatorState)\n    hazard: IndicatorState = field(converter=IndicatorState)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AdditionalInfo","title":"AdditionalInfo","text":"<p>A dataclass to represent additional state information of the ego vehicle.</p> <p>Attributes:</p> <ul> <li> <code>speed</code>               (<code>float | None</code>)           \u2013            <p>Speed of the ego vehicle.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass AdditionalInfo:\n    \"\"\"A dataclass to represent additional state information of the ego vehicle.\n\n    Attributes:\n        speed (float | None): Speed of the ego vehicle.\n    \"\"\"\n\n    speed: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n</code></pre>"},{"location":"apis/schema/registry/","title":"Schema Registry","text":"<p>Each schema table is registered in <code>SchemaRegistry</code> dynamically at the runtime.</p>"},{"location":"apis/schema/registry/#t4_devkit.schema.builder","title":"t4_devkit.schema.builder","text":""},{"location":"apis/schema/registry/#t4_devkit.schema.builder.build_schema","title":"build_schema","text":"<pre><code>build_schema(\n    name: str | SchemaName, filepath: str\n) -&gt; list[SchemaTable]\n</code></pre> <p>Build schema dataclass from json file path.</p> <p>Parameters:</p> <ul> <li> <code>name</code>               (<code>str | SchemaName</code>)           \u2013            <p>Name of schema table.</p> </li> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>Path to json file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[SchemaTable]</code>           \u2013            <p>List of schema dataclasses.</p> </li> </ul> Source code in <code>t4_devkit/schema/builder.py</code> <pre><code>def build_schema(name: str | SchemaName, filepath: str) -&gt; list[SchemaTable]:\n    \"\"\"Build schema dataclass from json file path.\n\n    Args:\n        name (str | SchemaName): Name of schema table.\n        filepath (str): Path to json file.\n\n    Returns:\n        List of schema dataclasses.\n    \"\"\"\n    return SCHEMAS.build_from_json(name, filepath)\n</code></pre>"},{"location":"apis/schema/registry/#t4_devkit.schema.tables.registry","title":"t4_devkit.schema.tables.registry","text":""},{"location":"apis/schema/registry/#t4_devkit.schema.tables.registry.SCHEMAS","title":"SCHEMAS  <code>module-attribute</code>","text":"<pre><code>SCHEMAS = SchemaRegistry()\n</code></pre>"},{"location":"apis/schema/registry/#t4_devkit.schema.tables.registry.SchemaRegistry","title":"SchemaRegistry","text":"<pre><code>SchemaRegistry()\n</code></pre> <p>A manager class to register schema tables.</p> Source code in <code>t4_devkit/schema/tables/registry.py</code> <pre><code>def __init__(self) -&gt; None:\n    self.__schemas: dict[str, SchemaTable] = {}\n</code></pre>"},{"location":"apis/schema/registry/#t4_devkit.schema.tables.registry.SchemaRegistry.build_from_json","title":"build_from_json","text":"<pre><code>build_from_json(\n    key: str | SchemaName, filepath: str\n) -&gt; list[SchemaTable]\n</code></pre> <p>Build schema dataclass from json.</p> <p>Parameters:</p> <ul> <li> <code>key</code>               (<code>str</code>)           \u2013            <p>Name of schema field.</p> </li> <li> <code>filepath</code>               (<code>str</code>)           \u2013            <p>Path to schema json file.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[SchemaTable]</code>           \u2013            <p>Instantiated dataclass.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/registry.py</code> <pre><code>def build_from_json(self, key: str | SchemaName, filepath: str) -&gt; list[SchemaTable]:\n    \"\"\"Build schema dataclass from json.\n\n    Args:\n        key (str): Name of schema field.\n        filepath (str): Path to schema json file.\n\n    Returns:\n        Instantiated dataclass.\n    \"\"\"\n    if isinstance(key, SchemaName):\n        key = key.value\n\n    schema: SchemaTable = self.get(key)\n    return schema.from_json(filepath)\n</code></pre>"},{"location":"apis/schema/serialize/","title":"Serialize Schema","text":"<p>You can serialize each schema table into <code>dict</code> using following functions.</p>"},{"location":"apis/schema/serialize/#t4_devkit.schema.serialize","title":"t4_devkit.schema.serialize","text":""},{"location":"apis/schema/serialize/#t4_devkit.schema.serialize.serialize_schemas","title":"serialize_schemas","text":"<pre><code>serialize_schemas(data: list[SchemaTable]) -&gt; list[dict]\n</code></pre> <p>Serialize a list of schema dataclasses into list of dict.</p> Deprecated <p>This function is deprecated. Please use <code>serialize_dataclasses()</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>list[SchemaTable]</code>)           \u2013            <p>List of schema dataclasses.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>list[dict]</code>           \u2013            <p>Serialized list of dict data.</p> </li> </ul> Source code in <code>t4_devkit/schema/serialize.py</code> <pre><code>@deprecated(\"`serialize_schemas()` is deprecated. Please use `serialize_dataclasses()` instead.\")\ndef serialize_schemas(data: list[SchemaTable]) -&gt; list[dict]:\n    \"\"\"Serialize a list of schema dataclasses into list of dict.\n\n    Deprecated:\n        This function is deprecated. Please use `serialize_dataclasses()` instead.\n\n    Args:\n        data (list[SchemaTable]): List of schema dataclasses.\n\n    Returns:\n        Serialized list of dict data.\n    \"\"\"\n    return serialize_dataclasses(data)\n</code></pre>"},{"location":"apis/schema/serialize/#t4_devkit.schema.serialize.serialize_schema","title":"serialize_schema","text":"<pre><code>serialize_schema(data: SchemaTable) -&gt; dict\n</code></pre> <p>Serialize a schema dataclass into dict.</p> Deprecated <p>This function is deprecated. Please use <code>serialize_dataclass()</code> instead.</p> <p>Parameters:</p> <ul> <li> <code>data</code>               (<code>SchemaTable</code>)           \u2013            <p>Schema dataclass.</p> </li> </ul> <p>Returns:</p> <ul> <li> <code>dict</code>           \u2013            <p>Serialized dict data.</p> </li> </ul> Source code in <code>t4_devkit/schema/serialize.py</code> <pre><code>@deprecated(\"`serialize_schema()` is deprecated. Please use `serialize_dataclass()` instead.\")\ndef serialize_schema(data: SchemaTable) -&gt; dict:\n    \"\"\"Serialize a schema dataclass into dict.\n\n    Deprecated:\n        This function is deprecated. Please use `serialize_dataclass()` instead.\n\n    Args:\n        data (SchemaTable): Schema dataclass.\n\n    Returns:\n        Serialized dict data.\n    \"\"\"\n    return serialize_dataclass(data)\n</code></pre>"},{"location":"apis/schema/table/","title":"Schema Tables","text":""},{"location":"apis/schema/table/#t4_devkit.schema.tables","title":"t4_devkit.schema.tables","text":""},{"location":"apis/schema/table/#t4_devkit.schema.tables.Attribute","title":"Attribute","text":"<p>A dataclass to represent schema table of <code>attribute.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Attribute name.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>Attribute description.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/attribute.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.ATTRIBUTE)\nclass Attribute(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `attribute.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        name (str): Attribute name.\n        description (str): Attribute description.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    description: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.CalibratedSensor","title":"CalibratedSensor","text":"<p>A dataclass to represent schema table of <code>calibrated_sensor.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>sensor_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the sensor type.</p> </li> <li> <code>translation</code>               (<code>Vector3</code>)           \u2013            <p>Coordinates system origin given as [x, y, z] in [m].</p> </li> <li> <code>rotation</code>               (<code>Quaternion</code>)           \u2013            <p>Coordinates system orientation given as quaternion [w, x, y, z].</p> </li> <li> <code>camera_intrinsic</code>               (<code>CameraIntrinsic</code>)           \u2013            <p>3x3 camera intrinsic matrix. Empty for sensors that are not cameras.</p> </li> <li> <code>camera_distortion</code>               (<code>CameraDistortion</code>)           \u2013            <p>Camera distortion array. Empty for sensors that are not cameras.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/calibrated_sensor.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.CALIBRATED_SENSOR)\nclass CalibratedSensor(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `calibrated_sensor.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sensor_token (str): Foreign key pointing to the sensor type.\n        translation (Vector3): Coordinates system origin given as [x, y, z] in [m].\n        rotation (Quaternion): Coordinates system orientation given as quaternion [w, x, y, z].\n        camera_intrinsic (CameraIntrinsic): 3x3 camera intrinsic matrix. Empty for sensors that are not cameras.\n        camera_distortion (CameraDistortion): Camera distortion array. Empty for sensors that are not cameras.\n    \"\"\"\n\n    sensor_token: str = field(validator=validators.instance_of(str))\n    translation: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    camera_intrinsic: CameraIntrinsic = field(converter=CameraIntrinsic)\n    camera_distortion: CameraDistortion = field(converter=CameraDistortion)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Category","title":"Category","text":"<p>A dataclass to represent schema table of <code>category.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Category name.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>Category description.</p> </li> <li> <code>index</code>               (<code>int | None</code>)           \u2013            <p>Category index for lidar segmentation.</p> </li> <li> <code>has_orientation</code>               (<code>bool | None</code>)           \u2013            <p>Indicates whether annotations for this category may include an <code>orientation</code> field (e.g., traffic light arrows). If omitted, it is treated as <code>false</code>.</p> </li> <li> <code>has_number</code>               (<code>bool | None</code>)           \u2013            <p>Indicates whether annotations for this category may include a <code>number</code> field (e.g., numeric traffic lights). If omitted, it is treated as <code>false</code>.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/category.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.CATEGORY)\nclass Category(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `category.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        name (str): Category name.\n        description (str): Category description.\n        index (int | None, optional): Category index for lidar segmentation.\n        has_orientation (bool | None, optional): Indicates whether annotations for this category may include an `orientation` field (e.g., traffic light arrows). If omitted, it is treated as `false`.\n        has_number (bool | None, optional): Indicates whether annotations for this category may include a `number` field (e.g., numeric traffic lights). If omitted, it is treated as `false`.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    description: str = field(validator=validators.instance_of(str))\n    index: int | None = field(\n        default=None, validator=validators.optional(validators.instance_of(int))\n    )\n    has_orientation: bool = field(default=False, validator=validators.instance_of(bool))\n    has_number: bool = field(default=False, validator=validators.instance_of(bool))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.EgoPose","title":"EgoPose","text":"<p>A dataclass to represent schema table of <code>ego_pose.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>translation</code>               (<code>Vector3</code>)           \u2013            <p>Coordinate system origin given as [x, y, z] in [m].</p> </li> <li> <code>rotation</code>               (<code>Quaternion</code>)           \u2013            <p>Coordinate system orientation given as quaternion [w, x, y, z].</p> </li> <li> <code>timestamp</code>               (<code>int</code>)           \u2013            <p>Unix time stamp.</p> </li> <li> <code>twist</code>               (<code>Vector6 | None</code>)           \u2013            <p>Linear and angular velocities in the local coordinate system of the ego vehicle (in m/s for linear and rad/s for angular), in the order of (vx, vy, vz, yaw_rate, pitch_rate, roll_rate).</p> </li> <li> <code>acceleration</code>               (<code>Vector3 | None</code>)           \u2013            <p>Acceleration in the local coordinate system of the ego vehicle (in m/s2), in the order of (ax, ay, az).</p> </li> <li> <code>geocoordinate</code>               (<code>Vector3 | None</code>)           \u2013            <p>Coordinates in the WGS 84 reference ellipsoid (latitude, longitude, altitude) in degrees and meters.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/ego_pose.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.EGO_POSE)\nclass EgoPose(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `ego_pose.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        translation (Vector3): Coordinate system origin given as [x, y, z] in [m].\n        rotation (Quaternion): Coordinate system orientation given as quaternion [w, x, y, z].\n        timestamp (int): Unix time stamp.\n        twist (Vector6 | None): Linear and angular velocities in the local coordinate system of\n            the ego vehicle (in m/s for linear and rad/s for angular), in the order of\n            (vx, vy, vz, yaw_rate, pitch_rate, roll_rate).\n        acceleration (Vector3 | None): Acceleration in the local coordinate system of\n            the ego vehicle (in m/s2), in the order of (ax, ay, az).\n        geocoordinate (Vector3 | None): Coordinates in the WGS 84 reference ellipsoid\n            (latitude, longitude, altitude) in degrees and meters.\n    \"\"\"\n\n    translation: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    timestamp: int = field(validator=validators.instance_of(int))\n    twist: Vector6 | None = field(default=None, converter=converters.optional(Vector6))\n    acceleration: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n    geocoordinate: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Instance","title":"Instance","text":"<p>A dataclass to represent schema table of <code>instance.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>category_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the object category.</p> </li> <li> <code>instance_name</code>               (<code>str</code>)           \u2013            <p>Dataset name and instance ID defined in annotation tool.</p> </li> <li> <code>nbr_annotations</code>               (<code>int</code>)           \u2013            <p>Number of annotations of this instance.</p> </li> <li> <code>first_annotation_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the first annotation of this instance.</p> </li> <li> <code>last_annotation_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the last annotation of this instance.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/instance.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.INSTANCE)\nclass Instance(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `instance.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        category_token (str): Foreign key pointing to the object category.\n        instance_name (str): Dataset name and instance ID defined in annotation tool.\n        nbr_annotations (int): Number of annotations of this instance.\n        first_annotation_token (str): Foreign key pointing to the first annotation of this instance.\n        last_annotation_token (str): Foreign key pointing to the last annotation of this instance.\n    \"\"\"\n\n    category_token: str = field(validator=validators.instance_of(str))\n    instance_name: str = field(validator=validators.instance_of(str))\n    nbr_annotations: int = field(validator=validators.instance_of(int))\n    first_annotation_token: str = field(validator=validators.instance_of(str))\n    last_annotation_token: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Keypoint","title":"Keypoint","text":"<p>A dataclass to represent schema table of <code>keypoint.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the sample data, which must be a keyframe image.</p> </li> <li> <code>instance_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the instance.</p> </li> <li> <code>category_tokens</code>               (<code>list[str]</code>)           \u2013            <p>Foreign key pointing to keypoints categories.</p> </li> <li> <code>keypoints</code>               (<code>KeypointLike</code>)           \u2013            <p>Annotated keypoints. Given as a list of [x, y].</p> </li> <li> <code>num_keypoints</code>               (<code>int</code>)           \u2013            <p>The number of keypoints to be annotated.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/keypoint.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.KEYPOINT)\nclass Keypoint(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `keypoint.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_data_token (str): Foreign key pointing to the sample data, which must be a keyframe image.\n        instance_token (str): Foreign key pointing to the instance.\n        category_tokens (list[str]): Foreign key pointing to keypoints categories.\n        keypoints (KeypointLike): Annotated keypoints. Given as a list of [x, y].\n        num_keypoints (int): The number of keypoints to be annotated.\n    \"\"\"\n\n    sample_data_token: str = field(validator=validators.instance_of(str))\n    instance_token: str = field(validator=validators.instance_of(str))\n    category_tokens: list[str] = field(\n        validator=validators.deep_iterable(validators.instance_of(str))\n    )\n    keypoints: KeypointLike = field(converter=np.array)\n    num_keypoints: int = field(validator=validators.instance_of(int))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.LidarSeg","title":"LidarSeg","text":"<p>A dataclass to represent lidar point cloud segmentation data.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>The filename of the lidar point cloud segmentation data.</p> </li> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>The token of the sample data.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/lidarseg.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.LIDARSEG)\nclass LidarSeg(SchemaBase):\n    \"\"\"A dataclass to represent lidar point cloud segmentation data.\n\n    Attributes:\n        token (str): Unique record identifier.\n        filename (str): The filename of the lidar point cloud segmentation data.\n        sample_data_token (str): The token of the sample data.\n    \"\"\"\n\n    filename: str = field(validator=validators.instance_of(str))\n    sample_data_token: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Log","title":"Log","text":"<p>A dataclass to represent schema table of <code>log.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>logfile</code>               (<code>str</code>)           \u2013            <p>Log file name.</p> </li> <li> <code>vehicle</code>               (<code>str</code>)           \u2013            <p>Vehicle name.</p> </li> <li> <code>data_captured</code>               (<code>str</code>)           \u2013            <p>Date of the data was captured (YYYY-MM-DD-HH-mm-ss).</p> </li> <li> <code>location</code>               (<code>str</code>)           \u2013            <p>Area where log was captured.</p> </li> </ul>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Log--shortcuts","title":"Shortcuts:","text":"<pre><code>map_token (str): Foreign key pointing to the map record.\n    This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/log.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.LOG)\nclass Log(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `log.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        logfile (str): Log file name.\n        vehicle (str): Vehicle name.\n        data_captured (str): Date of the data was captured (YYYY-MM-DD-HH-mm-ss).\n        location (str): Area where log was captured.\n\n    Shortcuts:\n    ---------\n        map_token (str): Foreign key pointing to the map record.\n            This should be set after instantiated.\n    \"\"\"\n\n    logfile: str = field(validator=validators.instance_of(str))\n    vehicle: str = field(validator=validators.instance_of(str))\n    data_captured: str = field(validator=validators.instance_of(str))\n    location: str = field(validator=validators.instance_of(str))\n\n    # shortcuts\n    map_token: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Map","title":"Map","text":"<p>A dataclass to represent schema table of <code>map.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>log_tokens</code>               (<code>str</code>)           \u2013            <p>Foreign keys pointing the log tokens.</p> </li> <li> <code>category</code>               (<code>str</code>)           \u2013            <p>Map category.</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Relative path to the file with the map mask.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/map.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.MAP)\nclass Map(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `map.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        log_tokens (str): Foreign keys pointing the log tokens.\n        category (str): Map category.\n        filename (str): Relative path to the file with the map mask.\n    \"\"\"\n\n    log_tokens: list[str] = field(validator=validators.deep_iterable(validators.instance_of(str)))\n    category: str = field(validator=validators.instance_of(str))\n    filename: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.ObjectAnn","title":"ObjectAnn","text":"<p>A dataclass to represent schema table of <code>object_ann.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the sample data, which must be a keyframe image.</p> </li> <li> <code>instance_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the instance.</p> </li> <li> <code>category_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the object category.</p> </li> <li> <code>attribute_tokens</code>               (<code>list[str]</code>)           \u2013            <p>Foreign keys. List of attributes for this annotation.</p> </li> <li> <code>bbox</code>               (<code>Roi</code>)           \u2013            <p>Annotated bounding box. Given as [xmin, ymin, xmax, ymax].</p> </li> <li> <code>mask</code>               (<code>RLEMask</code>)           \u2013            <p>Instance mask using the COCO format compressed by RLE.</p> </li> <li> <code>orientation</code>               (<code>float | None</code>)           \u2013            <p>Orientation of the arrow shape within the bounding box, in radians. Present only for categories where <code>has_orientation</code> is true (e.g., traffic light arrows).</p> </li> <li> <code>number</code>               (<code>int | None</code>)           \u2013            <p>The digit displayed within the bounding box. Present only for categories where <code>has_number</code> is true (e.g., numeric traffic lights).</p> </li> </ul> Inherited from AutolabelMixin <p>automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.     If any part is manually modified or annotated by human this value is False. autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if <code>automatic_annotation</code> is <code>true</code>.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.ObjectAnn--shortcuts","title":"Shortcuts:","text":"<pre><code>category_name (str): Category name. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.OBJECT_ANN)\nclass ObjectAnn(SchemaBase, AutolabelMixin):\n    \"\"\"A dataclass to represent schema table of `object_ann.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_data_token (str): Foreign key pointing to the sample data, which must be a keyframe image.\n        instance_token (str): Foreign key pointing to the instance.\n        category_token (str): Foreign key pointing to the object category.\n        attribute_tokens (list[str]): Foreign keys. List of attributes for this annotation.\n        bbox (Roi): Annotated bounding box. Given as [xmin, ymin, xmax, ymax].\n        mask (RLEMask): Instance mask using the COCO format compressed by RLE.\n        orientation (float | None, optional): Orientation of the arrow shape within the bounding box, in radians. Present only for categories where `has_orientation` is true (e.g., traffic light arrows).\n        number (int | None, optional): The digit displayed within the bounding box. Present only for categories where `has_number` is true (e.g., numeric traffic lights).\n\n    Inherited from AutolabelMixin:\n        automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.\n            If any part is manually modified or annotated by human this value is False.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n\n    Shortcuts:\n    ---------\n        category_name (str): Category name. This should be set after instantiated.\n    \"\"\"\n\n    sample_data_token: str = field(validator=validators.instance_of(str))\n    instance_token: str = field(validator=validators.instance_of(str))\n    category_token: str = field(validator=validators.instance_of(str))\n    attribute_tokens: list[str] = field(\n        validator=validators.deep_iterable(validators.instance_of(str))\n    )\n    bbox: Roi = field(converter=Roi)\n    mask: RLEMask | None = field(\n        default=None,\n        converter=lambda x: RLEMask(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(RLEMask)),\n    )\n    orientation: float | None = field(\n        default=None, validator=validators.optional(validators.instance_of(float))\n    )\n    number: int | None = field(\n        default=None, validator=validators.optional(validators.instance_of(int))\n    )\n\n    # shortcuts\n    category_name: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sample","title":"Sample","text":"<p>A dataclass to represent schema table of <code>sample.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>timestamp</code>               (<code>int</code>)           \u2013            <p>Unix time stamp.</p> </li> <li> <code>scene_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the scene.</p> </li> <li> <code>next</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the sample that follows this in time. Empty if end of scene.</p> </li> <li> <code>prev</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the sample that precedes this in time. Empty if start of scene.</p> </li> </ul>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sample--shortcuts","title":"Shortcuts:","text":"<pre><code>data (dict[str, str]): Sensor channel and its token.\n    This should be set after instantiated.\nann_3ds (list[str]): List of foreign keys pointing the sample annotations.\n    This should be set after instantiated.\nann_2ds (list[str]): List of foreign keys pointing the object annotations.\n    This should be set after instantiated.\nsurface_anns (list[str]): List of foreign keys pointing the surface annotations.\n    This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sample.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SAMPLE)\nclass Sample(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `sample.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        timestamp (int): Unix time stamp.\n        scene_token (str): Foreign key pointing to the scene.\n        next (str): Foreign key pointing the sample that follows this in time. Empty if end of scene.\n        prev (str): Foreign key pointing the sample that precedes this in time. Empty if start of scene.\n\n    Shortcuts:\n    ---------\n        data (dict[str, str]): Sensor channel and its token.\n            This should be set after instantiated.\n        ann_3ds (list[str]): List of foreign keys pointing the sample annotations.\n            This should be set after instantiated.\n        ann_2ds (list[str]): List of foreign keys pointing the object annotations.\n            This should be set after instantiated.\n        surface_anns (list[str]): List of foreign keys pointing the surface annotations.\n            This should be set after instantiated.\n    \"\"\"\n\n    timestamp: int = field(validator=validators.instance_of(int))\n    scene_token: str = field(validator=validators.instance_of(str))\n    next: str = field(validator=validators.instance_of(str))  # noqa: A003\n    prev: str = field(validator=validators.instance_of(str))\n\n    # shortcuts\n    data: dict[str, str] = field(factory=dict, init=False)\n    ann_3ds: list[str] = field(factory=list, init=False)\n    ann_2ds: list[str] = field(factory=list, init=False)\n    surface_anns: list[str] = field(factory=list, init=False)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleAnnotation","title":"SampleAnnotation","text":"<p>A dataclass to represent schema table of <code>sample_annotation.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>sample_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the sample.</p> </li> <li> <code>instance_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the object instance.</p> </li> <li> <code>attribute_tokens</code>               (<code>list[str]</code>)           \u2013            <p>Foreign keys. List of attributes for this annotation.</p> </li> <li> <code>visibility_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the object visibility.</p> </li> <li> <code>translation</code>               (<code>Vector3</code>)           \u2013            <p>Bounding box location given as [x, y, z] in [m].</p> </li> <li> <code>size</code>               (<code>Vector3</code>)           \u2013            <p>Bounding box size given as [width, length, height] in [m].</p> </li> <li> <code>rotation</code>               (<code>Quaternion</code>)           \u2013            <p>Bounding box orientation given as quaternion [w, x, y, z].</p> </li> <li> <code>num_lidar_pts</code>               (<code>int</code>)           \u2013            <p>Number of lidar points in this box.</p> </li> <li> <code>num_radar_pts</code>               (<code>int</code>)           \u2013            <p>Number of radar points in this box.</p> </li> <li> <code>next</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the annotation that follows this in time. Empty if this is the last annotation for this object.</p> </li> <li> <code>prev</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the annotation that precedes this in time. Empty if this the first annotation for this object.</p> </li> <li> <code>velocity</code>               (<code>Vector3 | None</code>)           \u2013            <p>Bounding box velocity given as [vx, vy, vz] in [m/s].</p> </li> <li> <code>acceleration</code>               (<code>Vector3 | None</code>)           \u2013            <p>Bonding box acceleration given as [ax, ay, av] in [m/s^2].</p> </li> </ul> Inherited from AutolabelMixin <p>automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.     If any part is manually modified or annotated by human this value is False. autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if <code>automatic_annotation</code> is <code>true</code>.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleAnnotation--shortcuts","title":"Shortcuts:","text":"<pre><code>category_name (str): Category name. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sample_annotation.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SAMPLE_ANNOTATION)\nclass SampleAnnotation(SchemaBase, AutolabelMixin):\n    \"\"\"A dataclass to represent schema table of `sample_annotation.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_token (str): Foreign key pointing the sample.\n        instance_token (str): Foreign key pointing the object instance.\n        attribute_tokens (list[str]): Foreign keys. List of attributes for this annotation.\n        visibility_token (str): Foreign key pointing the object visibility.\n        translation (Vector3): Bounding box location given as [x, y, z] in [m].\n        size (Vector3): Bounding box size given as [width, length, height] in [m].\n        rotation (Quaternion): Bounding box orientation given as quaternion [w, x, y, z].\n        num_lidar_pts (int): Number of lidar points in this box.\n        num_radar_pts (int): Number of radar points in this box.\n        next (str): Foreign key pointing the annotation that follows this in time.\n            Empty if this is the last annotation for this object.\n        prev (str): Foreign key pointing the annotation that precedes this in time.\n            Empty if this the first annotation for this object.\n        velocity (Vector3 | None, optional): Bounding box velocity given as\n            [vx, vy, vz] in [m/s].\n        acceleration (Vector3 | None, optional): Bonding box acceleration\n            given as [ax, ay, av] in [m/s^2].\n\n    Inherited from AutolabelMixin:\n        automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.\n            If any part is manually modified or annotated by human this value is False.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n\n    Shortcuts:\n    ---------\n        category_name (str): Category name. This should be set after instantiated.\n    \"\"\"\n\n    sample_token: str = field(validator=validators.instance_of(str))\n    instance_token: str = field(validator=validators.instance_of(str))\n    attribute_tokens: list[str] = field(\n        validator=validators.deep_iterable(validators.instance_of(str))\n    )\n    visibility_token: str = field(validator=validators.instance_of(str))\n    translation: Vector3 = field(converter=Vector3)\n    size: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    num_lidar_pts: int = field(validator=validators.instance_of(int))\n    num_radar_pts: int = field(validator=validators.instance_of(int))\n    next: str = field(validator=validators.instance_of(str))  # noqa: A003\n    prev: str = field(validator=validators.instance_of(str))\n    velocity: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n    acceleration: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n\n    # shortcuts\n    category_name: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleData","title":"SampleData","text":"<p>A class to represent schema table of <code>sample_data.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>sample_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the sample.</p> </li> <li> <code>ego_pose_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the ego_pose.</p> </li> <li> <code>calibrated_sensor_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the calibrated_sensor.</p> </li> <li> <code>filename</code>               (<code>str</code>)           \u2013            <p>Relative path to data-blob on disk.</p> </li> <li> <code>fileformat</code>               (<code>FileFormat</code>)           \u2013            <p>Data file format.</p> </li> <li> <code>width</code>               (<code>int</code>)           \u2013            <p>If the sample data is an image, this is the image width in [px].</p> </li> <li> <code>height</code>               (<code>int</code>)           \u2013            <p>If the sample data is an image, this is the image height in [px].</p> </li> <li> <code>timestamp</code>               (<code>int</code>)           \u2013            <p>Unix time stamp.</p> </li> <li> <code>is_key_frame</code>               (<code>bool</code>)           \u2013            <p>True if sample_data is part of key frame else, False.</p> </li> <li> <code>next</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the sample_data that follows this in time. Empty if end of scene.</p> </li> <li> <code>prev</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing the sample_data that precedes this in time. Empty if start of scene.</p> </li> <li> <code>is_valid</code>               (<code>bool</code>)           \u2013            <p>True if this data is valid, else False. Invalid data should be ignored.</p> </li> <li> <code>info_filename</code>               (<code>str</code>)           \u2013            <p>Relative path to metainfo data-blob on disk.</p> </li> <li> <code>autolabel_metadata</code>               (<code>list[AutolabelModel] | None</code>)           \u2013            <p>List of models used for autolabeling applied to this entire sample_data item (e.g., image or scan).</p> </li> </ul>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleData--shortcuts","title":"Shortcuts:","text":"<pre><code>modality (SensorModality): Sensor modality. This should be set after instantiated.\nchannel (str): Sensor channel. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SAMPLE_DATA)\nclass SampleData(SchemaBase):\n    \"\"\"A class to represent schema table of `sample_data.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_token (str): Foreign key pointing the sample.\n        ego_pose_token (str): Foreign key pointing the ego_pose.\n        calibrated_sensor_token (str): Foreign key pointing the calibrated_sensor.\n        filename (str): Relative path to data-blob on disk.\n        fileformat (FileFormat): Data file format.\n        width (int): If the sample data is an image, this is the image width in [px].\n        height (int): If the sample data is an image, this is the image height in [px].\n        timestamp (int): Unix time stamp.\n        is_key_frame (bool): True if sample_data is part of key frame else, False.\n        next (str): Foreign key pointing the sample_data that follows this in time.\n            Empty if end of scene.\n        prev (str): Foreign key pointing the sample_data that precedes this in time.\n            Empty if start of scene.\n        is_valid (bool): True if this data is valid, else False. Invalid data should be ignored.\n        info_filename (str): Relative path to metainfo data-blob on disk.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling applied to this entire sample_data item (e.g., image or scan).\n\n    Shortcuts:\n    ---------\n        modality (SensorModality): Sensor modality. This should be set after instantiated.\n        channel (str): Sensor channel. This should be set after instantiated.\n    \"\"\"\n\n    sample_token: str = field(validator=validators.instance_of(str))\n    ego_pose_token: str = field(validator=validators.instance_of(str))\n    calibrated_sensor_token: str = field(validator=validators.instance_of(str))\n    filename: str = field(validator=validators.instance_of(str))\n    fileformat: FileFormat = field(converter=FileFormat)\n    width: int = field(validator=validators.instance_of(int))\n    height: int = field(validator=validators.instance_of(int))\n    timestamp: int = field(validator=validators.instance_of(int))\n    is_key_frame: bool = field(validator=validators.instance_of(bool))\n    next: str = field(validator=validators.instance_of(str))  # noqa: A003\n    prev: str = field(validator=validators.instance_of(str))\n    is_valid: bool = field(default=True, validator=validators.instance_of(bool))\n    info_filename: str | None = field(\n        default=None, validator=validators.optional(validators.instance_of(str))\n    )\n    autolabel_metadata: list[AutolabelModel] | None = field(\n        default=None,\n        converter=AutolabelModel.to_autolabel_model,\n        validator=validators.optional(\n            validators.deep_iterable(validators.instance_of(AutolabelModel))\n        ),\n    )\n\n    # shortcuts\n    modality: SensorModality | None = field(init=False, default=None)\n    channel: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Scene","title":"Scene","text":"<p>A dataclass to represent schema table of <code>scene.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>name</code>               (<code>str</code>)           \u2013            <p>Short string identifier.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>Longer description for the scene.</p> </li> <li> <code>log_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to log from where the data was extracted.</p> </li> <li> <code>nbr_samples</code>               (<code>int</code>)           \u2013            <p>Number of samples in the scene.</p> </li> <li> <code>first_sample_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the first sample in scene.</p> </li> <li> <code>last_sample_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the last sample in scene.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/scene.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SCENE)\nclass Scene(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `scene.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        name (str): Short string identifier.\n        description (str): Longer description for the scene.\n        log_token (str): Foreign key pointing to log from where the data was extracted.\n        nbr_samples (int): Number of samples in the scene.\n        first_sample_token (str): Foreign key pointing to the first sample in scene.\n        last_sample_token (str): Foreign key pointing to the last sample in scene.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    description: str = field(validator=validators.instance_of(str))\n    log_token: str = field(validator=validators.instance_of(str))\n    nbr_samples: int = field(validator=validators.instance_of(int))\n    first_sample_token: str = field(validator=validators.instance_of(str))\n    last_sample_token: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sensor","title":"Sensor","text":"<p>A dataclass to represent schema table of <code>sensor.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>channel</code>               (<code>str</code>)           \u2013            <p>Sensor channel name.</p> </li> <li> <code>modality</code>               (<code>SensorModality</code>)           \u2013            <p>Sensor modality.</p> </li> </ul>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sensor--shortcuts","title":"Shortcuts:","text":"<pre><code>first_sd_token (str): The first sample data token corresponding to its sensor channel.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sensor.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SENSOR)\nclass Sensor(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `sensor.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        channel (str): Sensor channel name.\n        modality (SensorModality): Sensor modality.\n\n    Shortcuts:\n    ---------\n        first_sd_token (str): The first sample data token corresponding to its sensor channel.\n    \"\"\"\n\n    channel: str = field(validator=validators.instance_of(str))\n    modality: SensorModality = field(converter=SensorModality)\n\n    # shortcuts\n    first_sd_token: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SurfaceAnn","title":"SurfaceAnn","text":"<p>A dataclass to represent schema table of <code>surface_ann.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>sample_data_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the sample data, which must be a keyframe image.</p> </li> <li> <code>category_token</code>               (<code>str</code>)           \u2013            <p>Foreign key pointing to the surface category.</p> </li> <li> <code>mask</code>               (<code>RLEMask</code>)           \u2013            <p>Segmentation mask using the COCO format compressed by RLE.</p> </li> </ul> Inherited from AutolabelMixin <p>automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.     If any part is manually modified or annotated by human this value is False. autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if <code>automatic_annotation</code> is <code>true</code>.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SurfaceAnn--shortcuts","title":"Shortcuts:","text":"<pre><code>category_name (str): Category name. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/surface_ann.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SURFACE_ANN)\nclass SurfaceAnn(SchemaBase, AutolabelMixin):\n    \"\"\"A dataclass to represent schema table of `surface_ann.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_data_token (str): Foreign key pointing to the sample data, which must be a keyframe image.\n        category_token (str): Foreign key pointing to the surface category.\n        mask (RLEMask): Segmentation mask using the COCO format compressed by RLE.\n\n    Inherited from AutolabelMixin:\n        automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.\n            If any part is manually modified or annotated by human this value is False.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n\n    Shortcuts:\n    ---------\n        category_name (str): Category name. This should be set after instantiated.\n    \"\"\"\n\n    sample_data_token: str = field(validator=validators.instance_of(str))\n    category_token: str = field(validator=validators.instance_of(str))\n    mask: RLEMask | None = field(\n        default=None,\n        converter=lambda x: RLEMask(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(RLEMask)),\n    )\n\n    # shortcuts\n    category_name: str = field(init=False, factory=str)\n\n    @property\n    def bbox(self) -&gt; Roi | None:\n        \"\"\"Return a bounding box corners calculated from polygon vertices.\n\n        Returns:\n            Roi instance given as [xmin, ymin, xmax, ymax].\n        \"\"\"\n        if self.mask is None:\n            return None\n\n        mask = self.mask.decode()\n        indices = np.where(mask == 1)\n        xmin, ymin = np.min(indices, axis=1)\n        xmax, ymax = np.max(indices, axis=1)\n        return Roi(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SurfaceAnn.bbox","title":"bbox  <code>property</code>","text":"<pre><code>bbox\n</code></pre> <p>Return a bounding box corners calculated from polygon vertices.</p> <p>Returns:</p> <ul> <li> <code>Roi | None</code>           \u2013            <p>Roi instance given as [xmin, ymin, xmax, ymax].</p> </li> </ul>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.VehicleState","title":"VehicleState","text":"<p>A dataclass to represent schema table of <code>vehicle_state.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>timestamp</code>               (<code>int</code>)           \u2013            <p>Unix time stamp.</p> </li> <li> <code>accel_pedal</code>               (<code>float | None</code>)           \u2013            <p>Accel pedal position [%].</p> </li> <li> <code>brake_pedal</code>               (<code>float | None</code>)           \u2013            <p>Brake pedal position [%].</p> </li> <li> <code>steer_pedal</code>               (<code>float | None</code>)           \u2013            <p>Steering wheel position [%].</p> </li> <li> <code>steering_tire_angle</code>               (<code>float | None</code>)           \u2013            <p>Steering tire angle [rad].</p> </li> <li> <code>steering_wheel_angle</code>               (<code>float | None</code>)           \u2013            <p>Steering wheel angle [rad].</p> </li> <li> <code>shift_state</code>               (<code>ShiftState | None</code>)           \u2013            <p>Gear shift state.</p> </li> <li> <code>indicators</code>               (<code>Indicators | None</code>)           \u2013            <p>State of each indicator.</p> </li> <li> <code>additional_info</code>               (<code>AdditionalInfo | None</code>)           \u2013            <p>Additional state information.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.VEHICLE_STATE)\nclass VehicleState(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `vehicle_state.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        timestamp (int): Unix time stamp.\n        accel_pedal (float | None): Accel pedal position [%].\n        brake_pedal (float | None): Brake pedal position [%].\n        steer_pedal (float | None): Steering wheel position [%].\n        steering_tire_angle (float | None): Steering tire angle [rad].\n        steering_wheel_angle (float | None): Steering wheel angle [rad].\n        shift_state (ShiftState | None): Gear shift state.\n        indicators (Indicators | None): State of each indicator.\n        additional_info (AdditionalInfo | None): Additional state information.\n    \"\"\"\n\n    timestamp: int = field(validator=validators.instance_of(int))\n    accel_pedal: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    brake_pedal: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    steer_pedal: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    steering_tire_angle: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    steering_wheel_angle: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    shift_state: ShiftState | None = field(\n        default=None,\n        converter=converters.optional(ShiftState),\n        validator=validators.optional(validators.instance_of(ShiftState)),\n    )\n    indicators: Indicators | None = field(\n        default=None,\n        converter=lambda x: Indicators(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(Indicators)),\n    )\n    additional_info: AdditionalInfo | None = field(\n        default=None,\n        converter=lambda x: AdditionalInfo(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(AdditionalInfo)),\n    )\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Visibility","title":"Visibility","text":"<p>A dataclass to represent schema table of <code>visibility.json</code>.</p> <p>Attributes:</p> <ul> <li> <code>token</code>               (<code>str</code>)           \u2013            <p>Unique record identifier.</p> </li> <li> <code>level</code>               (<code>VisibilityLevel</code>)           \u2013            <p>Visibility level.</p> </li> <li> <code>description</code>               (<code>str</code>)           \u2013            <p>Description of visibility level.</p> </li> </ul> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.VISIBILITY)\nclass Visibility(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `visibility.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        level (VisibilityLevel): Visibility level.\n        description (str): Description of visibility level.\n    \"\"\"\n\n    level: VisibilityLevel = field(\n        converter=lambda x: VisibilityLevel.from_value(x)\n        if not isinstance(x, VisibilityLevel)\n        else VisibilityLevel(x)\n    )\n    description: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"cli/","title":"CLI Support","text":"<p>Following command line tools are supported:</p> <ul> <li><code>t4viz</code>: Visualize T4 dataset features</li> <li><code>t4sanity</code>: Sanity checker of T4 dataset</li> </ul>"},{"location":"cli/t4sanity/","title":"t4sanity","text":"<p><code>t4sanity</code> performs sanity checks on T4 datasets, reporting any issues regarding the dataset requirements.</p> <pre><code>$ t4sanity -h\n\n Usage: t4sanity [OPTIONS] DB_PARENT\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    data_root      TEXT  Path to root directory of a dataset. [default: None] [required]                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --version             -v             Show the application version and exit.                                           \u2502\n\u2502 --output              -o       TEXT  Path to output JSON file. [default: None]                                        \u2502\n\u2502 --revision            -rv      TEXT  Specify if you want to check the specific version. [default: None]               \u2502\n\u2502 --exclude             -e       TEXT  Exclude specific rules or rule groups. [default: None]                           \u2502\n\u2502 --strict              -s             Indicates whether warnings are treated as failures.                              \u2502\n\u2502 --install-completion                 Install completion for the current shell.                                        \u2502\n\u2502 --show-completion                    Show completion for the current shell, to copy it or customize the installation. \u2502\n\u2502 --help                -h             Show this message and exit.                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/t4sanity/#shell-completion","title":"Shell Completion","text":"<p>Run the following command to install completion, and reload shell.</p> <pre><code>t4sanity --install-completion\n</code></pre>"},{"location":"cli/t4sanity/#usages","title":"Usages","text":"<p>As an example, we have the following the dataset structure:</p> <pre><code>&lt;DATA_ROOT; (DATASET ID)&gt;\n\u251c\u2500\u2500 &lt;VERSION&gt;\n\u2502    \u251c\u2500\u2500 annotation\n\u2502    \u251c\u2500\u2500 data\n|    ...\n</code></pre> <p>Then, you can run sanity checks with <code>t4sanity &lt;DATA_ROOT&gt;</code>:</p> <pre><code>$ t4sanity &lt;DATA_ROOT&gt;\n\n&gt;&gt;&gt;Sanity checking...: 1it [00:00,  9.70it/s]\n\n=== DatasetID: dataset1 ===\n  STR001: \u2705\n  STR002: \u2705\n  STR003: \u2705\n  STR004: \u2705\n  STR005: \u2705\n  STR006: \u2705\n  STR007: \u2705\n  STR008: \u2705\n  ...\n\n+-----------+---------+--------+--------+---------+----------+\n| DatasetID | Version | Passed | Failed | Skipped | Warnings |\n+-----------+---------+--------+--------+---------+----------+\n| dataset1  |    0    |   49   |   0    |    2    |    3     |\n+-----------+---------+--------+--------+---------+----------+\n</code></pre>"},{"location":"cli/t4sanity/#strict-mode","title":"Strict Mode","text":"<p>Basically, rules whose severity is WARNING will be treated as success.</p> <p>With <code>-s; --strict</code> option enables us to treat warnings as failures:</p> <pre><code># Run strict mode\nt4sanity &lt;DATA_ROOT&gt; -s\n</code></pre>"},{"location":"cli/t4sanity/#exclude-checks","title":"Exclude Checks","text":"<p>With <code>-e; --excludes</code> option enables us to exclude specific checks by specifying the rule IDs or groups:</p> <pre><code># Exclude STR001 and all FMT-relevant rules\nt4sanity &lt;DATA_ROOT&gt; -e STR001 -e FMT\n</code></pre>"},{"location":"cli/t4sanity/#exit-status-logic","title":"Exit Status Logic","text":"<p><code>t4sanity</code> CLI returns the exit code based on the following conditions:</p> Condition <code>--strict</code> Exit Code Notes At least one <code>Severity.ERROR</code> rule failed N/A 1 Always fails the run At least one <code>Severity.WARNING</code> rule failed, no <code>Severity.ERROR</code> failed <code>False</code> (default) 0 Run is considered successful, warnings are reported At least one <code>Severity.WARNING</code> rule failed, no <code>Severity.ERROR</code> failed <code>True</code> 1 Treat warnings as failures; exit with failure All rules passed or skipped N/A 0 Run is considered successful"},{"location":"cli/t4sanity/#dump-results-as-json","title":"Dump Results as JSON","text":"<p>To dump results into JSON, use the <code>-o; --output</code> option:</p> <pre><code>t4sanity &lt;DATA_ROOT&gt; -o result.json\n</code></pre> <p>Then a JSON file named <code>result.json</code> will be generated as follows:</p> <pre><code>{\n  \"dataset_id\": \"&lt;DatasetID: str&gt;\",\n  \"version\": &lt;Version: int&gt;,\n  \"reports\": [\n    {\n        \"id\": \"&lt;RuleID: str&gt;\",\n        \"name\": \"&lt;RuleName: str&gt;\",\n        \"severity\": \"&lt;WARNING/ERROR: str&gt;\",\n        \"description\": \"&lt;Description: str&gt;\",\n        \"status\": \"&lt;PASSED/FAILED/SKIPPED: str&gt;\",\n        \"reasons\": \"&lt;[&lt;Reason1&gt;, &lt;Reason2&gt;, ...]: [str; N] | null&gt;\" // Failed or skipped reasons, null if passed\n    },\n  ]\n}\n</code></pre> <p>Here is the description of the JSON format:</p> <ul> <li><code>dataset_id</code>: The ID of the dataset.</li> <li><code>version</code>: The version of the dataset.</li> <li><code>reports</code>: An array of rule reports.</li> <li><code>id</code>: The ID of the rule.</li> <li><code>name</code>: The name of the rule.</li> <li><code>severity</code>: How important a rule is.</li> <li><code>description</code>: A description of the rule.</li> <li><code>status</code>: What happened when it ran.</li> <li><code>reasons</code>: An array of reasons for failure or skipped rules, null if passed.</li> </ul>"},{"location":"cli/t4viz/","title":"t4viz","text":"<p><code>t4viz</code> performs visualizing particular dataset attributes from command line.</p> <pre><code>$ t4viz -h\n\n Usage: t4viz [OPTIONS] COMMAND [ARGS]...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --version             -v        Show the application version and exit.                                           \u2502\n\u2502 --install-completion            Install completion for the current shell.                                        \u2502\n\u2502 --show-completion               Show completion for the current shell, to copy it or customize the installation. \u2502\n\u2502 --help                -h        Show this message and exit.                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 scene        Visualize a specific scene.                                                                         \u2502\n\u2502 instance     Visualize a particular instance in the corresponding scene.                                         \u2502\n\u2502 pointcloud   Visualize pointcloud in the corresponding scene.                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/t4viz/#shell-completion","title":"Shell Completion","text":"<p>Run the following command to install completion, and reload shell.</p> <pre><code>t4viz --install-completion\n</code></pre>"},{"location":"cli/t4viz/#usages","title":"Usages","text":""},{"location":"cli/t4viz/#scene","title":"Scene","text":"<p>This command performs the same behavior with <code>Tier4.render_scene(...)</code>.</p> <p>For options, run <code>t4viz scene -h</code>.</p> <pre><code>t4viz scene &lt;DATA_ROOT&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/t4viz/#specific-instances","title":"Specific Instance(s)","text":"<p>This command performs the same behavior with <code>Tier4.render_instance(...)</code>.</p> <p>For options, run <code>t4viz instance -h</code>.</p> <pre><code>t4viz instance &lt;DATA_ROOT&gt; &lt;INSTANCE_TOKEN&gt; [OPTIONS]\n</code></pre> <p>You can also specify multiple instance tokens:</p> <pre><code>t4viz instance &lt;DATA_ROOT&gt; &lt;INSTANCE_TOKEN1&gt; &lt;INSTANCE_TOKEN2&gt; ... [OPTIONS]\n</code></pre>"},{"location":"cli/t4viz/#pointcloud","title":"PointCloud","text":"<p>This command performs the same behavior with <code>Tier4.render_pointcloud(...)</code>.</p> <p>For options, run <code>t4viz pointcloud -h</code>.</p> <pre><code>t4viz pointcloud &lt;DATA_ROOT&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/t4viz/#future-trajectories","title":"Future Trajectories","text":"<p><code>scene</code> and <code>instance</code> commands support visualizing future trajectories for each object.</p> <p>By specifying <code>-f [--future]</code> option, you can render them in the particular time length:</p> <pre><code>t4viz &lt;COMMAND&gt; ... -f &lt;FUTURE_LENGTH[s]&gt;\n</code></pre>"},{"location":"cli/t4viz/#save-recording-as-rrd","title":"Save Recording as <code>.rrd</code>","text":"<p>You can save visualized recording with <code>-o [--output]</code> option as follows:</p> <pre><code>t4viz &lt;COMMAND&gt; ... -o &lt;OUTPUT_DIR&gt;\n</code></pre> <p>Note that if you specify <code>--output</code> option, viewer will not be spawned.</p>"},{"location":"schema/","title":"Dataset Schema","text":""},{"location":"schema/#directory-structure","title":"Directory Structure","text":"<pre><code>&lt;DATASET_ID&gt;/\n\u2514\u2500\u2500 &lt;DATASET_VERSION&gt;\n    \u251c\u2500\u2500 annotation    ...schema tables in JSON format\n    \u251c\u2500\u2500 data          ...sensor raw data\n    \u251c\u2500\u2500 input_bag     ...original ROS bag file\n    \u251c\u2500\u2500 map           ...map files\n    \u2514\u2500\u2500 status.json   ...dataset status information\n</code></pre>"},{"location":"schema/#schema-tables","title":"Schema Tables","text":"<p>Annotation information is stored in the <code>annotation</code> directory.</p> <p>See the document of dataset schema for details.</p>"},{"location":"schema/#sensor-data","title":"Sensor Data","text":"<p>Raw sensor data is stored in the <code>data</code> directory.</p> <p>See the document of sensor data for details.</p>"},{"location":"schema/#map-data","title":"Map Data","text":"<p>Map data is stored in the <code>map</code> directory.</p> <p>It is structured as follows:</p> <pre><code>map/\n\u251c\u2500\u2500 lanelet2_map.osm\n\u2514\u2500\u2500 pointcloud_map.pcd\n</code></pre>"},{"location":"schema/#statusjson","title":"status.json","text":"<p><code>status.json</code> contains the information about the configuration used to generate the dataset.</p>"},{"location":"schema/data/","title":"Sensor Data","text":""},{"location":"schema/data/#lidar-point-cloud","title":"LiDAR Point Cloud","text":"<p>LiDAR directory contains point cloud data as the name of <code>&lt;LIDAR_CONCAT&gt;</code> or <code>&lt;LIDAR_TOP&gt;</code>:</p> <pre><code>data/\n\u2514\u2500\u2500 LIDAR_CONCAT\n    \u251c\u2500\u2500 &lt;FRAME_ID&gt;.pcd.bin\n    ...\n</code></pre> <p>Each file contains <code>(x, y, z, intensity, ring_idx(=-1))</code>, and location coordinates are given with respect to the ego vehicle coordinate system.</p> <p>Each file can be loaded using as follows:</p> <pre><code># Using NumPy\nimport numpy as np\n\ndef load_lidar_point_cloud(file_path) -&gt; np.ndarray:\n    data = np.fromfile(file_path, dtype=np.float32) # (N*5,)\n    return data.reshape((-1, 5)) # (N, 5)\n\n# Using t4-devkit\nfrom t4_devkit.dataclass import LidarPointCloud\n\ndef load_lidar_point_cloud_t4(file_path) -&gt; LidarPointCloud:\n    return LidarPointCloud.from_file(file_path)\n</code></pre>"},{"location":"schema/data/#camera-image","title":"Camera Image","text":"<p>Camera directory contains raw images as the name of <code>&lt;CAM_XXX&gt;</code>:</p> <pre><code>data/\n\u251c\u2500\u2500 CAM_BACK\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 &lt;FRAME_ID&gt;.jpg\n\u2502\u00a0\u00a0 ...\n\u251c\u2500\u2500 CAM_BACK_LEFT\n\u251c\u2500\u2500 CAM_BACK_RIGHT\n\u251c\u2500\u2500 CAM_FRONT\n...\n</code></pre>"},{"location":"schema/data/#radar-object","title":"Radar Object","text":"<p>Radar directory contains radar object tracks</p> <pre><code>data/\n\u251c\u2500\u2500 RADAR_BACK\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 &lt;FRAME_ID&gt;.pcd\n\u2502\u00a0\u00a0 ...\n\u251c\u2500\u2500 RADAR_BACK_LEFT\n\u251c\u2500\u2500 RADAR_BACK_RIGHT\n\u251c\u2500\u2500 RADAR_FRONT\n...\n</code></pre> <p>Each file is based on NuScenes radar data format as follows:</p> <pre><code># .PCD v0.7 - Point Cloud Data file format\nVERSION 0.7\nFIELDS x y z dyn_prop id rcs vx vy vx_comp vy_comp is_quality_valid ambig_state x_rms y_rms invalid_state pdh0 vx_rms vy_rms\nSIZE 4 4 4 1 2 4 4 4 4 4 1 1 1 1 1 1 1 1\nTYPE F F F I I F F F F F I I I I I I I I\nCOUNT 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\nWIDTH 112\nHEIGHT 1\nVIEWPOINT 0 0 0 1 0 0 0\nPOINTS 112\nDATA binary\n</code></pre> <pre><code>from t4_devkit.dataclass import RadarPointCloud\n\ndef load_radar_point_cloud(file_path) -&gt; RadarPointCloud:\n    return RadarPointCloud.from_file(file_path)\n</code></pre>"},{"location":"schema/requirement/","title":"Dataset Requirements","text":""},{"location":"schema/requirement/#structure-str","title":"Structure (<code>STR</code>)","text":"ID Name Severity Description <code>STR001</code> <code>version-dir-presence</code> <code>WARNING</code> <code>version/</code> directory exists under the dataset root directory. <code>STR002</code> <code>annotation-dir-presence</code> <code>ERROR</code> <code>annotation/</code> directory exists under the dataset root directory. <code>STR003</code> <code>data-dir-presence</code> <code>ERROR</code> <code>data/</code> directory exists under the dataset root directory. <code>STR004</code> <code>map-dir-presence</code> <code>WARNING</code> <code>map/</code> directory exists under the dataset root directory. <code>STR005</code> <code>bag-dir-presence</code> <code>WARNING</code> <code>input_bag/</code> directory exists under the dataset root directory. <code>STR006</code> <code>status-file-presence</code> <code>WARNING</code> <code>status.json</code> file exists under the dataset root directory. <code>STR007</code> <code>schema-files-presence</code> <code>ERROR</code> Mandatory schema JSON files exist under the <code>annotation/</code> directory. <code>STR008</code> <code>lanelet-file-presence</code> <code>WARNING</code> <code>lanelet2_map.osm</code> file exists under the <code>map/</code> directory. <code>STR009</code> <code>pointcloud-map-dir-presence</code> <code>WARNING</code> <code>pointcloud_map.pcd</code> directory exists under the <code>map/</code> directory."},{"location":"schema/requirement/#schema-record-rec","title":"Schema Record (<code>REC</code>)","text":"ID Name Severity Description <code>REC001</code> <code>scene-single</code> <code>ERROR</code> <code>Scene</code> record is a single. <code>REC002</code> <code>sample-not-empty</code> <code>ERROR</code> <code>Sample</code> record is not empty. <code>REC003</code> <code>sample-data-not-empty</code> <code>ERROR</code> <code>SampleData</code> record is not empty. <code>REC004</code> <code>ego-pose-not-empty</code> <code>ERROR</code> <code>EgoPose</code> record is not empty. <code>REC005</code> <code>calibrated-sensor-non-empty</code> <code>ERROR</code> <code>CalibratedSensor</code> record is not empty. <code>REC006</code> <code>instance-not-empty</code> <code>ERROR</code> <code>Instance</code> record is not empty."},{"location":"schema/requirement/#reference-ref","title":"Reference (<code>REF</code>)","text":"ID Name Severity Description <code>REF001</code> <code>scene-to-log</code> <code>ERROR</code> <code>Scene.log_token</code> refers to <code>Log</code> record. <code>REF002</code> <code>scene-to-first-sample</code> <code>ERROR</code> <code>Scene.first_sample_token</code> refers to <code>Sample</code> record. <code>REF003</code> <code>scene-to-last-sample</code> <code>ERROR</code> <code>Scene.last_sample_token</code> refers to <code>Sample</code> record. <code>REF004</code> <code>sample-to-scene</code> <code>ERROR</code> <code>Sample.scene_token</code> refers to <code>Scene</code> record. <code>REF005</code> <code>sample-data-to-sample</code> <code>ERROR</code> <code>SampleData.sample_token</code> refers to <code>Sample</code> record. <code>REF006</code> <code>sample-data-to-ego-pose</code> <code>ERROR</code> <code>SampleData.ego_pose_token</code> refers to <code>EgoPose</code> record. <code>REF007</code> <code>sample-data-to-calibrated-sensor</code> <code>ERROR</code> <code>SampleData.calibrated_sensor_token</code> refers to <code>CalibratedSensor</code> record. <code>REF008</code> <code>calibrated-sensor-to-sensor</code> <code>ERROR</code> <code>CalibratedSensor.sensor_token</code> refers to <code>Sensor</code> record. <code>REF009</code> <code>instance-to-category</code> <code>ERROR</code> <code>Instance.category_token</code> refers to <code>Category</code> record. <code>REF010</code> <code>instance-to-first-sample-annotation</code> <code>ERROR</code> <code>Instance.first_annotation_token</code> refers to <code>SampleAnnotation</code> record. <code>REF011</code> <code>instance-to-last-sample-annotation</code> <code>ERROR</code> <code>Instance.last_annotation_token</code> refers to <code>SampleAnnotation</code> record. <code>REF012</code> <code>lidarseg-to-sample-data</code> <code>ERROR</code> <code>LidarSeg.sample_data_token</code> refers to <code>SampleData</code> record. <code>REF013</code> <code>sample-data-filename-presence</code> <code>ERROR</code> <code>SampleData.filename</code> exists. <code>REF014</code> <code>sample-data-info-filename-presence</code> <code>ERROR</code> <code>SampleData.info_filename</code> exists if it is not <code>None</code>. <code>REF015</code> <code>lidarseg-filename-presence</code> <code>ERROR</code> <code>LidarSeg.filename</code> exists if <code>lidarseg.json</code> exists."},{"location":"schema/requirement/#format-fmt","title":"Format (<code>FMT</code>)","text":"ID Name Severity Description <code>FMT001</code> <code>attribute-field</code> <code>ERROR</code> All types of <code>Attribute</code> fields are valid. <code>FMT002</code> <code>calibrated-sensor-field</code> <code>ERROR</code> All types of <code>CalibratedSensor</code> fields are valid. <code>FMT003</code> <code>category-field</code> <code>ERROR</code> All types of <code>Category</code> fields are valid. <code>FMT004</code> <code>ego-pose-field</code> <code>ERROR</code> All types of <code>EgoPose</code> fields are valid. <code>FMT005</code> <code>instance-field</code> <code>ERROR</code> All types of <code>Instance</code> fields are valid. <code>FMT006</code> <code>log-field</code> <code>ERROR</code> All types of <code>Log</code> fields are valid. <code>FMT007</code> <code>map-field</code> <code>ERROR</code> All types of <code>Map</code> fields are valid. <code>FMT008</code> <code>sample-field</code> <code>ERROR</code> All types of <code>Sample</code> fields are valid. <code>FMT009</code> <code>sample-annotation-field</code> <code>ERROR</code> All types of <code>SampleAnnotation</code> fields are valid. <code>FMT010</code> <code>sample-data-field</code> <code>ERROR</code> All types of <code>SampleData</code> fields are valid. <code>FMT011</code> <code>scene-field</code> <code>ERROR</code> All types of <code>Scene</code> fields are valid. <code>FMT012</code> <code>sensor-field</code> <code>ERROR</code> All types of <code>Sensor</code> fields are valid. <code>FMT013</code> <code>visibility-field</code> <code>ERROR</code> All types of <code>Visibility</code> fields are valid. <code>FMT014</code> <code>lidarseg-field</code> <code>ERROR</code> All types of <code>Lidarseg</code> fields are valid. <code>FMT015</code> <code>object-ann-field</code> <code>ERROR</code> All types of <code>ObjectAnn</code> fields are valid. <code>FMT016</code> <code>surface-ann-field</code> <code>ERROR</code> All types of <code>SurfaceAnn</code> fields are valid. <code>FMT017</code> <code>keypoint-field</code> <code>ERROR</code> All types of <code>Keypoint</code> fields are valid. <code>FMT018</code> <code>vehicle-state-field</code> <code>ERROR</code> All types of <code>VehicleState</code> fields are valid."},{"location":"schema/requirement/#tier4-instance-tiv","title":"Tier4 Instance (<code>TIV</code>)","text":"ID Name Severity Description <code>TIV001</code> <code>load-tier4</code> <code>ERROR</code> Ensure <code>Tier4</code> instance is loaded successfully."},{"location":"schema/table/","title":"Schema Tables","text":""},{"location":"schema/table/#type-definition","title":"Type Definition","text":""},{"location":"schema/table/#primitive-types","title":"Primitive Types","text":"Expression Description <code>str</code> String <code>int</code> Integer <code>float</code> Floating point number <code>bool</code> Boolean <code>enum[X,Y,...]</code> Enumerated type with possible values X, Y, ... <code>[T;N]</code> Array of N elements of type T <code>[T;N,M,...]</code> Array of type T with N, M, or other specified number of elements <code>option[T]</code> Optional value of type T"},{"location":"schema/table/#special-types","title":"Special Types","text":"<p>Some schema contains special types as follows, which are written in key-value pairs in JSON format.</p>"},{"location":"schema/table/#rle","title":"<code>RLE</code>","text":"<p>The <code>RLE</code> type is used to represent run-length encoding of a 2D semantic mask:</p> <pre><code>RLE {\n  \"size\":                   &lt;[int;2]&gt; -- Mask size [width, height].\n  \"counts\":                 &lt;str&gt; -- Encoded counts, where each count is represented as a pair of integers separated by a comma.\n}\n</code></pre>"},{"location":"schema/table/#autolabelmodel","title":"<code>AutolabelModel</code>","text":"<p>The <code>AutolabelModel</code> type used in <code>autolabel_metadata</code> fields has the following structure:</p> <pre><code>AutolabelModel {\n  \"name\":                     &lt;str&gt; -- Name of the model used for annotation. Can include version information.\n  \"score\":                    &lt;float&gt; -- Label score for the annotation from this model (range: 0.0\u20131.0).\n  \"uncertainty\":              &lt;option[float]&gt; -- Model-reported uncertainty for the annotation (range: 0.0\u20131.0). Lower values imply higher confidence.\n}\n</code></pre>"},{"location":"schema/table/#indicators","title":"<code>Indicators</code>","text":"<p>The <code>Indicators</code> represents the status of vehicle indicators:</p> <pre><code>Indicators {\n  \"left\":                   &lt;enum[\"on\", \"off\"]&gt; -- Left indicator status.\n  \"right\":                  &lt;enum[\"on\", \"off\"]&gt; -- Right indicator status.\n  \"hazard\":                 &lt;enum[\"on\", \"off\"]&gt; -- Hazard indicator status.\n}\n</code></pre>"},{"location":"schema/table/#additionalinfo","title":"<code>AdditionalInfo</code>","text":"<p>The <code>AdditionalInfo</code> represents additional information about the vehicle:</p> <pre><code>AdditionalInfo {\n  \"speed\":                  &lt;option[float]&gt; -- Vehicle speed in meters per second.\n}\n</code></pre>"},{"location":"schema/table/#mandatory-tables","title":"Mandatory Tables","text":"<p>The following mandatory tables are required for the dataset, so <code>Tier</code> class raises runtime error if not found.</p>"},{"location":"schema/table/#attribute","title":"Attribute","text":"<ul> <li>Filename: <code>attribute.json</code></li> </ul> <p>An attribute is a property of an instance that can change while the category remains the same.</p> <p>For example, a <code>pedestrian</code> category can have the following attributes:</p> <ul> <li><code>sitting</code>: Indicates whether the pedestrian is sitting.</li> <li><code>standing</code>: Indicates whether the pedestrian is standing.</li> <li><code>lying_down</code>: Indicates whether the pedestrian is lying down.</li> </ul> <pre><code>attribute {\n  \"token\":             &lt;str&gt; -- Unique record identifier.\n  \"name\":              &lt;str&gt; -- Name of the attribute.\n  \"description\":       &lt;str&gt; -- Description of the attribute.\n}\n</code></pre>"},{"location":"schema/table/#calibratedsensor","title":"CalibratedSensor","text":"<ul> <li>Filename: <code>calibrated_sensor.json</code></li> </ul> <p>Definition of a particular sensor (e.g. LiDAR, camera, radar) as calibrated on a particular vehicle.</p> <p>All extrinsic parameters are given with respect to the world coordinate frame.</p> <pre><code>calibrated_sensor {\n  \"token\":              &lt;str&gt; -- Unique record identifier.\n  \"sensor_token\":       &lt;str&gt; -- Foreign key to the `Sensor` table.\n  \"translation\":        &lt;[float;3]&gt; -- Extrinsic translation of the sensor. Coordinate system origin in meters: (x, y, z).\n  \"rotation\":           &lt;[float;4]&gt; -- Extrinsic rotation of the sensor. Coordinate system orientation as quaternion: (w, x, y, z).\n  \"camera_intrinsic\":   &lt;[[float;3];3]&gt; -- Intrinsic camera calibration matrix. Empty list `[]` for sensors other than cameras.\n  \"camera_distortion\":  &lt;[float;4,5,8,12,14]&gt; -- Distortion coefficients of the camera following OpenCV convention. Supports 4, 5, 8, 12, or 14 elements for different distortion models. Empty list `[]` for sensors other than cameras.\n}\n</code></pre>"},{"location":"schema/table/#category","title":"Category","text":"<ul> <li>Filename: <code>category.json</code></li> </ul> <p>Taxonomy of object categories, such as <code>vehicle.truck</code>, <code>vehicle.car</code>, etc.</p> <pre><code>category {\n  \"token\":              &lt;str&gt; -- Unique record identifier.\n  \"name\":               &lt;str&gt; -- Name of the category.\n  \"description\":        &lt;str&gt; -- Description of the category.\n  \"index\":              &lt;option[int]&gt; -- Category index, this is added to support `lidarseg`, or `None` when it doesn't support `lidarseg`.\n  \"has_orientation\":    &lt;bool&gt; -- Indicates whether annotations for this category may include an `orientation` field (e.g., traffic light arrows). If omitted, it is treated as `false`.\n  \"has_number\":         &lt;bool&gt; -- Indicates whether annotations for this category may include a `number` field (e.g., numeric traffic lights). If omitted, it is treated as `false`.\n}\n</code></pre>"},{"location":"schema/table/#egopose","title":"EgoPose","text":"<ul> <li>Filename: <code>ego_pose.json</code></li> </ul> <p>Definition of the ego vehicle's pose at a particular timestamp.</p> <p>This includes both the vehicle's position and orientation in space, typically referred in a global coordinate system such as the map or odometry frame.</p> <pre><code>ego_pose {\n  \"token\":              &lt;str&gt; -- Unique record identifier.\n  \"translation\":        &lt;[float;3]&gt; -- Location of the ego vehicle. Coordinate system origin in meters: (x, y, z).\n  \"rotation\":           &lt;[float;4]&gt; -- Rotation of the ego vehicle. Coordinate system orientation as quaternion: (w, x, y, z).\n  \"twist\":              &lt;option[[float;6]]&gt; -- Linear and angular velocity in the local coordinate system of the ego vehicle. Coordinate system velocity as vector: (vx, vy, vz, yaw_rate, pitch_rate, roll_rate).\n  \"acceleration\":       &lt;option[[float;3]]&gt; -- Linear acceleration in the **local** coordinate system of the ego vehicle, (ax, ay, az).\n  \"geocoordinate\":      &lt;option[[float;3]]&gt; -- Geographical coordinates of the ego vehicle. Coordinate system origin in meters: (latitude, longitude, altitude).\n}\n</code></pre>"},{"location":"schema/table/#instance","title":"Instance","text":"<ul> <li>Filename: <code>instance.json</code></li> </ul> <p>A particular object instance. This table is an enumeration of all object instances we observed.</p> <p>Note that instances are not tracked across scenes. For example, even if an object has the same instance in scene A and B, it should be considered as two different instances.</p> <pre><code>instance {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"category_token\":         &lt;str&gt; -- Foreign key to the `Category` table.\n  \"instance_name\":          &lt;str&gt; -- Consists of the dataset name and the instance ID separated by colons `::`, such as `&lt;DATASET_ID&gt;::&lt;INSTANCE_ID&gt;`.\n  \"nbr_annotations\":        &lt;int&gt; -- Number of annotations associated with this instance.\n  \"first_annotation_token\": &lt;str&gt; -- Foreign key to the first `SampleAnnotation` table associated with this instance.\n  \"last_annotation_token\":  &lt;str&gt; -- Foreign key to the last `SampleAnnotation` table associated with this instance.\n}\n</code></pre>"},{"location":"schema/table/#log","title":"Log","text":"<ul> <li>Filename: <code>log.json</code></li> </ul> <p>Log information on the data from which the data was collected.</p> <pre><code>log {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"logfile\":                &lt;str&gt; -- Path to the log file.\n  \"vehicle\":                &lt;str&gt; -- Name of the vehicle.\n  \"data_captured\":          &lt;str&gt; -- Data captured by the vehicle given as `YYYY-MM-DD-HH-MM-SS`.\n  \"location\":               &lt;str&gt; -- Location of the vehicle.\n}\n</code></pre>"},{"location":"schema/table/#map","title":"Map","text":"<ul> <li>Filename: <code>map.json</code></li> </ul> <pre><code>map {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"log_tokens\":             &lt;[str;N]&gt; -- List of foreign keys to the `Log` table associated with this map.\n  \"category\":               &lt;str&gt; -- Category of the map.\n  \"filename\":               &lt;str&gt; -- Relative path to the binary file of the map mask.\n}\n</code></pre>"},{"location":"schema/table/#sample","title":"Sample","text":"<ul> <li>Filename: <code>sample.json</code></li> </ul> <p>A sample is an annotated keyframe. The timestamp of a sample is the same as that of a LiDAR sample data.</p> <pre><code>sample {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"timestamp\":              &lt;int&gt; -- Unix timestamp in microseconds, which is the same as the `timestamp` field in the corresponding LiDAR `SampleData` table.\n  \"scene_token\":            &lt;str&gt; -- Foreign key to the `Scene` table associated with this sample.\n  \"next\":                   &lt;str&gt; -- Foreign key to the next `Sample` table associated with this sample. Empty string `\"\"` if this is the last sample.\n  \"prev\":                   &lt;str&gt; -- Foreign key to the previous `Sample` table associated with this sample. Empty string `\"\"` if this is the first sample.\n}\n</code></pre>"},{"location":"schema/table/#sampleannotation","title":"SampleAnnotation","text":"<ul> <li>Filename: <code>sample_annotation.json</code></li> </ul> <p>An annotation for 3D objects in a sample. All location data are given with respect to the global coordinate system.</p> <pre><code>sample_annotation {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"sample_token\":           &lt;str&gt; -- Foreign key to the `Sample` table associated with this annotation.\n  \"instance_token\":         &lt;str&gt; -- Foreign key to the `Instance` table associated with this annotation.\n  \"attribute_tokens\":       &lt;[str;N]&gt; -- Foreign keys to the `Attribute` table associated with this annotation.\n  \"visibility_token\":       &lt;str&gt; -- Foreign key to the `Visibility` table associated with this annotation.\n  \"translation\":            &lt;[float;3]&gt; -- Center location of the cuboid in meters as (x, y, z).\n  \"rotation\":               &lt;[float;4]&gt; -- Quaternion representing the orientation of the cuboid as (w, x, y, z).\n  \"size\":                   &lt;[float;3]&gt; -- Size of the cuboid in meters as (width, length, height).\n  \"velocity\":               &lt;option[[float;3]]&gt; -- Velocity of the cuboid in meters per second as (vx, vy, vz).\n  \"acceleration\":           &lt;option[[float;3]]&gt; -- Acceleration of the cuboid in meters per second squared as (ax, ay, az).\n  \"num_lidar_pts\":          &lt;int&gt; -- Number of lidar points within the cuboid.\n  \"num_radar_pts\":          &lt;int&gt; -- Number of radar points within the cuboid.\n  \"next\":                   &lt;str&gt; -- Foreign key to the `SampleAnnotation` table associated with the next annotation in the sequence. Empty string `\"\"` if this is the last annotation.\n  \"prev\":                   &lt;str&gt; -- Foreign key to the `SampleAnnotation` table associated with the previous annotation in the sequence. Empty string `\"\"` if this is the first annotation.\n  \"automatic_annotation\":   &lt;bool&gt; -- Indicates whether the annotation was automatically generated. Defaults to `false`.\n  \"autolabel_metadata\":     &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n}\n</code></pre>"},{"location":"schema/table/#sampledata","title":"SampleData","text":"<ul> <li>Filename: <code>sample_data.json</code></li> </ul> <p>A sensor data, such as image, point cloud, or radar return. If the <code>is_key_frame=True</code>, the timestamp should be very close to the associated sample's timestamp.</p> <pre><code>sample_data {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"sample_token\":             &lt;str&gt; -- Foreign key to the `Sample` table.\n  \"ego_pose_token\":           &lt;str&gt; -- Foreign key to the `EgoPose` table.\n  \"calibrated_sensor_token\":  &lt;str&gt; -- Foreign key to the `CalibratedSensor` table.\n  \"filename\":                 &lt;str&gt; -- Relative path from a dataset root directory to the sensor data file.\n  \"fileformat\":               &lt;enum[\"jpg\", \"png\", \"pcd\", \"bin\", \"pcd.bin\"]&gt; -- File format of the sensor data file.\n  \"width\":                    &lt;int&gt; -- Width of the image in pixels.\n  \"height\":                   &lt;int&gt; -- Height of the image in pixels.\n  \"timestamp\":                &lt;int&gt; -- unix timestamp in microseconds.\n  \"is_key_frame\":             &lt;bool&gt; -- Indicates whether this is a key frame.\n  \"next\":                     &lt;str&gt; -- Foreign key to the `SampleData` table associated with the next data in the sequence. Empty string `\"\"` if this is the last data.\n  \"prev\":                     &lt;str&gt; -- Foreign key to the `SampleData` table associated with the previous data in the sequence. Empty string `\"\"` if this is the first data.\n  \"is_valid\":                 &lt;bool&gt; -- Indicates whether this data is valid. Defaults to `true`.\n  \"info_filename\":            &lt;option[str]&gt; -- Relative path to metadata-blob file.\n  \"autolabel_metadata\":       &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling applied to this entire sample_data item (e.g., image or scan).\n}\n</code></pre>"},{"location":"schema/table/#scene","title":"Scene","text":"<ul> <li>Filename: <code>scene.json</code></li> </ul> <p>A scene is a sequence of consecutive frames extracted from a log. In T4 format, only one scene is included in a single dataset.</p> <pre><code>scene {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"name\":                     &lt;str&gt; -- Name of the scene, given as `{PROJECT_NAME}_{SCENE_TOKEN}`.\n  \"description\":              &lt;str&gt; -- Description of the scene.\n  \"log_token\":                &lt;str&gt; -- Foreign key to the `Log` table associated with the log that contains this scene.\n  \"nbr_samples\":              &lt;int&gt; -- Number of samples in the scene.\n  \"first_sample_token\":       &lt;str&gt; -- Foreign key to the `Sample` table associated with the first data in the scene.\n  \"last_sample_token\":        &lt;str&gt; -- Foreign key to the `Sample` table associated with the last data in the scene.\n}\n</code></pre>"},{"location":"schema/table/#sensor","title":"Sensor","text":"<ul> <li>Filename: <code>sensor.json</code></li> </ul> <p>A description of sensor types.</p> <pre><code>sensor {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"channel\":                  &lt;str&gt; -- Channel of the sensor.\n  \"modality\":                 &lt;enum[\"camera\", \"lidar\", \"radar\"]&gt; -- Modality of the sensor.\n}\n</code></pre>"},{"location":"schema/table/#visibility","title":"Visibility","text":"<ul> <li>Filename: <code>visibility.json</code></li> </ul> <p>A description of annotation visibility status.</p> <p>Visibility level is classified into 4 bins below:</p> <ul> <li>full: The annotation is fully visible.</li> <li>most: The annotation is mostly visible, more than 50%.</li> <li>partial: The annotation is partially visible, more than 10% but less than 50%.</li> <li>none: The annotation is not visible.</li> </ul> <pre><code>visibility {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"level\":                    &lt;enum[\"full\", \"most\", \"partial\", \"none\"]&gt; -- Level of visibility of the annotation.\n  \"description\":              &lt;str&gt; -- Description of the visibility level.\n}\n</code></pre> Warning <p>Following old formats are also supported but deprecated:</p> <p> <pre><code>- v80-100 : full\n- v60-80  : most\n- v40-60  : partial\n- v0-40   : none\n</code></pre></p> <p>If input level does not satisfy any above cases, <code>VisibilityLevel.UNAVAILABLE</code> will be assigned.</p>"},{"location":"schema/table/#optional-tables","title":"Optional Tables","text":"<p>The following tables are optional, and skipped loading by <code>Tier4</code> class if not exists.</p>"},{"location":"schema/table/#lidarseg","title":"LidarSeg","text":"<ul> <li>Filename: <code>lidarseg.json</code></li> </ul> <p>Mapping between LiDAR segmentation annotations and <code>SampleData</code> corresponding to the LiDAR point cloud associated with a keyframe.</p> <pre><code>lidarseg {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"filename\":                 &lt;str&gt; -- Filename of the LiDAR segmentation annotation labels that is an array of unit8.\n  \"sample_data_token\":        &lt;str&gt; -- Foreign key to the `SampleData` table associated with the sample data.\n}\n</code></pre>"},{"location":"schema/table/#objectann","title":"ObjectAnn","text":"<ul> <li>Filename: <code>object_ann.json</code></li> </ul> <p>The annotation of a foreground object (car, bike, pedestrian, etc.) in an image. Each foreground object is annotated with a 2D box, a 2D instance mask and category-specific attributes.</p> <pre><code>object_ann {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"sample_data_token\":        &lt;str&gt; -- Foreign key to the `SampleData` table associated with the sample data.\n  \"instance_token\":           &lt;str&gt; -- Foreign key to the `Instance` table associated with the instance of the object.\n  \"category_token\":           &lt;str&gt; -- Foreign key to the `Category` table associated with the category of the object.\n  \"attribute_tokens\":         &lt;[str;N]&gt; -- Foreign keys to the `Attribute` table associated with the attributes of the object.\n  \"bbox\":                     &lt;[int;4]&gt; -- Bounding box coordinates in the format (xmin, ymin, xmax, ymax).\n  \"mask\":                     &lt;RLE&gt; -- Run length encoding of instance mask.\n  \"orientation\":              &lt;option[float]&gt; -- Orientation of the arrow shape within the bounding box, in radians. Present only for categories where `has_orientation` is true (e.g., traffic light arrows).\n  \"number\":                   &lt;option[int]&gt; -- The digit displayed within the bounding box. Present only for categories where `has_number` is true (e.g., numeric traffic lights).\n  \"automatic_annotation\":     &lt;bool&gt; -- Whether the annotation was automatically generated. Defaults to `false`.\n  \"autolabel_metadata\":       &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n}\n</code></pre>"},{"location":"schema/table/#surfaceann","title":"SurfaceAnn","text":"<ul> <li>Filename: <code>surface_ann.json</code></li> </ul> <p>The annotation of a background object (drivable surface) in an image. Each background object is annotated with a 2d semantic segmentation mask.</p> <pre><code>surface_ann {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"sample_data_token\":        &lt;str&gt; -- Foreign key to the `SampleData` table associated with the sample data.\n  \"category_token\":           &lt;str&gt; -- Foreign key to the `Category` table associated with the category of the surface.\n  \"mask\":                     &lt;RLE&gt; -- Run length encoding of instance mask.\n  \"automatic_annotation\":     &lt;bool&gt; -- Whether the annotation was automatically generated. Defaults to `false`.\n  \"autolabel_metadata\":       &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n}\n</code></pre>"},{"location":"schema/table/#vehiclestate","title":"VehicleState","text":"<ul> <li>Filename: <code>vehicle_state.json</code></li> </ul> <p>This table provides comprehensive information about the vehicle's state at a given timestamp, including the status of doors, indicators, steering, and other relevant information.</p> <pre><code>vehicle_state {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"timestamp\":                &lt;int&gt; -- Unix timestamp in microseconds.\n  \"accel_pedal\":              &lt;option[float]&gt; -- Accelerator pedal position percentage.\n  \"brake_pedal\":              &lt;option[float]&gt; -- Brake pedal position percentage.\n  \"steer_pedal\":              &lt;option[float]&gt; -- Steering wheel position percentage.\n  \"steering_tire_angle\":      &lt;option[float]&gt; -- Steering tire angle in radians.\n  \"steering_wheel_angle\":     &lt;option[float]&gt; -- Steering wheel angle in radians.\n  \"shift_state\":              &lt;option[enum[\"PARK\", \"REVERSE\", \"NEUTRAL\", \"HIGH\", \"FORWARD\", \"LOW\", \"NONE\"]]&gt; -- Shift state of the vehicle.\n  \"indicators\":               &lt;option[Indicators]&gt; -- Indicator state of the vehicle.\n  \"additional_info\":          &lt;option[AdditionalInfo]&gt; -- Additional information about the vehicle state.\n}\n</code></pre>"},{"location":"tutorials/customize/","title":"Schema Customization","text":""},{"location":"tutorials/customize/#generate-with-a-new-token","title":"Generate with a New Token","text":"<p>You can crate a schema containing the specified table data with a new token using <code>new(...)</code> methods.</p> <pre><code>&gt;&gt;&gt; from t4_devkit.schema import Attribute\n&gt;&gt;&gt; from t4_devkit.common import serialize_dataclass\n&gt;&gt;&gt;\n&gt;&gt;&gt; # schema data except of the unique identifier token\n&gt;&gt;&gt; data = {\n...     \"name\": \"foo\",\n...     \"description\": \"this is re-generated attribute.\"\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; attr1 = Attribute.new(data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Also, it allows us to create a copy of the existing table data with a new token\n&gt;&gt;&gt; serialized = serialize_dataclass(attr1)\n&gt;&gt;&gt; attr2 = Attribute.new(serialized)\n&gt;&gt;&gt;\n&gt;&gt;&gt; attr1.token != attr2.token\nTrue\n&gt;&gt;&gt; attr1\nAttribute(token='b08701e5095fbd12a45e7f51b85ffc08', name='foo', description='this is re-generated attribute.')\n&gt;&gt;&gt; attr2\nAttribute(token='f40e605870aa29b1473ca6e65255c45e', name='foo', description='this is re-generated attribute.')\n</code></pre>"},{"location":"tutorials/customize/#customize-schema-classes","title":"Customize Schema Classes","text":"<p>You can customize schema classes on your own code, if you need for some reasons.</p> <p>For example, you might meet the error because of missing some mandatory fields but it is OK whatever the actual value is.</p> <p>In here, let's define a custom <code>Attribute</code> class, called <code>CustomAttribute</code>, in your workspace. This class suppresses runtime exception caused by missing <code>description</code> in <code>attribute.json</code>.</p> <p>Now you have the following workspace structure:</p> <pre><code>my_package\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 custom_schema.py\n\u2502   \u2514\u2500\u2500 main.py\n\u2514\u2500\u2500 pyproject.toml\n</code></pre> <p>By editing <code>custom_schema.py</code>, you can define <code>CustomAttribute</code> overwriting <code>Attribute</code> as follows:</p> custom_schema.py<pre><code>from __future__ import annotations\n\nfrom attrs import define, field\n\nfrom t4_devkit.schema import SCHEMAS, SchemaName, SchemaBase\nfrom t4_devkit.common import load_json\n\n__all__ = [\"CustomAttribute\"]\n\n\n@define(slots=False)\n@SCHEMAS.register(SchemaName.ATTRIBUTE, force=True)\nclass CustomAttribute(SchemaBase):\n    \"\"\"Custom Attribute class ignoring if there is no `description` field.\n    Note that `description` field is mandatory in the original `Attribute` class.\n\n    `@SCHEMAS.register(SchemaName.ATTRIBUTE, force=True)` performs that\n    it forces to update the attribute table in the schema registry.\n    \"\"\"\n\n    name: str\n    description: str | None = field(default=None)\n</code></pre> <p>Note that <code>CustomAttribute</code> should be imported before instantiating <code>Tier4</code> class. Then modify <code>__init__.py</code> in order to import it automatically:</p> __init__.py<pre><code>from .custom_attribute import * # noqa\n</code></pre>"},{"location":"tutorials/initialize/","title":"Initialization","text":""},{"location":"tutorials/initialize/#initialize-tier4-class","title":"Initialize <code>Tier4</code> class","text":"<p><code>Tier4</code> class expects both following dataset directly structure with or without <code>&lt;VERSION&gt;</code> directory:</p> <ul> <li>With <code>&lt;VERSION&gt;</code> directory:</li> </ul> <pre><code>data/tier4/\n\u2514\u2500\u2500 &lt;VERSION&gt; ...version number\n    \u251c\u2500\u2500 annotation ...contains `*.json` files\n    \u251c\u2500\u2500 data\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_LEFT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_RIGHT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_LEFT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_RIGHT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 LIDAR_CONCAT\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ...Other sensor channels\n    ...\n</code></pre> <ul> <li>Without <code>&lt;VERSION&gt;</code> directory:</li> </ul> <pre><code>data/tier4/\n\u251c\u2500\u2500 annotation ...contains `*.json` files\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_LEFT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_RIGHT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_LEFT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_RIGHT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LIDAR_CONCAT\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...Other sensor channels\n...\n</code></pre> <p>You can initialize a <code>Tier4</code> instance as follows:</p> <pre><code>&gt;&gt;&gt; from t4_devkit import Tier4\n\n&gt;&gt;&gt; t4 = Tier4(\"data/tier4/\", verbose=True)\n======\nLoading T4 tables in `annotation`...\nReverse indexing...\nDone reverse indexing in 0.007 seconds.\n======\n13 attribute\n7 calibrated_sensor\n8 category\n2524 ego_pose\n106 instance\n1 log\n1 map\n72 sample\n2390 sample_annotation\n2524 sample_data\n4 visibility\n7 sensor\n1 scene\n1326 object_ann\n0 surface_ann\n0 keypoint\nDone loading in 0.061 seconds.\n======\n</code></pre> <p>Note that if you doesn't specify <code>revision</code> parameter in construction, it searches the latest version of the dataset. By specifying <code>revision=&lt;VERSION&gt;</code>, you can load the specific version of the dataset.</p> <pre><code>&gt;&gt;&gt; t4 = Tier4(\"data/tier4/\", revision=\"2\", verbose=True)\n</code></pre>"},{"location":"tutorials/initialize/#access-to-schema-fields","title":"Access to Schema Fields","text":""},{"location":"tutorials/initialize/#scene","title":"<code>scene</code>","text":"<pre><code>&gt;&gt;&gt; my_scene = t4.scene[0]\n</code></pre>"},{"location":"tutorials/initialize/#sample","title":"<code>sample</code>","text":"<p><code>sample</code> is an annotated keyframe of a scene at a given timestamp.</p> <pre><code>&gt;&gt;&gt; first_sample_token = my_scene.first_sample_token\n&gt;&gt;&gt; my_sample = t4.get(\"sample\", first_sample_token)\n</code></pre> <p>You can access the <code>sample_data</code> associated with this <code>sample</code>. <code>sample.data</code> returns a <code>dict</code> object consists of <code>{str: &lt;SAMPLE_DATA_TOKEN (str)&gt;}</code>.</p> <pre><code>&gt;&gt;&gt; my_sample.data\n</code></pre>"},{"location":"tutorials/initialize/#sample_data","title":"<code>sample_data</code>","text":"<p><code>sample_data</code> is references to a family of data that is collected from specific sensors.</p> <pre><code>&gt;&gt;&gt; sensor = \"CAM_FRONT\"\n&gt;&gt;&gt; t4.get(\"sample_data\", my_sample.data[sensor])\n</code></pre>"},{"location":"tutorials/initialize/#sample_annotation","title":"<code>sample_annotation</code>","text":"<p><code>sample_annotation</code> refers to any 3D bounding box in a corresponding <code>sample</code>. All location data is given with respect to the global coordinate system. You can access the list of <code>sample_annotation</code> tokens with <code>sample.ann_3ds: list[str]</code>.</p> <pre><code>&gt;&gt;&gt; my_annotation_token = my_sample.ann_3ds[0]\n&gt;&gt;&gt; t4.get(\"sample_annotation\", my_annotation_token)\n</code></pre>"},{"location":"tutorials/initialize/#instance","title":"<code>instance</code>","text":"<p>Each annotated object is instanced to be tracked.</p> <pre><code>&gt;&gt;&gt; t4.instance\n</code></pre>"},{"location":"tutorials/initialize/#category","title":"<code>category</code>","text":"<p>A <code>category</code> is the object assignment of an annotation.</p> <pre><code>&gt;&gt;&gt; t4.category\n</code></pre>"},{"location":"tutorials/initialize/#attribute","title":"<code>attribute</code>","text":"<p>An <code>attribute</code> is a property of an instance that may change throughout different parts of a scene while <code>category</code> remains the same.</p> <pre><code>&gt;&gt;&gt; t4.attribute\n</code></pre>"},{"location":"tutorials/initialize/#visibility","title":"<code>visibility</code>","text":"<p><code>visibility</code> is defined as the fraction of pixels of a particular annotation that are visible over the 6 camera feeds.</p> <pre><code>&gt;&gt;&gt; t4.visibility\n</code></pre> <p>Warning</p> <p>Expected <code>level</code> values in <code>visibility</code> are as below:</p> <p> <pre><code>- full    : No occlusion for the object.\n- most    : Object is occluded, but by less than 50%.\n- partial : Object is occluded, but by more than 50%.\n- none    : Object is 90-100% occluded and no points/pixels are visible.\n</code></pre></p> <p>Following old formats are also supported but deprecated:</p> <p> <pre><code>- v80-100 : full\n- v60-80  : most\n- v40-60  : partial\n- v0-40   : none\n</code></pre></p> <p>If input level does not satisfy any above cases, <code>VisibilityLevel.UNAVAILABLE</code> will be assigned.</p>"},{"location":"tutorials/initialize/#sensor","title":"<code>sensor</code>","text":"<p>T4 dataset consists of several type of sensors. The supported sensor modalities and channels are defined in <code>t4_devkit/schema/tables/sensor.py</code>.</p> <pre><code>&gt;&gt;&gt; t4.sensor\n</code></pre>"},{"location":"tutorials/initialize/#calibrated_sensor","title":"<code>calibrated_sensor</code>","text":"<p><code>calibrated_sensor</code> consists of the definition of a calibration of a particular sensor based on a vehicle.</p> <pre><code>&gt;&gt;&gt; t4.calibrated_sensor\n</code></pre> <p>Note that the <code>translation</code> and <code>rotation</code> parameters are given with respect to the ego vehicle body frame.</p>"},{"location":"tutorials/initialize/#ego_pose","title":"<code>ego_pose</code>","text":"<p><code>ego_pose</code> contains information about the <code>translation</code> and <code>rotation</code> of the ego vehicle, with respect to the global coordinate system.</p> <pre><code>&gt;&gt;&gt; t4.ego_pose\n</code></pre>"},{"location":"tutorials/render/","title":"Visualization","text":""},{"location":"tutorials/render/#rendering-with-tier4","title":"Rendering with <code>Tier4</code>","text":"<p>If you want to visualize annotation results, <code>Tier4</code> supports some rendering methods as below.</p>"},{"location":"tutorials/render/#scene","title":"Scene","text":"<pre><code>&gt;&gt;&gt; t4.render_scene()\n</code></pre>"},{"location":"tutorials/render/#specific-instances","title":"Specific Instance(s)","text":"<pre><code>&gt;&gt;&gt; instance_token = t4.instance[0].token\n&gt;&gt;&gt; t4.render_instance(instance_token)\n</code></pre> <p>Note</p> <p>You can also render multiple instances at once:</p> <p> <pre><code>&gt;&gt;&gt; instance_tokens = [inst.token for inst in t4.instance[:3]]\n&gt;&gt;&gt; t4.render_instance(instance_tokens)\n</code></pre></p>"},{"location":"tutorials/render/#pointcloud","title":"PointCloud","text":"<pre><code>&gt;&gt;&gt; t4.render_pointcloud()\n</code></pre> <p>Note</p> <p>In case of you want to ignore camera distortion, please specify <code>ignore_distortion=True</code>.</p> <p> <pre><code>&gt;&gt;&gt; t4.render_pointcloud(ignore_distortion=True)\n</code></pre></p>"},{"location":"tutorials/render/#save-recording","title":"Save Recording","text":"<p>You can save the rendering result as follows:</p> <pre><code>&gt;&gt;&gt; t4.render_scene(scene_token, save_dir=&lt;DIR_TO_SAVE&gt;)\n</code></pre> <p>When you specify <code>save_dir</code>, viewer will not be spawned on your screen.</p>"},{"location":"tutorials/render/#rendering-with-rerunviewer","title":"Rendering with <code>RerunViewer</code>","text":"<p>If you want to visualize your components, such as boxes that your ML-model estimated, <code>RerunViewer</code> allows you to visualize these components. For details, please refer to the API references.</p> <p>To initialize <code>RerunViewer</code>, you can use the <code>ViewerBuilder</code> class:</p> <pre><code>&gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n# You need to specify `cameras` if you want to 2D spaces\n&gt;&gt;&gt; viewer = (\n        ViewerBuilder()\n        .with_spatial3d()\n        .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n        .with_labels({\"car\": 1, \"pedestrian\": 2})\n        .build(app_id=\"foo\")\n    )\n\n# Timestamp in seconds\n&gt;&gt;&gt; seconds: int | float = ...\n</code></pre>"},{"location":"tutorials/render/#rendering-3d-boxes","title":"Rendering 3D boxes","text":"<pre><code># Rendering 3D boxes\n&gt;&gt;&gt; from t4_devkit.dataclass import Box3D\n&gt;&gt;&gt; box3ds = [Box3D(...)...]\n&gt;&gt;&gt; viewer.render_box3ds(seconds, box3ds)\n</code></pre> <p>It allows you to render boxes by specifying elements of boxes directly.</p> <pre><code># Rendering 3D boxes by specifying elements of boxes directly\n&gt;&gt;&gt; centers = [[i, i, i] for i in range(10)]\n&gt;&gt;&gt; frame_id = \"base_link\"\n&gt;&gt;&gt; rotations = [[1, 0, 0, 0] for _ in range(10)]\n&gt;&gt;&gt; sizes = [[1, 1, 1] for _ in range(10)]\n&gt;&gt;&gt; class_ids = [0 for _ in range(10)]\n&gt;&gt;&gt; viewer.render_box3ds(seconds, frame_id, centers, rotations, sizes, class_ids)\n</code></pre> <p></p>"},{"location":"tutorials/render/#rendering-2d-boxes","title":"Rendering 2D boxes","text":"<p>For 2D spaces, you need to specify camera names in the viewer constructor, and render images by specifying camera names:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from t4_devkit.dataclass import Box2D\n\n# Rendering an image\n&gt;&gt;&gt; image = np.zeros((100, 100, 3), dtype=np.uint8)\n&gt;&gt;&gt; viewer.render_image(seconds, \"camera1\", image)\n\n# Rendering 2D boxes\n&gt;&gt;&gt; box2ds = [Box2D(...)...]\n&gt;&gt;&gt; viewer.render_box2ds(seconds, \"camera1\", box2ds)\n</code></pre> <p>It allows you to render boxes by specifying elements of boxes directly:</p> <pre><code># Rendering 2D boxes by specifying elements of boxes directly\n&gt;&gt;&gt; rois = [[0, 0, 10 * i, 10 * i] for i in range(10)]\n&gt;&gt;&gt; viewer.render_box2ds(seconds, \"camera1\", rois, class_ids)\n</code></pre> <p></p>"},{"location":"tutorials/render/#rendering-point-cloud","title":"Rendering point cloud","text":"<pre><code>from t4_devkit.dataclass import LidarPointCloud\n# Point cloud channel name\n&gt;&gt;&gt; lidar_channel = \"LIDAR_TOP\"\n# Load point cloud from file\n&gt;&gt;&gt; pointcloud = LidarPointCloud.from_file(&lt;PATH_TO_POINTCLOUD.pcd.bin&gt;)\n&gt;&gt;&gt; viewer.render_pointcloud(seconds, lidar_channel, pointcloud)\n</code></pre>"},{"location":"tutorials/render/#rendering-lanelet-map","title":"Rendering lanelet map","text":"<pre><code># Rendering lanelet map\n&gt;&gt;&gt; viewer.render_map(&lt;PATH_TO_LANELET.osm&gt;)\n</code></pre>"},{"location":"tutorials/sanity/","title":"Sanity Check","text":""},{"location":"tutorials/sanity/#sanity-check","title":"Sanity Check","text":""},{"location":"tutorials/sanity/#quick-start","title":"Quick Start","text":"<p><code>sanity_check(...)</code> function performs a series of sanity checks to ensure the integrity of the dataset.</p> <p>About the defined rules, please refer to requirement.md.</p> main.py<pre><code>from t4_devkit.common import save_json, serialize_dataclass\nfrom t4_devkit.sanity import sanity_check, print_sanity_result\n\n\nresult = sanity_check(\"&lt;path/to/dataset&gt;\")\n\n# display detailed results and summary\nprint_sanity_result(result)\n\n# save result to JSON file if you want\nsave_json(serialize_dataclass(result), \"result.json\")\n</code></pre>"},{"location":"tutorials/sanity/#how-to-add-new-checkers","title":"How to Add New Checkers","text":"<p>All checkers must follow:</p> <ul> <li>Implement a class that inherits from <code>Checker</code> class.</li> <li>Its ID must be unique and belong to one of <code>RuleGroup</code> enum.</li> <li>Override the <code>check() -&gt; list[Reason] | None</code> method to perform the specific check.</li> <li>Register the checker using <code>CHECKERS.register()</code> decorator.</li> </ul> str000.py<pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom t4_devkit.sanity.checker import Checker, RuleID, RuleName, Severity\nfrom t4_devkit.sanity.registry import CHECKERS\nfrom t4_devkit.sanity.result import Reason\n\nif TYPE_CHECKING:\n    from t4_devkit.sanity.context import SanityContext\n\n\n@CHECKERS.register()\nclass STR000(Checker):\n    \"\"\"This is a custom checker.\"\"\"\n\n    id = RuleID(\"STR000\")\n    name = RuleName(\"my-custom-checker\")\n    severity = Severity.ERROR\n    description = \"This is a custom checker.\"\n\n    def check(self, context: SanityContext) -&gt; list[Reason] | None:\n        # Return a list of reasons if the check fails, or None if it passes.\n        return None\n</code></pre>"}]}