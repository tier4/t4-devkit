{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"<code>t4-devkit</code>","text":"<p><code>t4-devkit</code> is a toolkit to load and operate T4 dataset.</p>"},{"location":"#feature-supports","title":"Feature supports","text":""},{"location":"#visualization","title":"Visualization","text":"<p><code>t4-devkit</code> provides a set of visualization tools to help you understand the data.</p> <p>More details, please refer to <code>t4viz</code> CLI or API usage.</p> Feature Task Support 3D 3D Boxes \u2705 PointCloud Segmentation \u2705 Raw PointCloud \u2705 3D Trajectories \u2705 TF Links \u2705 2D 2D Boxes \u2705 Image Segmentation \u2705 Raw Image \u2705 Raw PointCloud on Image \u2705 Map Vector Map \u2705 Ego Position on Street View \u2705"},{"location":"#sanity-checks","title":"Sanity Checks","text":"<p><code>t4-devkit</code> provides a set of sanity checks to ensure the correctness of the data.</p> <p>More details, please refer to <code>t4sanity</code> CLI or API usage.</p>"},{"location":"install/","title":"Installation","text":""},{"location":"install/#for-users-install-via-github","title":"[For Users] Install via GitHub","text":"<p>Note that the following command installs the latest <code>main</code> branch:</p> <pre><code># e.g) with pip\npip install git+https://github.com/tier4/t4-devkit.git\n</code></pre> <p>By specifying <code>@&lt;TAG_OR_BRANCH&gt;</code>, you can install the particular version of <code>t4-devkit</code>:</p> <pre><code># e.g) with pip\npip install git+https://github.com/tier4/t4-devkit.git@main\n</code></pre>"},{"location":"install/#for-developers-install-from-source","title":"[For Developers] Install from source","text":"<p>You need to install <code>uv</code>. For details, please refer to OFFICIAL DOCUMENT.</p> <pre><code>git clone git@github.com:tier4/t4-devkit.git\ncd t4-devkit\nuv sync --python 3.10\n</code></pre> <p>The virtual environment can be activated with:</p> <pre><code>source .venv/bin/activate\n</code></pre>"},{"location":"apis/common/","title":"<code>common</code>","text":""},{"location":"apis/dataclass/","title":"<code>dataclass</code>","text":""},{"location":"apis/dataclass/#t4_devkit.dataclass.label.SemanticLabel","title":"<code>SemanticLabel</code>","text":"<p>A dataclass to represent semantic labels.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Label name.</p> <code>attributes</code> <code>list[str]</code> <p>List of attribute names.</p> Source code in <code>t4_devkit/dataclass/label.py</code> <pre><code>@define(frozen=True, eq=False)\nclass SemanticLabel:\n    \"\"\"A dataclass to represent semantic labels.\n\n    Attributes:\n        name (str): Label name.\n        attributes (list[str], optional): List of attribute names.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    attributes: list[str] = field(\n        factory=list,\n        validator=validators.deep_iterable(validators.instance_of(str)),\n    )\n\n    def __eq__(self, other: str | SemanticLabel) -&gt; bool:\n        return self.name == other if isinstance(other, str) else self.name == other.name\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box2D","title":"<code>Box2D</code>","text":"<p>A class to represent 2D box.</p> <p>Attributes:</p> Name Type Description <code>unix_time</code> <code>int</code> <p>Unix timestamp.</p> <code>frame_id</code> <code>str</code> <p>Coordinates frame ID where the box is with respect to.</p> <code>semantic_label</code> <code>SemanticLabel</code> <p><code>SemanticLabel</code> object.</p> <code>confidence</code> <code>float</code> <p>Confidence score of the box.</p> <code>uuid</code> <code>str | None</code> <p>Unique box identifier.</p> <code>roi</code> <code>Roi | None</code> <p><code>Roi</code> object.</p> <code>position</code> <code>Vector3 | None</code> <p>3D position (x, y, z).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # without 3D position\n&gt;&gt;&gt; box2d = Box2D(\n...     unix_time=100,\n...     frame_id=\"camera\",\n...     semantic_label=SemanticLabel(\"car\"),\n...     roi=(100, 100, 50, 50),\n...     confidence=1.0,\n...     uuid=\"car2d_0\",\n... )\n&gt;&gt;&gt; # with 3D position\n&gt;&gt;&gt; box2d = box2d.with_position(position=(1.0, 1.0, 1.0))\n</code></pre> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>@define(eq=False)\nclass Box2D(BaseBox):\n    \"\"\"A class to represent 2D box.\n\n    Attributes:\n        unix_time (int): Unix timestamp.\n        frame_id (str): Coordinates frame ID where the box is with respect to.\n        semantic_label (SemanticLabel): `SemanticLabel` object.\n        confidence (float, optional): Confidence score of the box.\n        uuid (str | None, optional): Unique box identifier.\n        roi (Roi | None, optional): `Roi` object.\n        position (Vector3 | None, optional): 3D position (x, y, z).\n\n    Examples:\n        &gt;&gt;&gt; # without 3D position\n        &gt;&gt;&gt; box2d = Box2D(\n        ...     unix_time=100,\n        ...     frame_id=\"camera\",\n        ...     semantic_label=SemanticLabel(\"car\"),\n        ...     roi=(100, 100, 50, 50),\n        ...     confidence=1.0,\n        ...     uuid=\"car2d_0\",\n        ... )\n        &gt;&gt;&gt; # with 3D position\n        &gt;&gt;&gt; box2d = box2d.with_position(position=(1.0, 1.0, 1.0))\n    \"\"\"\n\n    roi: Roi | None = field(\n        default=None,\n        converter=lambda x: None if x is None else Roi(x),\n    )\n\n    # additional attributes: set by `with_**`\n    position: Vector3 | None = field(\n        default=None,\n        converter=lambda x: None if x is None else Vector3(x),\n    )\n\n    def with_position(self, position: Vector3Like) -&gt; Self:\n        \"\"\"Return a self instance setting `position` attribute.\n\n        Args:\n            position (Vector3Like): 3D position.\n\n        Returns:\n            Self instance after setting `position`.\n        \"\"\"\n        self.position = Vector3(position)\n        return self\n\n    def __eq__(self, other: Box2D | None) -&gt; bool:\n        if other is None:\n            return False\n        else:\n            # NOTE: This comparison might be not enough\n            eq = True\n            eq &amp;= self.unix_time == other.unix_time\n            eq &amp;= self.semantic_label == other.semantic_label\n            return eq\n\n    @property\n    def offset(self) -&gt; tuple[ScalarLike, ScalarLike] | None:\n        return None if self.roi is None else self.roi.offset\n\n    @property\n    def size(self) -&gt; tuple[ScalarLike, ScalarLike] | None:\n        return None if self.roi is None else self.roi.size\n\n    @property\n    def width(self) -&gt; ScalarLike | None:\n        return None if self.roi is None else self.roi.width\n\n    @property\n    def height(self) -&gt; ScalarLike | None:\n        return None if self.roi is None else self.roi.height\n\n    @property\n    def center(self) -&gt; tuple[ScalarLike, ScalarLike] | None:\n        return None if self.roi is None else self.roi.center\n\n    @property\n    def area(self) -&gt; ScalarLike | None:\n        return None if self.roi is None else self.roi.area\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box2D.with_position","title":"<code>with_position(position)</code>","text":"<p>Return a self instance setting <code>position</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Vector3Like</code> <p>3D position.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Self instance after setting <code>position</code>.</p> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def with_position(self, position: Vector3Like) -&gt; Self:\n    \"\"\"Return a self instance setting `position` attribute.\n\n    Args:\n        position (Vector3Like): 3D position.\n\n    Returns:\n        Self instance after setting `position`.\n    \"\"\"\n    self.position = Vector3(position)\n    return self\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D","title":"<code>Box3D</code>","text":"<p>A class to represent 3D box.</p> <p>Attributes:</p> Name Type Description <code>unix_time</code> <code>int</code> <p>Unix timestamp.</p> <code>frame_id</code> <code>str</code> <p>Coordinates frame ID where the box is with respect to.</p> <code>semantic_label</code> <code>SemanticLabel</code> <p><code>SemanticLabel</code> object.</p> <code>confidence</code> <code>float</code> <p>Confidence score of the box.</p> <code>uuid</code> <code>str | None</code> <p>Unique box identifier.</p> <code>position</code> <code>Vector3</code> <p>Box center position (x, y, z).</p> <code>rotation</code> <code>Quaternion</code> <p>Box rotation quaternion.</p> <code>shape</code> <code>Shape</code> <p><code>Shape</code> object.</p> <code>velocity</code> <code>Vector3 | None</code> <p>Box velocity (vx, vy, vz).</p> <code>num_points</code> <code>int | None</code> <p>The number of points inside the box.</p> <code>visibility</code> <code>VisibilityLevel</code> <p>Box visibility.</p> <code>future</code> <code>Future | None</code> <p>Box trajectory in the future of each mode.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; # without future\n&gt;&gt;&gt; box3d = Box3D(\n...     unix_time=100,\n...     frame_id=\"base_link\",\n...     semantic_label=SemanticLabel(\"car\"),\n...     position=(1.0, 1.0, 1.0),\n...     rotation=(0.0, 0.0, 0.0, 1.0),\n...     shape=Shape(shape_type=ShapeType.BOUNDING_BOX, size=(1.0, 1.0, 1.0)),\n...     velocity=(1.0, 1.0, 1.0),\n...     confidence=1.0,\n...     uuid=\"car3d_0\",\n... )\n&gt;&gt;&gt; # with future\n&gt;&gt;&gt; box3d = box3d.with_future(\n...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0], [3.0, 3.0, 3.0]]],\n...     confidences=[1.0],\n... )\n</code></pre> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>@define(eq=False)\nclass Box3D(BaseBox):\n    \"\"\"A class to represent 3D box.\n\n    Attributes:\n        unix_time (int): Unix timestamp.\n        frame_id (str): Coordinates frame ID where the box is with respect to.\n        semantic_label (SemanticLabel): `SemanticLabel` object.\n        confidence (float, optional): Confidence score of the box.\n        uuid (str | None, optional): Unique box identifier.\n        position (Vector3): Box center position (x, y, z).\n        rotation (Quaternion): Box rotation quaternion.\n        shape (Shape): `Shape` object.\n        velocity (Vector3 | None, optional): Box velocity (vx, vy, vz).\n        num_points (int | None, optional): The number of points inside the box.\n        visibility (VisibilityLevel, optional): Box visibility.\n        future (Future | None, optional): Box trajectory in the future of each mode.\n\n    Examples:\n        &gt;&gt;&gt; # without future\n        &gt;&gt;&gt; box3d = Box3D(\n        ...     unix_time=100,\n        ...     frame_id=\"base_link\",\n        ...     semantic_label=SemanticLabel(\"car\"),\n        ...     position=(1.0, 1.0, 1.0),\n        ...     rotation=(0.0, 0.0, 0.0, 1.0),\n        ...     shape=Shape(shape_type=ShapeType.BOUNDING_BOX, size=(1.0, 1.0, 1.0)),\n        ...     velocity=(1.0, 1.0, 1.0),\n        ...     confidence=1.0,\n        ...     uuid=\"car3d_0\",\n        ... )\n        &gt;&gt;&gt; # with future\n        &gt;&gt;&gt; box3d = box3d.with_future(\n        ...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0], [3.0, 3.0, 3.0]]],\n        ...     confidences=[1.0],\n        ... )\n    \"\"\"\n\n    position: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    shape: Shape = field(validator=validators.instance_of(Shape))\n    velocity: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n    num_points: int | None = field(\n        default=None,\n        validator=validators.optional((validators.instance_of(int), validators.ge(0))),\n    )\n    visibility: VisibilityLevel = field(\n        default=VisibilityLevel.UNAVAILABLE,\n        converter=VisibilityLevel,\n        validator=validators.instance_of(VisibilityLevel),\n    )\n\n    # additional attributes: set by `with_**`\n    future: Future | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(Future)),\n    )\n\n    def with_future(\n        self,\n        timestamps: ArrayLike,\n        confidences: ArrayLike,\n        waypoints: ArrayLike,\n    ) -&gt; Self:\n        \"\"\"Return a self instance setting `future` attribute.\n\n        Args:\n            timestamps (ArrayLike): Array of future timestamps at each waypoint in the shape of (T).\n            confidences (ArrayLike): Array of confidences for each mode in the shape of (M).\n            waypoints (ArrayLike): Array of waypoints for each mode in the shape of (M, T, D).\n\n        Returns:\n            Self instance after setting `future`.\n        \"\"\"\n        self.future = Future(timestamps=timestamps, confidences=confidences, waypoints=waypoints)\n        return self\n\n    def __eq__(self, other: Box3D | None) -&gt; bool:\n        if other is None:\n            return False\n        else:\n            # NOTE: This comparison might be not enough\n            eq = True\n            eq &amp;= self.unix_time == other.unix_time\n            eq &amp;= self.semantic_label == other.semantic_label\n            eq &amp;= self.position == other.position\n            eq &amp;= self.rotation == other.rotation\n            return eq\n\n    @property\n    def size(self) -&gt; Vector3:\n        \"\"\"Return the box size in the order of (width, length, height).\n\n        Returns:\n            (width, length, height) values.\n        \"\"\"\n        return self.shape.size\n\n    @property\n    def footprint(self) -&gt; Polygon:\n        return self.shape.footprint\n\n    @property\n    def area(self) -&gt; float:\n        return self.shape.footprint.area\n\n    @property\n    def volume(self) -&gt; float:\n        return self.area * self.size[2]\n\n    def translate(self, x: Vector3Like) -&gt; None:\n        \"\"\"Apply a translation.\n\n        Args:\n            x (Vector3Like): 3D translation vector in the order of (x, y, z).\n        \"\"\"\n        self.position += Vector3(x)\n\n        if self.future is not None:\n            self.future.translate(x)\n\n    def rotate(self, q: RotationLike) -&gt; None:\n        \"\"\"Apply a rotation.\n\n        Args:\n            q (RotationLike): Rotation quaternion.\n        \"\"\"\n        q = to_quaternion(q)\n        self.position = np.dot(q.rotation_matrix, self.position)\n        self.rotation = q * self.rotation\n\n        if self.velocity is not None:\n            self.velocity = np.dot(q.rotation_matrix, self.velocity)\n\n        if self.future is not None:\n            self.future.rotate(q)\n\n    def corners(self, box_scale: float = 1.0) -&gt; NDArrayF64:\n        \"\"\"Return the bounding box corners.\n\n        Args:\n            box_scale (float, optional): Multiply size by this factor to scale the box.\n\n        Returns:\n            First four corners are the ones facing forward. The last four are the ones facing backwards,\n                in the shape of (8, 3).\n        \"\"\"\n        width, length, height = self.size * box_scale\n\n        # 3D box corners (Convention: x points forward, y to the left, z up.)\n        x_corners = 0.5 * length * np.array([1, 1, 1, 1, -1, -1, -1, -1])\n        y_corners = 0.5 * width * np.array([1, -1, -1, 1, 1, -1, -1, 1])\n        z_corners = 0.5 * height * np.array([1, 1, -1, -1, 1, 1, -1, -1])\n        corners = np.vstack((x_corners, y_corners, z_corners))  # (3, 8)\n\n        # Rotate and translate\n        return np.dot(self.rotation.rotation_matrix, corners).T + self.position\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.size","title":"<code>size</code>  <code>property</code>","text":"<p>Return the box size in the order of (width, length, height).</p> <p>Returns:</p> Type Description <code>Vector3</code> <p>(width, length, height) values.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.corners","title":"<code>corners(box_scale=1.0)</code>","text":"<p>Return the bounding box corners.</p> <p>Parameters:</p> Name Type Description Default <code>box_scale</code> <code>float</code> <p>Multiply size by this factor to scale the box.</p> <code>1.0</code> <p>Returns:</p> Type Description <code>NDArrayF64</code> <p>First four corners are the ones facing forward. The last four are the ones facing backwards, in the shape of (8, 3).</p> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def corners(self, box_scale: float = 1.0) -&gt; NDArrayF64:\n    \"\"\"Return the bounding box corners.\n\n    Args:\n        box_scale (float, optional): Multiply size by this factor to scale the box.\n\n    Returns:\n        First four corners are the ones facing forward. The last four are the ones facing backwards,\n            in the shape of (8, 3).\n    \"\"\"\n    width, length, height = self.size * box_scale\n\n    # 3D box corners (Convention: x points forward, y to the left, z up.)\n    x_corners = 0.5 * length * np.array([1, 1, 1, 1, -1, -1, -1, -1])\n    y_corners = 0.5 * width * np.array([1, -1, -1, 1, 1, -1, -1, 1])\n    z_corners = 0.5 * height * np.array([1, 1, -1, -1, 1, 1, -1, -1])\n    corners = np.vstack((x_corners, y_corners, z_corners))  # (3, 8)\n\n    # Rotate and translate\n    return np.dot(self.rotation.rotation_matrix, corners).T + self.position\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.rotate","title":"<code>rotate(q)</code>","text":"<p>Apply a rotation.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>RotationLike</code> <p>Rotation quaternion.</p> required Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def rotate(self, q: RotationLike) -&gt; None:\n    \"\"\"Apply a rotation.\n\n    Args:\n        q (RotationLike): Rotation quaternion.\n    \"\"\"\n    q = to_quaternion(q)\n    self.position = np.dot(q.rotation_matrix, self.position)\n    self.rotation = q * self.rotation\n\n    if self.velocity is not None:\n        self.velocity = np.dot(q.rotation_matrix, self.velocity)\n\n    if self.future is not None:\n        self.future.rotate(q)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.translate","title":"<code>translate(x)</code>","text":"<p>Apply a translation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Vector3Like</code> <p>3D translation vector in the order of (x, y, z).</p> required Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def translate(self, x: Vector3Like) -&gt; None:\n    \"\"\"Apply a translation.\n\n    Args:\n        x (Vector3Like): 3D translation vector in the order of (x, y, z).\n    \"\"\"\n    self.position += Vector3(x)\n\n    if self.future is not None:\n        self.future.translate(x)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.Box3D.with_future","title":"<code>with_future(timestamps, confidences, waypoints)</code>","text":"<p>Return a self instance setting <code>future</code> attribute.</p> <p>Parameters:</p> Name Type Description Default <code>timestamps</code> <code>ArrayLike</code> <p>Array of future timestamps at each waypoint in the shape of (T).</p> required <code>confidences</code> <code>ArrayLike</code> <p>Array of confidences for each mode in the shape of (M).</p> required <code>waypoints</code> <code>ArrayLike</code> <p>Array of waypoints for each mode in the shape of (M, T, D).</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Self instance after setting <code>future</code>.</p> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def with_future(\n    self,\n    timestamps: ArrayLike,\n    confidences: ArrayLike,\n    waypoints: ArrayLike,\n) -&gt; Self:\n    \"\"\"Return a self instance setting `future` attribute.\n\n    Args:\n        timestamps (ArrayLike): Array of future timestamps at each waypoint in the shape of (T).\n        confidences (ArrayLike): Array of confidences for each mode in the shape of (M).\n        waypoints (ArrayLike): Array of waypoints for each mode in the shape of (M, T, D).\n\n    Returns:\n        Self instance after setting `future`.\n    \"\"\"\n    self.future = Future(timestamps=timestamps, confidences=confidences, waypoints=waypoints)\n    return self\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.box.distance_box","title":"<code>distance_box(box, tf_matrix)</code>","text":"<p>Return a box distance from <code>base_link</code>.</p> <p>Parameters:</p> Name Type Description Default <code>box</code> <code>BoxLike</code> <p>A box.</p> required <code>tf_matrix</code> <code>HomogeneousMatrix</code> <p>Transformation matrix.</p> required <p>Raises:</p> Type Description <code>TypeError</code> <p>Expecting type of box is <code>Box2D</code> or <code>Box3D</code>.</p> <p>Returns:</p> Type Description <code>float | None</code> <p>float | None: Return <code>None</code> if the type of box is <code>Box2D</code> and its <code>position</code> is <code>None</code>, otherwise returns distance from <code>base_link</code>.</p> Source code in <code>t4_devkit/dataclass/box.py</code> <pre><code>def distance_box(box: BoxLike, tf_matrix: HomogeneousMatrix) -&gt; float | None:\n    \"\"\"Return a box distance from `base_link`.\n\n    Args:\n        box (BoxLike): A box.\n        tf_matrix (HomogeneousMatrix): Transformation matrix.\n\n    Raises:\n        TypeError: Expecting type of box is `Box2D` or `Box3D`.\n\n    Returns:\n        float | None: Return `None` if the type of box is `Box2D` and its `position` is `None`,\n            otherwise returns distance from `base_link`.\n    \"\"\"\n    if isinstance(box, Box2D) and box.position is None:\n        return None\n\n    if isinstance(box, Box2D):\n        position = tf_matrix.transform(box.position)\n    elif isinstance(box, Box3D):\n        position, _ = tf_matrix.transform(box.position, box.rotation)\n    else:\n        raise TypeError(f\"Unexpected box type: {type(box)}\")\n\n    return np.linalg.norm(position).item()\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.LidarPointCloud","title":"<code>LidarPointCloud</code>","text":"<p>A dataclass to represent lidar pointcloud.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>NDArrayFloat</code> <p>Points matrix in the shape of (4, N).</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@define\nclass LidarPointCloud(PointCloud):\n    \"\"\"A dataclass to represent lidar pointcloud.\n\n    Attributes:\n        points (NDArrayFloat): Points matrix in the shape of (4, N).\n    \"\"\"\n\n    @staticmethod\n    def num_dims() -&gt; int:\n        return 4\n\n    @classmethod\n    def from_file(cls, filepath: str, metainfo_filepath: str | None = None) -&gt; Self:\n        assert filepath.endswith(\".bin\"), f\"Unexpected filetype: {filepath}\"\n\n        scan = np.fromfile(filepath, dtype=np.float32)\n        points = scan.reshape((-1, 5))[:, : cls.num_dims()]\n\n        metainfo = (\n            PointCloudMetainfo.from_file(metainfo_filepath)\n            if metainfo_filepath is not None\n            else None\n        )\n\n        return cls(points.T, metainfo=metainfo)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud","title":"<code>PointCloud</code>","text":"<p>Abstract base dataclass for pointcloud data.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@define\nclass PointCloud:\n    \"\"\"Abstract base dataclass for pointcloud data.\"\"\"\n\n    points: NDArrayFloat = field(converter=np.array)\n    metainfo: PointCloudMetainfo | None = field(default=None)\n\n    @points.validator\n    def _check_dims(self, attribute, value) -&gt; None:\n        if value.shape[0] != self.num_dims():\n            raise ValueError(\n                f\"Expected point dimension is {self.num_dims()}, but got {value.shape[0]}\"\n            )\n\n    @metainfo.validator\n    def _validate_metainfo(self, attribute, value) -&gt; None:\n        \"\"\"Validate that sources in metainfo form non-overlapping parts covering all points.\n\n        This validator ensures backward compatibility by allowing None metainfo.\n        \"\"\"\n        if value is None:\n            # Backward compatibility: metainfo is optional\n            return\n\n        if not value.sources:\n            # No sources to validate\n            return\n\n        num_points = self.num_points()\n\n        # Collect all intervals defined by sources\n        intervals = []\n        for source_info in value.sources:\n            source_token = source_info.sensor_token\n            idx_begin = source_info.idx_begin\n            length = source_info.length\n            idx_end = idx_begin + length\n\n            # Check bounds\n            if idx_begin &lt; 0:\n                raise ValueError(f\"Source '{source_token}' has negative idx_begin: {idx_begin}\")\n            if length &lt; 0:\n                raise ValueError(f\"Source '{source_token}' has negative length: {length}\")\n            if idx_end &gt; num_points:\n                raise ValueError(\n                    f\"Source '{source_token}' exceeds point cloud size: \"\n                    f\"idx_begin={idx_begin}, length={length}, but num_points={num_points}\"\n                )\n\n            intervals.append((idx_begin, idx_end, source_token))\n\n        # Sort intervals by start index\n        intervals.sort(key=lambda x: x[0])\n\n        # Check for non-overlapping and complete coverage\n        expected_start = 0\n        for idx_begin, idx_end, source_token in intervals:\n            if idx_begin != expected_start:\n                if idx_begin &gt; expected_start:\n                    raise ValueError(\n                        f\"Gap detected: points [{expected_start}:{idx_begin}) are not covered by any source\"\n                    )\n                else:\n                    raise ValueError(\n                        f\"Overlap detected: source '{source_token}' starts at {idx_begin}, \"\n                        f\"but previous source ends at {expected_start}\"\n                    )\n            expected_start = idx_end\n\n        # Check if all points are covered\n        if expected_start != num_points:\n            raise ValueError(\n                f\"Incomplete coverage: sources cover up to index {expected_start}, \"\n                f\"but num_points={num_points}\"\n            )\n\n    @staticmethod\n    @abstractmethod\n    def num_dims() -&gt; int:\n        \"\"\"Return the number of the point dimensions.\n\n        Returns:\n            int: The number of the point dimensions.\n        \"\"\"\n        pass\n\n    @classmethod\n    @abstractmethod\n    def from_file(cls, filepath: str) -&gt; Self:\n        \"\"\"Create an object from pointcloud file.\n\n        Args:\n            filepath (str): File path of the pointcloud file.\n\n        Returns:\n            Self instance.\n        \"\"\"\n        pass\n\n    def num_points(self) -&gt; int:\n        \"\"\"Return the number of points.\n\n        Returns:\n            int: _description_\n        \"\"\"\n        return self.points.shape[1]\n\n    def translate(self, x: NDArrayFloat) -&gt; None:\n        for i in range(3):\n            self.points[i, :] = self.points[i, :] + x[i]\n\n    def rotate(self, matrix: NDArrayFloat) -&gt; None:\n        self.points[:3, :] = np.dot(matrix, self.points[:3, :])\n\n    def transform(self, matrix: NDArrayFloat) -&gt; None:\n        self.points[:3, :] = matrix.dot(\n            np.vstack((self.points[:3, :], np.ones(self.num_points())))\n        )[:3, :]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud.from_file","title":"<code>from_file(filepath)</code>  <code>abstractmethod</code> <code>classmethod</code>","text":"<p>Create an object from pointcloud file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>File path of the pointcloud file.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Self instance.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@classmethod\n@abstractmethod\ndef from_file(cls, filepath: str) -&gt; Self:\n    \"\"\"Create an object from pointcloud file.\n\n    Args:\n        filepath (str): File path of the pointcloud file.\n\n    Returns:\n        Self instance.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud.num_dims","title":"<code>num_dims()</code>  <code>abstractmethod</code> <code>staticmethod</code>","text":"<p>Return the number of the point dimensions.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of the point dimensions.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@staticmethod\n@abstractmethod\ndef num_dims() -&gt; int:\n    \"\"\"Return the number of the point dimensions.\n\n    Returns:\n        int: The number of the point dimensions.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloud.num_points","title":"<code>num_points()</code>","text":"<p>Return the number of points.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>description</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>def num_points(self) -&gt; int:\n    \"\"\"Return the number of points.\n\n    Returns:\n        int: _description_\n    \"\"\"\n    return self.points.shape[1]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloudMetainfo","title":"<code>PointCloudMetainfo</code>","text":"<p>A dataclass to represent pointcloud metadata.</p> <p>Attributes:</p> Name Type Description <code>stamp</code> <code>Stamp</code> <p>Timestamp.</p> <code>sources</code> <code>list[PointCloudSourceInfo]</code> <p>List of source information.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@define\nclass PointCloudMetainfo:\n    \"\"\"A dataclass to represent pointcloud metadata.\n\n    Attributes:\n        stamp (Stamp): Timestamp.\n        sources (list[PointCloudSourceInfo]): List of source information.\n    \"\"\"\n\n    stamp: Stamp = field(converter=lambda x: Stamp(**x) if isinstance(x, dict) else x)\n    sources: list[PointCloudSourceInfo] = field(factory=list)\n\n    @classmethod\n    def from_file(cls, filepath: str) -&gt; Self:\n        \"\"\"Create an instance from a JSON file.\n\n        Args:\n            filepath (str): Path to the JSON file containing metadata.\n\n        Returns:\n            Self: PointCloudMetainfo instance.\n        \"\"\"\n        data = load_json(filepath)\n        stamp = Stamp(**data[\"stamp\"])\n        sources = []\n        for source_data in data.get(\"sources\", []):\n            sources.append(PointCloudSourceInfo(**source_data))\n        return cls(stamp=stamp, sources=sources)\n\n    @property\n    def source_tokens(self) -&gt; list[str]:\n        \"\"\"Get the list of source sensor tokens.\n\n        Returns:\n            list[str]: List of sensor tokens.\n        \"\"\"\n        return [source.sensor_token for source in self.sources]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloudMetainfo.source_tokens","title":"<code>source_tokens</code>  <code>property</code>","text":"<p>Get the list of source sensor tokens.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>list[str]: List of sensor tokens.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloudMetainfo.from_file","title":"<code>from_file(filepath)</code>  <code>classmethod</code>","text":"<p>Create an instance from a JSON file.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to the JSON file containing metadata.</p> required <p>Returns:</p> Name Type Description <code>Self</code> <code>Self</code> <p>PointCloudMetainfo instance.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@classmethod\ndef from_file(cls, filepath: str) -&gt; Self:\n    \"\"\"Create an instance from a JSON file.\n\n    Args:\n        filepath (str): Path to the JSON file containing metadata.\n\n    Returns:\n        Self: PointCloudMetainfo instance.\n    \"\"\"\n    data = load_json(filepath)\n    stamp = Stamp(**data[\"stamp\"])\n    sources = []\n    for source_data in data.get(\"sources\", []):\n        sources.append(PointCloudSourceInfo(**source_data))\n    return cls(stamp=stamp, sources=sources)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.PointCloudSourceInfo","title":"<code>PointCloudSourceInfo</code>","text":"<p>A dataclass to represent pointcloud source information.</p> <p>Attributes:</p> Name Type Description <code>sensor_token</code> <code>str</code> <p>source sensor identifier. References token field from Sensor table.</p> <code>idx_begin</code> <code>int</code> <p>Begin index of points for the source in the concatenated pointcloud structure.</p> <code>length</code> <code>int</code> <p>Length of points for the source in the concatenated pointcloud structure.</p> <code>stamp</code> <code>Stamp</code> <p>Timestamp.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@define\nclass PointCloudSourceInfo:\n    \"\"\"A dataclass to represent pointcloud source information.\n\n    Attributes:\n        sensor_token (str): source sensor identifier. References token field from Sensor table.\n        idx_begin (int): Begin index of points for the source in the concatenated pointcloud structure.\n        length (int): Length of points for the source in the concatenated pointcloud structure.\n        stamp (Stamp): Timestamp.\n    \"\"\"\n\n    sensor_token: str\n    idx_begin: int\n    length: int\n    stamp: Stamp = field(converter=lambda x: Stamp(**x) if isinstance(x, dict) else x)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.RadarPointCloud","title":"<code>RadarPointCloud</code>","text":"<p>A dataclass to represent radar pointcloud.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>NDArrayFloat</code> <p>Points matrix in the shape of (18, N).</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@define\nclass RadarPointCloud(PointCloud):\n    \"\"\"A dataclass to represent radar pointcloud.\n\n    Attributes:\n        points (NDArrayFloat): Points matrix in the shape of (18, N).\n    \"\"\"\n\n    # class variables\n    invalid_states: ClassVar[list[int]] = [0]\n    dynprop_states: ClassVar[list[int]] = list(range(7))\n    ambig_states: ClassVar[list[int]] = [3]\n\n    @staticmethod\n    def num_dims() -&gt; int:\n        return 18\n\n    @classmethod\n    def from_file(\n        cls,\n        filepath: str,\n        invalid_states: list[int] | None = None,\n        dynprop_states: list[int] | None = None,\n        ambig_states: list[int] | None = None,\n        metainfo_filepath: str | None = None,\n    ) -&gt; Self:\n        assert filepath.endswith(\".pcd\"), f\"Unexpected filetype: {filepath}\"\n\n        metadata: list[str] = []\n        with open(filepath, \"rb\") as f:\n            for line in f:\n                line = line.strip().decode(\"utf-8\")\n                metadata.append(line)\n                if line.startswith(\"DATA\"):\n                    break\n\n            data_binary = f.read()\n\n        # Get the header rows and check if they appear as expected.\n        assert metadata[0].startswith(\"#\"), \"First line must be comment\"\n        assert metadata[1].startswith(\"VERSION\"), \"Second line must be VERSION\"\n        sizes = metadata[3].split(\" \")[1:]\n        types = metadata[4].split(\" \")[1:]\n        counts = metadata[5].split(\" \")[1:]\n        width = int(metadata[6].split(\" \")[1])\n        height = int(metadata[7].split(\" \")[1])\n        data = metadata[10].split(\" \")[1]\n        feature_count = len(types)\n        assert width &gt; 0\n        assert len([c for c in counts if c != c]) == 0, \"Error: COUNT not supported!\"\n        assert height == 1, \"Error: height != 0 not supported!\"\n        assert data == \"binary\"\n\n        # Lookup table for how to decode the binaries.\n        unpacking_lut = {\n            \"F\": {2: \"e\", 4: \"f\", 8: \"d\"},\n            \"I\": {1: \"b\", 2: \"h\", 4: \"i\", 8: \"q\"},\n            \"U\": {1: \"B\", 2: \"H\", 4: \"I\", 8: \"Q\"},\n        }\n        types_str = \"\".join([unpacking_lut[t][int(s)] for t, s in zip(types, sizes)])\n\n        # Decode each point.\n        offset = 0\n        point_count = width\n        points = []\n        for i in range(point_count):\n            point = []\n            for p in range(feature_count):\n                start_p = offset\n                end_p = start_p + int(sizes[p])\n                assert end_p &lt; len(data_binary)\n                point_p = struct.unpack(types_str[p], data_binary[start_p:end_p])[0]\n                point.append(point_p)\n                offset = end_p\n            points.append(point)\n\n        # A NaN in the first point indicates an empty pointcloud.\n        point = np.array(points[0])\n        if np.any(np.isnan(point)):\n            metainfo = (\n                PointCloudMetainfo.from_file(metainfo_filepath)\n                if metainfo_filepath is not None\n                else None\n            )\n            return cls(np.zeros((feature_count, 0)), metainfo=metainfo)\n\n        # Convert to numpy matrix.\n        points = np.array(points).transpose()\n\n        # If no parameters are provided, use default settings.\n        invalid_states = cls.invalid_states if invalid_states is None else invalid_states\n        dynprop_states = cls.dynprop_states if dynprop_states is None else dynprop_states\n        ambig_states = cls.ambig_states if ambig_states is None else ambig_states\n\n        # Filter points with an invalid state.\n        valid = [p in invalid_states for p in points[-4, :]]\n        points = points[:, valid]\n\n        # Filter by dynProp.\n        valid = [p in dynprop_states for p in points[3, :]]\n        points = points[:, valid]\n\n        # Filter by ambig_state.\n        valid = [p in ambig_states for p in points[11, :]]\n        points = points[:, valid]\n\n        metainfo = (\n            PointCloudMetainfo.from_file(metainfo_filepath)\n            if metainfo_filepath is not None\n            else None\n        )\n        return cls(points, metainfo=metainfo)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.SegmentationPointCloud","title":"<code>SegmentationPointCloud</code>","text":"<p>A dataclass to represent segmentation pointcloud.</p> <p>Attributes:</p> Name Type Description <code>points</code> <code>NDArrayFloat</code> <p>Points matrix in the shape of (4, N).</p> <code>labels</code> <code>NDArrayU8</code> <p>Label matrix.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@define\nclass SegmentationPointCloud(PointCloud):\n    \"\"\"A dataclass to represent segmentation pointcloud.\n\n    Attributes:\n        points (NDArrayFloat): Points matrix in the shape of (4, N).\n        labels (NDArrayU8): Label matrix.\n    \"\"\"\n\n    labels: NDArrayU8 = field(converter=lambda x: np.array(x, dtype=np.uint8), kw_only=True)\n\n    @staticmethod\n    def num_dims() -&gt; int:\n        return 4\n\n    @classmethod\n    def from_file(\n        cls, point_filepath: str, label_filepath: str, metainfo_filepath: str | None = None\n    ) -&gt; Self:\n        scan = np.fromfile(point_filepath, dtype=np.float32)\n        points = scan.reshape((-1, 5))[:, : cls.num_dims()]\n        labels = np.fromfile(label_filepath, dtype=np.uint8)\n        metainfo = (\n            PointCloudMetainfo.from_file(metainfo_filepath)\n            if metainfo_filepath is not None\n            else None\n        )\n        return cls(points.T, labels=labels, metainfo=metainfo)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.Stamp","title":"<code>Stamp</code>","text":"<p>A dataclass to represent timestamp.</p> <p>Attributes:</p> Name Type Description <code>sec</code> <code>int</code> <p>Seconds.</p> <code>nanosec</code> <code>int</code> <p>Nanoseconds.</p> Source code in <code>t4_devkit/dataclass/pointcloud.py</code> <pre><code>@define\nclass Stamp:\n    \"\"\"A dataclass to represent timestamp.\n\n    Attributes:\n        sec (int): Seconds.\n        nanosec (int): Nanoseconds.\n    \"\"\"\n\n    sec: int\n    nanosec: int\n\n    @property\n    def in_seconds(self) -&gt; float:\n        \"\"\"Convert timestamp to seconds as a float.\n\n        Returns:\n            float: Timestamp in seconds.\n        \"\"\"\n        return self.sec + self.nanosec * 1e-9\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.pointcloud.Stamp.in_seconds","title":"<code>in_seconds</code>  <code>property</code>","text":"<p>Convert timestamp to seconds as a float.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>Timestamp in seconds.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.shape.Shape","title":"<code>Shape</code>","text":"<p>A dataclass to represent the 3D box shape.</p> <p>Attributes:</p> Name Type Description <code>shape_type</code> <code>ShapeType</code> <p>Box shape type.</p> <code>size</code> <code>Vector3</code> <p>Box size in the order of (width, length, height).</p> <code>footprint</code> <code>Polygon</code> <p>Polygon of footprint.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; shape = Shape(\n...     shape_type=ShapeType.BOUNDING_BOX,\n...     size=[1.0, 1.0, 1.0]\n... )\n</code></pre> Source code in <code>t4_devkit/dataclass/shape.py</code> <pre><code>@define\nclass Shape:\n    \"\"\"A dataclass to represent the 3D box shape.\n\n    Attributes:\n        shape_type (ShapeType): Box shape type.\n        size (Vector3): Box size in the order of (width, length, height).\n        footprint (Polygon): Polygon of footprint.\n\n    Examples:\n        &gt;&gt;&gt; shape = Shape(\n        ...     shape_type=ShapeType.BOUNDING_BOX,\n        ...     size=[1.0, 1.0, 1.0]\n        ... )\n    \"\"\"\n\n    shape_type: ShapeType\n    size: Vector3 = field(converter=Vector3)\n    footprint: Polygon = field(default=None)\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.shape_type == ShapeType.POLYGON and self.footprint is None:\n            raise ValueError(\"`footprint` must be specified for `POLYGON`.\")\n\n        if self.footprint is None:\n            self.footprint = _calculate_footprint(self.size)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.shape.ShapeType","title":"<code>ShapeType</code>","text":"<p>               Bases: <code>Enum</code></p> Source code in <code>t4_devkit/dataclass/shape.py</code> <pre><code>@unique\nclass ShapeType(Enum):\n    BOUNDING_BOX = 0\n    POLYGON = auto()\n\n    @classmethod\n    def from_name(cls, name: str) -&gt; Self:\n        \"\"\"Return an enum object from the name of the member.\n\n        Args:\n            name (str): Name of enum member.\n\n        Returns:\n            Enum object.\n        \"\"\"\n        name = name.upper()\n        assert name in cls.__members__, f\"Unexpected shape type: {name}.\"\n        return cls.__members__[name]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.shape.ShapeType.from_name","title":"<code>from_name(name)</code>  <code>classmethod</code>","text":"<p>Return an enum object from the name of the member.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of enum member.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Enum object.</p> Source code in <code>t4_devkit/dataclass/shape.py</code> <pre><code>@classmethod\ndef from_name(cls, name: str) -&gt; Self:\n    \"\"\"Return an enum object from the name of the member.\n\n    Args:\n        name (str): Name of enum member.\n\n    Returns:\n        Enum object.\n    \"\"\"\n    name = name.upper()\n    assert name in cls.__members__, f\"Unexpected shape type: {name}.\"\n    return cls.__members__[name]\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.Future","title":"<code>Future</code>","text":"<p>               Bases: <code>ObjectPath</code></p> <p>Represent the future trajectory features.</p> <p>Note that the expected shape of waypoints is (M, T, D).</p> <p>Attributes:</p> Name Type Description <code>timestamps</code> <code>NDArrayInt</code> <p>Sequence of timestamps (T,).</p> <code>confidences</code> <code>NDArrayFloat</code> <p>Confidences array for each mode (M,).</p> <code>waypoints</code> <code>Trajectory</code> <p>Waypoints matrix in the shape of (M, T, 3).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; future = Future(\n...     timestamps=[1.0, 2.0]\n...     confidences=[1.0],\n...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]],\n... )\n# Get the number of modes.\n&gt;&gt;&gt; len(future)\n1\n# Access the shape of waypoints matrix: (M, T, 3).\n&gt;&gt;&gt; future.shape\n(1, 2, 3)\n# Access waypoints as subscriptable.\n&gt;&gt;&gt; future[0] # for mode0\narray([[1., 1., 1.],\n       [2., 2., 2.]])\n&gt;&gt;&gt; future[0, 0] # point0 at mode0\narray([1., 1., 1.])\n# Access confidence and waypoints for each mode as iterable.\n&gt;&gt;&gt; for i, (timestamp, confidence, waypoints) in future:\n...     print(f\"Mode{i}: {timestamp}, {confidence}, {waypoints}\")\n...\nMode0: 1.0, 1.0, [[1. 1. 1.] [2. 2. 2.]]\n</code></pre> Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>@define\nclass Future(ObjectPath):\n    \"\"\"Represent the future trajectory features.\n\n    Note that the expected shape of waypoints is (M, T, D).\n\n    Attributes:\n        timestamps (NDArrayInt): Sequence of timestamps (T,).\n        confidences (NDArrayFloat): Confidences array for each mode (M,).\n        waypoints (Trajectory): Waypoints matrix in the shape of (M, T, 3).\n\n    Examples:\n        &gt;&gt;&gt; future = Future(\n        ...     timestamps=[1.0, 2.0]\n        ...     confidences=[1.0],\n        ...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]],\n        ... )\n        # Get the number of modes.\n        &gt;&gt;&gt; len(future)\n        1\n        # Access the shape of waypoints matrix: (M, T, 3).\n        &gt;&gt;&gt; future.shape\n        (1, 2, 3)\n        # Access waypoints as subscriptable.\n        &gt;&gt;&gt; future[0] # for mode0\n        array([[1., 1., 1.],\n               [2., 2., 2.]])\n        &gt;&gt;&gt; future[0, 0] # point0 at mode0\n        array([1., 1., 1.])\n        # Access confidence and waypoints for each mode as iterable.\n        &gt;&gt;&gt; for i, (timestamp, confidence, waypoints) in future:\n        ...     print(f\"Mode{i}: {timestamp}, {confidence}, {waypoints}\")\n        ...\n        Mode0: 1.0, 1.0, [[1. 1. 1.] [2. 2. 2.]]\n    \"\"\"\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath","title":"<code>ObjectPath</code>","text":"<p>A dataclass to represent object path including timestamps, confidences, and waypoints.</p> Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>@define\nclass ObjectPath:\n    \"\"\"A dataclass to represent object path including timestamps, confidences, and waypoints.\"\"\"\n\n    timestamps: NDArrayInt = field(converter=np.array)\n    confidences: NDArrayFloat = field(\n        converter=np.array,\n        validator=validators.deep_iterable((validators.ge(0.0), validators.le(1.0))),\n    )\n    waypoints: Trajectory = field(converter=Trajectory)\n\n    def __attrs_post_init__(self) -&gt; None:\n        self._check_dims()\n\n    def _check_dims(self) -&gt; None:\n        # check timestamp length between timestamps and waypoints\n        if len(self.timestamps) != self.waypoints.shape[1]:\n            raise ValueError(\n                \"Timestamp length must be the same between `timestamps` and `waypoints`, \"\n                f\"but got timestamps={len(self.timestamps)} and waypoints={self.waypoints.shape[1]}\"\n            )\n\n        # check mode length between waypoints and confidences\n        if self.waypoints.shape[0] != len(self.confidences):\n            raise ValueError(\n                \"Mode length must be the same between `waypoints` and `confidences`, \"\n                f\"but got waypoints={self.waypoints.shape[0]} and confidences={len(self.confidences)}\"\n            )\n\n    def __len__(self) -&gt; int:\n        \"\"\"Return the number of modes.\"\"\"\n        return len(self.waypoints)\n\n    def __getitem__(self, index: int | slice[int]) -&gt; NDArrayFloat:\n        return self.waypoints[index]\n\n    def __iter__(self) -&gt; Generator[tuple[float, NDArrayFloat]]:\n        yield from zip(self.confidences, self.waypoints, strict=True)\n\n    @property\n    def num_mode(self) -&gt; int:\n        \"\"\"Return the number of trajectory modes.\n\n        Returns:\n            int: The number of trajectory modes.\n        \"\"\"\n        return self.shape[0]\n\n    @property\n    def num_timestamp(self) -&gt; int:\n        \"\"\"Return the number of timestamps.\n\n        Returns:\n            int: The number of timestamps.\n        \"\"\"\n        return self.shape[1]\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Return the shape of the waypoints matrix.\n\n        Returns:\n            Shape of the matrix (M, T, D).\n        \"\"\"\n        return self.waypoints.shape\n\n    def translate(self, x: Vector3Like) -&gt; None:\n        \"\"\"Apply a translation.\n\n        Args:\n            x (Vector3Like): 3D translation vector.\n        \"\"\"\n        self.waypoints += Vector3(x)\n\n    def rotate(self, q: RotationLike) -&gt; None:\n        \"\"\"Apply a rotation.\n\n        Args:\n            q (RotationLike): Rotation quaternion.\n        \"\"\"\n        # NOTE: R * X = X * R^T\n        q = to_quaternion(q)\n        self.waypoints = np.dot(self.waypoints, q.rotation_matrix.T)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.num_mode","title":"<code>num_mode</code>  <code>property</code>","text":"<p>Return the number of trajectory modes.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of trajectory modes.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.num_timestamp","title":"<code>num_timestamp</code>  <code>property</code>","text":"<p>Return the number of timestamps.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of timestamps.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Return the shape of the waypoints matrix.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>Shape of the matrix (M, T, D).</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.__len__","title":"<code>__len__()</code>","text":"<p>Return the number of modes.</p> Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"Return the number of modes.\"\"\"\n    return len(self.waypoints)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.rotate","title":"<code>rotate(q)</code>","text":"<p>Apply a rotation.</p> <p>Parameters:</p> Name Type Description Default <code>q</code> <code>RotationLike</code> <p>Rotation quaternion.</p> required Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>def rotate(self, q: RotationLike) -&gt; None:\n    \"\"\"Apply a rotation.\n\n    Args:\n        q (RotationLike): Rotation quaternion.\n    \"\"\"\n    # NOTE: R * X = X * R^T\n    q = to_quaternion(q)\n    self.waypoints = np.dot(self.waypoints, q.rotation_matrix.T)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.ObjectPath.translate","title":"<code>translate(x)</code>","text":"<p>Apply a translation.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>Vector3Like</code> <p>3D translation vector.</p> required Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>def translate(self, x: Vector3Like) -&gt; None:\n    \"\"\"Apply a translation.\n\n    Args:\n        x (Vector3Like): 3D translation vector.\n    \"\"\"\n    self.waypoints += Vector3(x)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.trajectory.Past","title":"<code>Past</code>","text":"<p>               Bases: <code>ObjectPath</code></p> <p>Represent the past trajectory features.</p> <p>Note that the expected shape of waypoints is (1, T, D).</p> <p>Attributes:</p> Name Type Description <code>timestamps</code> <code>NDArrayInt</code> <p>Sequence of timestamps (T,).</p> <code>confidences</code> <code>NDArrayFloat</code> <p>Confidences array for the mode (1,).</p> <code>waypoints</code> <code>Trajectory</code> <p>Waypoints matrix in the shape of (1, T, 3).</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; past = Past(\n...     timestamps=[1.0, 2.0]\n...     confidences=[1.0],\n...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]],\n... )\n# Get the number of modes.\n&gt;&gt;&gt; len(past)\n1\n# Access the shape of waypoints matrix: (M, T, 3).\n&gt;&gt;&gt; past.shape\n(1, 2, 3)\n# Access waypoints as subscriptable.\n&gt;&gt;&gt; past[0] # for mode0\narray([[1., 1., 1.],\n       [2., 2., 2.]])\n&gt;&gt;&gt; past[0, 0] # point0 at mode0\narray([1., 1., 1.])\n# Access confidence and waypoints for each mode as iterable.\n&gt;&gt;&gt; for i, (timestamp, confidence, waypoints) in past:\n...     print(f\"Mode{i}: {timestamp}, {confidence}, {waypoints}\")\n...\nMode0: 1.0, 1.0, [[1. 1. 1.] [2. 2. 2.]]\n</code></pre> Source code in <code>t4_devkit/dataclass/trajectory.py</code> <pre><code>@define\nclass Past(ObjectPath):\n    \"\"\"Represent the past trajectory features.\n\n    Note that the expected shape of waypoints is (1, T, D).\n\n    Attributes:\n        timestamps (NDArrayInt): Sequence of timestamps (T,).\n        confidences (NDArrayFloat): Confidences array for the mode (1,).\n        waypoints (Trajectory): Waypoints matrix in the shape of (1, T, 3).\n\n    Examples:\n        &gt;&gt;&gt; past = Past(\n        ...     timestamps=[1.0, 2.0]\n        ...     confidences=[1.0],\n        ...     waypoints=[[[1.0, 1.0, 1.0], [2.0, 2.0, 2.0]]],\n        ... )\n        # Get the number of modes.\n        &gt;&gt;&gt; len(past)\n        1\n        # Access the shape of waypoints matrix: (M, T, 3).\n        &gt;&gt;&gt; past.shape\n        (1, 2, 3)\n        # Access waypoints as subscriptable.\n        &gt;&gt;&gt; past[0] # for mode0\n        array([[1., 1., 1.],\n               [2., 2., 2.]])\n        &gt;&gt;&gt; past[0, 0] # point0 at mode0\n        array([1., 1., 1.])\n        # Access confidence and waypoints for each mode as iterable.\n        &gt;&gt;&gt; for i, (timestamp, confidence, waypoints) in past:\n        ...     print(f\"Mode{i}: {timestamp}, {confidence}, {waypoints}\")\n        ...\n        Mode0: 1.0, 1.0, [[1. 1. 1.] [2. 2. 2.]]\n    \"\"\"\n\n    def _check_dims(self) -&gt; None:\n        super()._check_dims()\n\n        if self.num_mode != 1:\n            raise ValueError(f\"The number of modes for past must be 1, but got {self.num_mode}\")\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix","title":"<code>HomogeneousMatrix</code>","text":"Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>@define\nclass HomogeneousMatrix:\n    position: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    src: str = field(validator=validators.instance_of(str))\n    dst: str = field(validator=validators.instance_of(str))\n    matrix: Matrix4x4 = field(init=False)\n\n    def __attrs_post_init__(self) -&gt; None:\n        self.matrix = _generate_homogeneous_matrix(self.position, self.rotation)\n\n    @classmethod\n    def as_identity(cls, frame_id: str) -&gt; Self:\n        \"\"\"Construct a new object with identity.\n\n        Args:\n            frame_id (str): Frame ID.\n\n        Returns:\n            Constructed self instance.\n        \"\"\"\n        return cls(np.zeros(3), Quaternion(), frame_id, frame_id)\n\n    @classmethod\n    def from_matrix(\n        cls,\n        matrix: Matrix4x4Like | HomogeneousMatrix,\n        src: str | None = None,\n        dst: str | None = None,\n    ) -&gt; Self:\n        \"\"\"Construct a new object from a homogeneous matrix.\n\n        Args:\n            matrix (Matrix4x4Like | HomogeneousMatrix): 4x4 homogeneous matrix.\n            src (str | None, optional): Source frame ID.\n                This must be specified only if the input matrix is `Matrix4x4Like`.\n            dst (str | None, optional): Destination frame ID.\n                This must be specified only if the input matrix is `Matrix4x4Like`.\n\n        Returns:\n            Constructed self instance.\n        \"\"\"\n        position, rotation = _extract_position_and_rotation_from_matrix(matrix)\n        if isinstance(matrix, np.ndarray):\n            assert matrix.shape == (4, 4)\n            assert src is not None and dst is not None\n            return cls(position, rotation, src, dst)\n        else:\n            return cls(position, rotation, matrix.src, matrix.dst)\n\n    @property\n    def shape(self) -&gt; tuple[int, ...]:\n        \"\"\"Return a shape of the homogeneous matrix.\n\n        Returns:\n            Return the shape of (4, 4).\n        \"\"\"\n        return self.matrix.shape\n\n    @property\n    def yaw_pitch_roll(self) -&gt; tuple[float, float, float]:\n        \"\"\"Return yaw, pitch and roll.\n\n        NOTE:\n            yaw: Rotation angle around the z-axis in [rad], in the range `[-pi, pi]`.\n            pitch: Rotation angle around the y'-axis in [rad], in the range `[-pi/2, pi/2]`.\n            roll: Rotation angle around the x\"-axis in [rad], in the range `[-pi, pi]`.\n\n        Returns:\n            Yaw, pitch and roll in [rad].\n        \"\"\"\n        return self.rotation.yaw_pitch_roll\n\n    @property\n    def rotation_matrix(self) -&gt; Matrix3x3:\n        \"\"\"Return a 3x3 rotation matrix.\n\n        Returns:\n            3x3 rotation matrix.\n        \"\"\"\n        return self.rotation.rotation_matrix\n\n    def dot(self, other: HomogeneousMatrix) -&gt; HomogeneousMatrix:\n        \"\"\"Return a dot product of myself and another.\n\n        Args:\n            other (HomogeneousMatrix): `HomogeneousMatrix` object.\n\n        Raises:\n            ValueError: `self.src` and `other.dst` must be the same frame ID.\n\n        Returns:\n            Result of a dot product.\n        \"\"\"\n        if self.src != other.dst:\n            raise ValueError(f\"self.src != other.dst: self.src={self.src}, other.dst={other.dst}\")\n\n        ret_mat = self.matrix.dot(other.matrix)\n        position, rotation = _extract_position_and_rotation_from_matrix(ret_mat)\n        return HomogeneousMatrix(position, rotation, src=other.src, dst=self.dst)\n\n    def inv(self) -&gt; HomogeneousMatrix:\n        \"\"\"Return a inverse matrix of myself.\n\n        Returns:\n            Inverse matrix.\n        \"\"\"\n        ret_mat = np.linalg.inv(self.matrix)\n        position, rotation = _extract_position_and_rotation_from_matrix(ret_mat)\n        return HomogeneousMatrix(position, rotation, src=self.src, dst=self.dst)\n\n    @overload\n    def translate(self, position: Vector3Like) -&gt; Vector3:\n        \"\"\"Translate a position by myself.\n\n        Args:\n            position (Vector3Like): 3D position.\n\n        Returns:\n            Translated position.\n        \"\"\"\n        pass\n\n    @overload\n    def translate(self, matrix: HomogeneousMatrix) -&gt; HomogeneousMatrix:\n        \"\"\"Translate a homogeneous matrix by myself.\n\n        Args:\n            matrix (HomogeneousMatrix):\n\n        Returns:\n            Translated `HomogeneousMatrix` object.\n        \"\"\"\n        pass\n\n    def translate(self, *args, **kwargs) -&gt; TranslateItemLike:\n        inputs = _format_transform_args(*args, **kwargs)\n        if {\"position\"} == set(inputs.keys()):\n            return self.position + inputs[\"position\"]\n        elif {\"matrix\"} == set(inputs.keys()):\n            matrix: HomogeneousMatrix = deepcopy(inputs[\"matrix\"])\n            matrix.position = self.position + matrix.position\n            return matrix\n        else:\n            raise ValueError(f\"Unexpected arguments: {list(inputs.keys())}\")\n\n    @overload\n    def rotate(self, position: Vector3Like) -&gt; Vector3:\n        \"\"\"Rotate a position by myself.\n\n        Args:\n            position (Vector3Like): 3D position.\n\n        Returns:\n            Rotated position.\n        \"\"\"\n        pass\n\n    @overload\n    def rotate(self, rotation: RotationLike) -&gt; Quaternion:\n        \"\"\"Rotate a 3x3 rotation matrix or quaternion by myself.\n\n        Args:\n            rotation (RotationLike): 3x3 rotation matrix or quaternion.\n\n        Returns:\n            Rotated quaternion.\n        \"\"\"\n        pass\n\n    @overload\n    def rotate(self, matrix: HomogeneousMatrix) -&gt; HomogeneousMatrix:\n        \"\"\"Rotate a homogeneous matrix by myself.\n\n        Args:\n            matrix (HomogeneousMatrix): `HomogeneousMatrix` object.\n\n        Returns:\n            Rotated `HomogeneousMatrix` object.\n        \"\"\"\n        pass\n\n    def rotate(self, *args, **kwargs) -&gt; RotateItemLike:\n        inputs = _format_transform_args(*args, **kwargs)\n        if {\"position\"} == set(inputs.keys()):\n            return np.matmul(self.rotation_matrix, inputs[\"position\"])\n        elif {\"rotation\"} == set(inputs.keys()):\n            return np.matmul(self.rotation_matrix, inputs[\"rotation\"].rotation_matrix)\n        elif {\"matrix\"} == set(inputs.keys()):\n            matrix: HomogeneousMatrix = deepcopy(inputs[\"matrix\"])\n            matrix.rotation = Quaternion(\n                matrix=np.matmul(self.rotation_matrix, matrix.rotation_matrix)\n            )\n            return matrix\n        else:\n            raise ValueError(f\"Unexpected arguments: {list(inputs.keys())}\")\n\n    @overload\n    def transform(self, position: Vector3Like) -&gt; Vector3:\n        \"\"\"Transform a position by myself.\n\n        Args:\n            position (ArrayLike): 3D position.\n\n        Returns:\n            Transformed position.\n        \"\"\"\n        pass\n\n    @overload\n    def transform(self, rotation: RotationLike) -&gt; Quaternion:\n        \"\"\"Transform a rotation by myself.\n\n        Args:\n            rotation (RotationLike): 3x3 rotation matrix or quaternion.\n\n        Returns:\n            Transformed quaternion.\n        \"\"\"\n        pass\n\n    @overload\n    def transform(\n        self,\n        position: Vector3Like,\n        rotation: RotationLike,\n    ) -&gt; tuple[Vector3, Quaternion]:\n        \"\"\"Transform position and rotation by myself.\n\n        Args:\n            position (Vector3Like): 3D position.\n            rotation (RotationLike): 3x3 rotation matrix or quaternion.\n\n        Returns:\n            Transformed position and quaternion.\n        \"\"\"\n        pass\n\n    @overload\n    def transform(self, matrix: HomogeneousMatrix) -&gt; HomogeneousMatrix:\n        \"\"\"Transform a homogeneous matrix by myself.\n\n        Args:\n            matrix (HomogeneousMatrix): `HomogeneousMatrix` object.\n\n        Returns:\n            Transformed `HomogeneousMatrix` object.\n        \"\"\"\n        pass\n\n    def transform(self, *args, **kwargs) -&gt; TransformItemLike:\n        inputs = _format_transform_args(*args, **kwargs)\n        if {\"position\", \"rotation\"} == set(inputs.keys()):\n            return self.__transform_position_and_rotation(**inputs)\n        elif {\"position\"} == set(inputs.keys()):\n            return self.__transform_position(**inputs)\n        elif {\"rotation\"} == set(inputs.keys()):\n            return self.__transform_rotation(**inputs)\n        elif {\"matrix\"} == set(inputs.keys()):\n            return self.__transform_matrix(**inputs)\n        else:\n            raise ValueError(f\"Unexpected inputs: {list(inputs.keys())}\")\n\n    def __transform_position(self, position: Vector3Like) -&gt; Vector3:\n        rotation = Quaternion()\n        matrix = _generate_homogeneous_matrix(position, rotation)\n        ret_mat = self.matrix.dot(matrix)\n        ret_pos, _ = _extract_position_and_rotation_from_matrix(ret_mat)\n        return ret_pos\n\n    def __transform_rotation(self, rotation: RotationLike) -&gt; Quaternion:\n        position = np.zeros(3)\n        matrix = _generate_homogeneous_matrix(position, rotation)\n        ret_mat = self.matrix.dot(matrix)\n        _, ret_rot = _extract_position_and_rotation_from_matrix(ret_mat)\n        return ret_rot\n\n    def __transform_position_and_rotation(\n        self,\n        position: Vector3Like,\n        rotation: RotationLike,\n    ) -&gt; tuple[Vector3, Quaternion]:\n        matrix = _generate_homogeneous_matrix(position, rotation)\n        ret_mat = self.matrix.dot(matrix)\n        return _extract_position_and_rotation_from_matrix(ret_mat)\n\n    def __transform_matrix(self, matrix: HomogeneousMatrix) -&gt; HomogeneousMatrix:\n        return matrix.dot(self)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.rotation_matrix","title":"<code>rotation_matrix</code>  <code>property</code>","text":"<p>Return a 3x3 rotation matrix.</p> <p>Returns:</p> Type Description <code>Matrix3x3</code> <p>3x3 rotation matrix.</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.shape","title":"<code>shape</code>  <code>property</code>","text":"<p>Return a shape of the homogeneous matrix.</p> <p>Returns:</p> Type Description <code>tuple[int, ...]</code> <p>Return the shape of (4, 4).</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.yaw_pitch_roll","title":"<code>yaw_pitch_roll</code>  <code>property</code>","text":"<p>Return yaw, pitch and roll.</p> NOTE <p>yaw: Rotation angle around the z-axis in [rad], in the range <code>[-pi, pi]</code>. pitch: Rotation angle around the y'-axis in [rad], in the range <code>[-pi/2, pi/2]</code>. roll: Rotation angle around the x\"-axis in [rad], in the range <code>[-pi, pi]</code>.</p> <p>Returns:</p> Type Description <code>tuple[float, float, float]</code> <p>Yaw, pitch and roll in [rad].</p>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.as_identity","title":"<code>as_identity(frame_id)</code>  <code>classmethod</code>","text":"<p>Construct a new object with identity.</p> <p>Parameters:</p> Name Type Description Default <code>frame_id</code> <code>str</code> <p>Frame ID.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>Constructed self instance.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>@classmethod\ndef as_identity(cls, frame_id: str) -&gt; Self:\n    \"\"\"Construct a new object with identity.\n\n    Args:\n        frame_id (str): Frame ID.\n\n    Returns:\n        Constructed self instance.\n    \"\"\"\n    return cls(np.zeros(3), Quaternion(), frame_id, frame_id)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.dot","title":"<code>dot(other)</code>","text":"<p>Return a dot product of myself and another.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>HomogeneousMatrix</code> <p><code>HomogeneousMatrix</code> object.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p><code>self.src</code> and <code>other.dst</code> must be the same frame ID.</p> <p>Returns:</p> Type Description <code>HomogeneousMatrix</code> <p>Result of a dot product.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def dot(self, other: HomogeneousMatrix) -&gt; HomogeneousMatrix:\n    \"\"\"Return a dot product of myself and another.\n\n    Args:\n        other (HomogeneousMatrix): `HomogeneousMatrix` object.\n\n    Raises:\n        ValueError: `self.src` and `other.dst` must be the same frame ID.\n\n    Returns:\n        Result of a dot product.\n    \"\"\"\n    if self.src != other.dst:\n        raise ValueError(f\"self.src != other.dst: self.src={self.src}, other.dst={other.dst}\")\n\n    ret_mat = self.matrix.dot(other.matrix)\n    position, rotation = _extract_position_and_rotation_from_matrix(ret_mat)\n    return HomogeneousMatrix(position, rotation, src=other.src, dst=self.dst)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.from_matrix","title":"<code>from_matrix(matrix, src=None, dst=None)</code>  <code>classmethod</code>","text":"<p>Construct a new object from a homogeneous matrix.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>Matrix4x4Like | HomogeneousMatrix</code> <p>4x4 homogeneous matrix.</p> required <code>src</code> <code>str | None</code> <p>Source frame ID. This must be specified only if the input matrix is <code>Matrix4x4Like</code>.</p> <code>None</code> <code>dst</code> <code>str | None</code> <p>Destination frame ID. This must be specified only if the input matrix is <code>Matrix4x4Like</code>.</p> <code>None</code> <p>Returns:</p> Type Description <code>Self</code> <p>Constructed self instance.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>@classmethod\ndef from_matrix(\n    cls,\n    matrix: Matrix4x4Like | HomogeneousMatrix,\n    src: str | None = None,\n    dst: str | None = None,\n) -&gt; Self:\n    \"\"\"Construct a new object from a homogeneous matrix.\n\n    Args:\n        matrix (Matrix4x4Like | HomogeneousMatrix): 4x4 homogeneous matrix.\n        src (str | None, optional): Source frame ID.\n            This must be specified only if the input matrix is `Matrix4x4Like`.\n        dst (str | None, optional): Destination frame ID.\n            This must be specified only if the input matrix is `Matrix4x4Like`.\n\n    Returns:\n        Constructed self instance.\n    \"\"\"\n    position, rotation = _extract_position_and_rotation_from_matrix(matrix)\n    if isinstance(matrix, np.ndarray):\n        assert matrix.shape == (4, 4)\n        assert src is not None and dst is not None\n        return cls(position, rotation, src, dst)\n    else:\n        return cls(position, rotation, matrix.src, matrix.dst)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.HomogeneousMatrix.inv","title":"<code>inv()</code>","text":"<p>Return a inverse matrix of myself.</p> <p>Returns:</p> Type Description <code>HomogeneousMatrix</code> <p>Inverse matrix.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def inv(self) -&gt; HomogeneousMatrix:\n    \"\"\"Return a inverse matrix of myself.\n\n    Returns:\n        Inverse matrix.\n    \"\"\"\n    ret_mat = np.linalg.inv(self.matrix)\n    position, rotation = _extract_position_and_rotation_from_matrix(ret_mat)\n    return HomogeneousMatrix(position, rotation, src=self.src, dst=self.dst)\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer","title":"<code>TransformBuffer</code>","text":"<p>A buffer class to store transformation matrices.</p> <p>Attributes:</p> Name Type Description <code>buffer</code> <code>dict[tuple[str, str], HomogeneousMatrix]</code> <p>Matrix buffer whose key is <code>(src, dst)</code>.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>@define\nclass TransformBuffer:\n    \"\"\"A buffer class to store transformation matrices.\n\n    Attributes:\n        buffer (dict[tuple[str, str], HomogeneousMatrix]): Matrix buffer whose key is `(src, dst)`.\n    \"\"\"\n\n    buffer: dict[tuple[str, str], HomogeneousMatrix] = field(factory=dict, init=False)\n\n    def set_transform(self, matrix: HomogeneousMatrix) -&gt; None:\n        \"\"\"Set transform matrix to the buffer.\n        Also, if its inverse transformation has not been registered, registers it too.\n\n        Args:\n            matrix (HomogeneousMatrix): Transformation matrix.\n        \"\"\"\n        src = matrix.src\n        dst = matrix.dst\n        if (src, dst) not in self.buffer:\n            self.buffer[(src, dst)] = matrix\n\n        if (dst, src) not in self.buffer:\n            self.buffer[(dst, src)] = matrix.inv()\n\n    def lookup_transform(self, src: str, dst: str) -&gt; HomogeneousMatrix | None:\n        \"\"\"Look up the transform matrix corresponding to the `src` and `dst` frame ID.\n\n        Args:\n            src (str): Source frame ID.\n            dst (str): Destination frame ID.\n\n        Returns:\n            Returns `HomogeneousMatrix` if the corresponding matrix can be found,\n                otherwise it returns `None`.\n        \"\"\"\n        if src == dst:\n            return HomogeneousMatrix.as_identity(src)\n        return self.buffer[(src, dst)] if (src, dst) in self.buffer else None\n\n    def do_translate(self, src: str, dst: str, *args, **kwargs) -&gt; TranslateItemLike | None:\n        \"\"\"Translate specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n        Args:\n            src (str): Source frame ID.\n            dst (str): Destination frame ID.\n\n        Returns:\n            TranslateItemLike | None: Returns translated items if the corresponding matrix can be found,\n                otherwise it returns `None`.\n        \"\"\"\n        tf_matrix = self.lookup_transform(src, dst)\n        return tf_matrix.translate(*args, **kwargs) if tf_matrix is not None else None\n\n    def do_rotate(self, src: str, dst: str, *args, **kwargs) -&gt; RotateItemLike | None:\n        \"\"\"Rotate specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n        Args:\n            src (str): Source frame ID.\n            dst (str): Destination frame ID.\n\n        Returns:\n            TranslateItemLike | None: Returns rotated items if the corresponding matrix can be found,\n                otherwise it returns `None`.\n        \"\"\"\n        tf_matrix = self.lookup_transform(src, dst)\n        return tf_matrix.rotate(*args, **kwargs) if tf_matrix is not None else None\n\n    def do_transform(self, src: str, dst: str, *args, **kwargs) -&gt; TransformItemLike | None:\n        \"\"\"Transform specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n        Args:\n            src (str): Source frame ID.\n            dst (str): Destination frame ID.\n\n        Returns:\n            TranslateItemLike | None: Returns transformed items if the corresponding matrix can be found,\n                otherwise it returns `None`.\n        \"\"\"\n        tf_matrix = self.lookup_transform(src, dst)\n        return tf_matrix.transform(*args, **kwargs) if tf_matrix is not None else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.do_rotate","title":"<code>do_rotate(src, dst, *args, **kwargs)</code>","text":"<p>Rotate specified items with the matrix corresponding to <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>Source frame ID.</p> required <code>dst</code> <code>str</code> <p>Destination frame ID.</p> required <p>Returns:</p> Type Description <code>RotateItemLike | None</code> <p>TranslateItemLike | None: Returns rotated items if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def do_rotate(self, src: str, dst: str, *args, **kwargs) -&gt; RotateItemLike | None:\n    \"\"\"Rotate specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        TranslateItemLike | None: Returns rotated items if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    tf_matrix = self.lookup_transform(src, dst)\n    return tf_matrix.rotate(*args, **kwargs) if tf_matrix is not None else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.do_transform","title":"<code>do_transform(src, dst, *args, **kwargs)</code>","text":"<p>Transform specified items with the matrix corresponding to <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>Source frame ID.</p> required <code>dst</code> <code>str</code> <p>Destination frame ID.</p> required <p>Returns:</p> Type Description <code>TransformItemLike | None</code> <p>TranslateItemLike | None: Returns transformed items if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def do_transform(self, src: str, dst: str, *args, **kwargs) -&gt; TransformItemLike | None:\n    \"\"\"Transform specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        TranslateItemLike | None: Returns transformed items if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    tf_matrix = self.lookup_transform(src, dst)\n    return tf_matrix.transform(*args, **kwargs) if tf_matrix is not None else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.do_translate","title":"<code>do_translate(src, dst, *args, **kwargs)</code>","text":"<p>Translate specified items with the matrix corresponding to <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>Source frame ID.</p> required <code>dst</code> <code>str</code> <p>Destination frame ID.</p> required <p>Returns:</p> Type Description <code>TranslateItemLike | None</code> <p>TranslateItemLike | None: Returns translated items if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def do_translate(self, src: str, dst: str, *args, **kwargs) -&gt; TranslateItemLike | None:\n    \"\"\"Translate specified items with the matrix corresponding to `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        TranslateItemLike | None: Returns translated items if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    tf_matrix = self.lookup_transform(src, dst)\n    return tf_matrix.translate(*args, **kwargs) if tf_matrix is not None else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.lookup_transform","title":"<code>lookup_transform(src, dst)</code>","text":"<p>Look up the transform matrix corresponding to the <code>src</code> and <code>dst</code> frame ID.</p> <p>Parameters:</p> Name Type Description Default <code>src</code> <code>str</code> <p>Source frame ID.</p> required <code>dst</code> <code>str</code> <p>Destination frame ID.</p> required <p>Returns:</p> Type Description <code>HomogeneousMatrix | None</code> <p>Returns <code>HomogeneousMatrix</code> if the corresponding matrix can be found, otherwise it returns <code>None</code>.</p> Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def lookup_transform(self, src: str, dst: str) -&gt; HomogeneousMatrix | None:\n    \"\"\"Look up the transform matrix corresponding to the `src` and `dst` frame ID.\n\n    Args:\n        src (str): Source frame ID.\n        dst (str): Destination frame ID.\n\n    Returns:\n        Returns `HomogeneousMatrix` if the corresponding matrix can be found,\n            otherwise it returns `None`.\n    \"\"\"\n    if src == dst:\n        return HomogeneousMatrix.as_identity(src)\n    return self.buffer[(src, dst)] if (src, dst) in self.buffer else None\n</code></pre>"},{"location":"apis/dataclass/#t4_devkit.dataclass.transform.TransformBuffer.set_transform","title":"<code>set_transform(matrix)</code>","text":"<p>Set transform matrix to the buffer. Also, if its inverse transformation has not been registered, registers it too.</p> <p>Parameters:</p> Name Type Description Default <code>matrix</code> <code>HomogeneousMatrix</code> <p>Transformation matrix.</p> required Source code in <code>t4_devkit/dataclass/transform.py</code> <pre><code>def set_transform(self, matrix: HomogeneousMatrix) -&gt; None:\n    \"\"\"Set transform matrix to the buffer.\n    Also, if its inverse transformation has not been registered, registers it too.\n\n    Args:\n        matrix (HomogeneousMatrix): Transformation matrix.\n    \"\"\"\n    src = matrix.src\n    dst = matrix.dst\n    if (src, dst) not in self.buffer:\n        self.buffer[(src, dst)] = matrix\n\n    if (dst, src) not in self.buffer:\n        self.buffer[(dst, src)] = matrix.inv()\n</code></pre>"},{"location":"apis/filtering/","title":"<code>filtering</code>","text":""},{"location":"apis/filtering/#t4_devkit.filtering.compose.BoxFilter","title":"<code>BoxFilter</code>","text":"<p>A class composes multiple filtering functions.</p> Source code in <code>t4_devkit/filtering/compose.py</code> <pre><code>class BoxFilter:\n    \"\"\"A class composes multiple filtering functions.\"\"\"\n\n    def __init__(self, params: FilterParams, tf_buffer: TransformBuffer) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            params (FilterParams): Filtering parameters.\n            tf_buffer (TransformBuffer): Transformation buffer.\n        \"\"\"\n        self.filters: list[BoxFilterFunction] = [\n            FilterByLabel.from_params(params),\n            FilterByUUID.from_params(params),\n            FilterByDistance.from_params(params),\n            FilterByRegion.from_params(params),\n            FilterBySpeed.from_params(params),\n            FilterByNumPoints.from_params(params),\n            FilterByVisibility.from_params(params),\n        ]\n\n        self.tf_buffer = tf_buffer\n\n    def __call__(self, boxes: Sequence[BoxLike]) -&gt; list[BoxLike]:\n        output: list[BoxLike] = []\n\n        for box in boxes:\n            tf_matrix = self.tf_buffer.lookup_transform(box.frame_id, \"base_link\")\n\n            is_ok = all(func(box, tf_matrix) for func in self.filters)\n\n            if is_ok:\n                output.append(box)\n\n        return output\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.compose.BoxFilter.__init__","title":"<code>__init__(params, tf_buffer)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>params</code> <code>FilterParams</code> <p>Filtering parameters.</p> required <code>tf_buffer</code> <code>TransformBuffer</code> <p>Transformation buffer.</p> required Source code in <code>t4_devkit/filtering/compose.py</code> <pre><code>def __init__(self, params: FilterParams, tf_buffer: TransformBuffer) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        params (FilterParams): Filtering parameters.\n        tf_buffer (TransformBuffer): Transformation buffer.\n    \"\"\"\n    self.filters: list[BoxFilterFunction] = [\n        FilterByLabel.from_params(params),\n        FilterByUUID.from_params(params),\n        FilterByDistance.from_params(params),\n        FilterByRegion.from_params(params),\n        FilterBySpeed.from_params(params),\n        FilterByNumPoints.from_params(params),\n        FilterByVisibility.from_params(params),\n    ]\n\n    self.tf_buffer = tf_buffer\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByDistance","title":"<code>FilterByDistance</code>","text":"<p>Filter a box by checking if the box is within the specified distance.</p> <p>Note that, the type box is <code>Box2D</code> and its <code>position</code> is None, these boxes pass through this filter.</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>class FilterByDistance(BaseBoxFilter):\n    \"\"\"Filter a box by checking if the box is within the specified distance.\n\n    Note that, the type box is `Box2D` and its `position` is None,\n    these boxes pass through this filter.\n    \"\"\"\n\n    def __init__(self, min_distance: float, max_distance: float) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            min_distance (float): Minimum distance from the ego [m].\n            max_distance (float): Maximum distance from the ego [m].\n        \"\"\"\n        super().__init__()\n        self.min_distance = min_distance\n        self.max_distance = max_distance\n\n    @classmethod\n    def from_params(cls, params: FilterParams) -&gt; Self:\n        return cls(params.min_distance, params.max_distance)\n\n    def __call__(self, box: BoxLike, tf_matrix: HomogeneousMatrix) -&gt; bool:\n        box_distance = distance_box(box, tf_matrix)\n\n        # box_distance is None, only if the box is 2D and its position is None.\n        if box_distance is None:\n            return True\n        else:\n            return self.min_distance &lt; box_distance and box_distance &lt; self.max_distance\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByDistance.__init__","title":"<code>__init__(min_distance, max_distance)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>min_distance</code> <code>float</code> <p>Minimum distance from the ego [m].</p> required <code>max_distance</code> <code>float</code> <p>Maximum distance from the ego [m].</p> required Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_distance: float, max_distance: float) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_distance (float): Minimum distance from the ego [m].\n        max_distance (float): Maximum distance from the ego [m].\n    \"\"\"\n    super().__init__()\n    self.min_distance = min_distance\n    self.max_distance = max_distance\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByLabel","title":"<code>FilterByLabel</code>","text":"<p>Filter a box by checking if the label of the box is included in specified labels.</p> <p>Note that, if <code>labels</code> is None all boxes pass through this filter.</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>class FilterByLabel(BaseBoxFilter):\n    \"\"\"Filter a box by checking if the label of the box is included in specified labels.\n\n    Note that, if `labels` is None all boxes pass through this filter.\n    \"\"\"\n\n    def __init__(self, labels: Sequence[str | SemanticLabel] | None = None) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            labels (Sequence[str | SemanticLabel] | None, optional): Sequence of target labels.\n                If `None`, this filter always returns `True`.\n        \"\"\"\n        super().__init__()\n        self.labels = labels\n\n    @classmethod\n    def from_params(cls, params: FilterParams) -&gt; Self:\n        return cls(params.labels)\n\n    def __call__(self, box: BoxLike, _tf_matrix: HomogeneousMatrix | None = None) -&gt; bool:\n        if self.labels is None:\n            return True\n\n        return box.semantic_label in self.labels\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByLabel.__init__","title":"<code>__init__(labels=None)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>labels</code> <code>Sequence[str | SemanticLabel] | None</code> <p>Sequence of target labels. If <code>None</code>, this filter always returns <code>True</code>.</p> <code>None</code> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, labels: Sequence[str | SemanticLabel] | None = None) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        labels (Sequence[str | SemanticLabel] | None, optional): Sequence of target labels.\n            If `None`, this filter always returns `True`.\n    \"\"\"\n    super().__init__()\n    self.labels = labels\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByNumPoints","title":"<code>FilterByNumPoints</code>","text":"<p>Filter a 3D box by checking if the box includes points greater than the specified one.</p> <p>Note that, the type box is <code>Box2D</code>, or <code>Box3D</code> and its <code>num_points</code> is None, these boxes pass through this filter.</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>class FilterByNumPoints(BaseBoxFilter):\n    \"\"\"Filter a 3D box by checking if the box includes points greater than the specified one.\n\n    Note that, the type box is `Box2D`, or `Box3D` and its `num_points` is None,\n    these boxes pass through this filter.\n    \"\"\"\n\n    def __init__(self, min_num_points: int = 0) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            min_num_points (int, optional): The minimum number of points that a box should include.\n        \"\"\"\n        super().__init__()\n        self.min_num_points = min_num_points\n\n    @classmethod\n    def from_params(cls, params: FilterParams) -&gt; Self:\n        return cls(params.min_num_points)\n\n    def __call__(self, box: BoxLike, _tf_matrix: HomogeneousMatrix | None = None) -&gt; bool:\n        if isinstance(box, Box2D):\n            return True\n        elif isinstance(box, Box3D) and box.num_points is None:\n            return True\n        else:\n            return self.min_num_points &lt;= box.num_points\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByNumPoints.__init__","title":"<code>__init__(min_num_points=0)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>min_num_points</code> <code>int</code> <p>The minimum number of points that a box should include.</p> <code>0</code> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_num_points: int = 0) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_num_points (int, optional): The minimum number of points that a box should include.\n    \"\"\"\n    super().__init__()\n    self.min_num_points = min_num_points\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByRegion","title":"<code>FilterByRegion</code>","text":"<p>Filter a box by checking if the box xy position is within the specified xy region.</p> <p>Note that, the type box is <code>Box2D</code> and its <code>position</code> is None, these boxes pass through this filter.</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>class FilterByRegion(BaseBoxFilter):\n    \"\"\"Filter a box by checking if the box xy position is within the specified xy region.\n\n    Note that, the type box is `Box2D` and its `position` is None,\n    these boxes pass through this filter.\n    \"\"\"\n\n    def __init__(self, min_xy: tuple[float, float], max_xy: tuple[float, float]) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            min_xy (tuple[float, float]): Minimum xy position [m].\n            max_xy (tuple[float, float]): Maximum xy position [m].\n        \"\"\"\n        super().__init__()\n        self.min_xy = min_xy\n        self.max_xy = max_xy\n\n    @classmethod\n    def from_params(cls, params: FilterParams) -&gt; Self:\n        return cls(params.min_xy, params.max_xy)\n\n    def __call__(self, box: BoxLike, tf_matrix: HomogeneousMatrix) -&gt; bool:\n        if isinstance(box, Box2D) and box.position is None:\n            return True\n\n        if isinstance(box, Box2D):\n            position = tf_matrix.transform(box.position)\n        elif isinstance(box, Box3D):\n            position, _ = tf_matrix.transform(box.position, box.rotation)\n        else:\n            raise TypeError(f\"Unexpected box type: {type(box)}\")\n\n        return np.all((self.min_xy &lt; position[:2]) &amp; (position[:2] &lt; self.max_xy))\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByRegion.__init__","title":"<code>__init__(min_xy, max_xy)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>min_xy</code> <code>tuple[float, float]</code> <p>Minimum xy position [m].</p> required <code>max_xy</code> <code>tuple[float, float]</code> <p>Maximum xy position [m].</p> required Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_xy: tuple[float, float], max_xy: tuple[float, float]) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_xy (tuple[float, float]): Minimum xy position [m].\n        max_xy (tuple[float, float]): Maximum xy position [m].\n    \"\"\"\n    super().__init__()\n    self.min_xy = min_xy\n    self.max_xy = max_xy\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterBySpeed","title":"<code>FilterBySpeed</code>","text":"<p>Filter a 3D box by checking if the box speed is within the specified one.</p> <p>Note that, the type box is <code>Box2D</code>, or <code>Box3D</code> and its <code>velocity</code> is None, these boxes pass through this filter.</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>class FilterBySpeed(BaseBoxFilter):\n    \"\"\"Filter a 3D box by checking if the box speed is within the specified one.\n\n    Note that, the type box is `Box2D`, or `Box3D` and its `velocity` is None,\n    these boxes pass through this filter.\n    \"\"\"\n\n    def __init__(self, min_speed: float, max_speed: float) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            min_speed (float): Minimum speed [m/s].\n            max_speed (float): Maximum speed [m/s].\n        \"\"\"\n        super().__init__()\n        self.min_speed = min_speed\n        self.max_speed = max_speed\n\n    @classmethod\n    def from_params(cls, params: FilterParams) -&gt; Self:\n        return cls(params.min_speed, params.max_speed)\n\n    def __call__(self, box: BoxLike, _tf_matrix: HomogeneousMatrix | None = None) -&gt; bool:\n        if isinstance(box, Box2D):\n            return True\n        elif isinstance(box, Box3D) and box.velocity is None:\n            return True\n        else:\n            speed = np.linalg.norm(box.velocity)\n            return self.min_speed &lt; speed and speed &lt; self.max_speed\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterBySpeed.__init__","title":"<code>__init__(min_speed, max_speed)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>min_speed</code> <code>float</code> <p>Minimum speed [m/s].</p> required <code>max_speed</code> <code>float</code> <p>Maximum speed [m/s].</p> required Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, min_speed: float, max_speed: float) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        min_speed (float): Minimum speed [m/s].\n        max_speed (float): Maximum speed [m/s].\n    \"\"\"\n    super().__init__()\n    self.min_speed = min_speed\n    self.max_speed = max_speed\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByUUID","title":"<code>FilterByUUID</code>","text":"<p>Filter a box by checking if the uuid of the box is included in specified uuids.</p> <p>Note that, if <code>uuids</code> is None all boxes pass through this filter.</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>class FilterByUUID(BaseBoxFilter):\n    \"\"\"Filter a box by checking if the uuid of the box is included in specified uuids.\n\n    Note that, if `uuids` is None all boxes pass through this filter.\n    \"\"\"\n\n    def __init__(self, uuids: Sequence[str] | None = None) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            uuids (Sequence[str] | None, optional): Sequence of target uuids.\n                If `None`, this filter always returns `True`.\n        \"\"\"\n        super().__init__()\n        self.uuids = uuids\n\n    @classmethod\n    def from_params(cls, params: FilterParams) -&gt; Self:\n        return cls(params.uuids)\n\n    def __call__(self, box: BoxLike, _tf_matrix: HomogeneousMatrix | None = None) -&gt; bool:\n        if self.uuids is None:\n            return True\n\n        return box.uuid in self.uuids\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByUUID.__init__","title":"<code>__init__(uuids=None)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>uuids</code> <code>Sequence[str] | None</code> <p>Sequence of target uuids. If <code>None</code>, this filter always returns <code>True</code>.</p> <code>None</code> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, uuids: Sequence[str] | None = None) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        uuids (Sequence[str] | None, optional): Sequence of target uuids.\n            If `None`, this filter always returns `True`.\n    \"\"\"\n    super().__init__()\n    self.uuids = uuids\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByVisibility","title":"<code>FilterByVisibility</code>","text":"<p>A filter that excludes 3D boxes with lower visibility than a specified threshold.</p> <p>Boxes with <code>UNAVAILABLE</code> visibility are always passed through (i.e., not filtered).</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>class FilterByVisibility(BaseBoxFilter):\n    \"\"\"A filter that excludes 3D boxes with lower visibility than a specified threshold.\n\n    Boxes with `UNAVAILABLE` visibility are always passed through (i.e., not filtered).\n    \"\"\"\n\n    def __init__(self, visibility: VisibilityLevel = VisibilityLevel.NONE) -&gt; None:\n        \"\"\"\n        Initialize the filter with a visibility threshold.\n\n        Args:\n            visibility (VisibilityLevel): The minimum visibility level for a box to pass the filter.\n\n        Raises:\n            ValueError: If the given visibility is not comparable (e.g., UNAVAILABLE).\n        \"\"\"\n        super().__init__()\n        if not visibility.is_comparable():\n            raise ValueError(f\"Comparable visibility must be set as threshold: {visibility}\")\n\n        self.visibility = visibility\n\n    @classmethod\n    def from_params(cls, params: FilterParams) -&gt; Self:\n        return cls(params.visibility)\n\n    def __call__(self, box: BoxLike, _tf_matrix: HomogeneousMatrix | None = None) -&gt; bool:\n        if not isinstance(box, Box3D):\n            return True\n        else:\n            return self.visibility &lt;= box.visibility if box.visibility.is_comparable() else True\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.functional.FilterByVisibility.__init__","title":"<code>__init__(visibility=VisibilityLevel.NONE)</code>","text":"<p>Initialize the filter with a visibility threshold.</p> <p>Parameters:</p> Name Type Description Default <code>visibility</code> <code>VisibilityLevel</code> <p>The minimum visibility level for a box to pass the filter.</p> <code>NONE</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the given visibility is not comparable (e.g., UNAVAILABLE).</p> Source code in <code>t4_devkit/filtering/functional.py</code> <pre><code>def __init__(self, visibility: VisibilityLevel = VisibilityLevel.NONE) -&gt; None:\n    \"\"\"\n    Initialize the filter with a visibility threshold.\n\n    Args:\n        visibility (VisibilityLevel): The minimum visibility level for a box to pass the filter.\n\n    Raises:\n        ValueError: If the given visibility is not comparable (e.g., UNAVAILABLE).\n    \"\"\"\n    super().__init__()\n    if not visibility.is_comparable():\n        raise ValueError(f\"Comparable visibility must be set as threshold: {visibility}\")\n\n    self.visibility = visibility\n</code></pre>"},{"location":"apis/filtering/#t4_devkit.filtering.parameter.FilterParams","title":"<code>FilterParams</code>","text":"<p>A dataclass to represent filtering parameters.</p> <p>Attributes:</p> Name Type Description <code>labels</code> <code>Sequence[str | SemanticLabel] | None</code> <p>Sequence of target labels.</p> <code>uuids</code> <code>Sequence[str] | None</code> <p>Sequence of target uuids.</p> <code>min_distance</code> <code>float</code> <p>Minimum distance from the ego [m].</p> <code>max_distance</code> <code>float</code> <p>Maximum distance from the ego [m].</p> <code>min_xy</code> <code>tuple[float, float]</code> <p>Minimum xy position from the ego [m].</p> <code>min_xy</code> <code>tuple[float, float]</code> <p>Maximum xy position from the ego [m].</p> <code>min_speed</code> <code>float</code> <p>Minimum speed [m/s].</p> <code>max_speed</code> <code>float</code> <p>Maximum speed [m/s].</p> <code>min_num_points</code> <code>int</code> <p>The minimum number of points which the 3D box should include.</p> <code>visibility</code> <code>str | VisibilityLevel</code> <p>Visibility threshold.</p> Source code in <code>t4_devkit/filtering/parameter.py</code> <pre><code>@define\nclass FilterParams:\n    \"\"\"A dataclass to represent filtering parameters.\n\n    Attributes:\n        labels (Sequence[str | SemanticLabel] | None, optional): Sequence of target labels.\n        uuids (Sequence[str] | None, optional): Sequence of target uuids.\n        min_distance (float, optional): Minimum distance from the ego [m].\n        max_distance (float, optional): Maximum distance from the ego [m].\n        min_xy (tuple[float, float], optional): Minimum xy position from the ego [m].\n        min_xy (tuple[float, float], optional): Maximum xy position from the ego [m].\n        min_speed (float, optional): Minimum speed [m/s].\n        max_speed (float, optional): Maximum speed [m/s].\n        min_num_points (int): The minimum number of points which the 3D box should include.\n        visibility (str | VisibilityLevel, optional): Visibility threshold.\n    \"\"\"\n\n    labels: Sequence[str | SemanticLabel] | None = field(\n        default=None,\n        validator=validators.optional(\n            validators.deep_iterable(\n                validators.or_(validators.instance_of(str), validators.instance_of(SemanticLabel))\n            )\n        ),\n    )\n    uuids: Sequence[str] | None = field(\n        default=None,\n        validator=validators.optional(validators.deep_iterable(validators.instance_of(str))),\n    )\n    min_distance: float = field(default=0.0, validator=validators.ge(0.0))\n    max_distance: float = field(default=np.inf, validator=validators.ge(0.0))\n    min_xy: tuple[float, float] = field(default=(-np.inf, -np.inf))\n    max_xy: tuple[float, float] = field(default=(np.inf, np.inf))\n    min_speed: float = field(default=0.0, validator=validators.ge(0.0))\n    max_speed: float = field(default=np.inf, validator=validators.ge(0.0))\n    min_num_points: int = field(\n        default=0,\n        validator=[validators.instance_of(int), validators.ge(0)],\n    )\n    visibility: VisibilityLevel = field(\n        default=VisibilityLevel.NONE,\n        converter=VisibilityLevel,\n        validator=validators.instance_of(VisibilityLevel),\n    )\n</code></pre>"},{"location":"apis/helper/","title":"<code>helper</code>","text":""},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper","title":"<code>RenderingHelper</code>","text":"<p>Help <code>Tier4</code> class with rendering tasks.</p> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>class RenderingHelper:\n    \"\"\"Help `Tier4` class with rendering tasks.\"\"\"\n\n    def __init__(self, t4: Tier4) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            t4 (Tier4): `Tier4` instance.\n        \"\"\"\n        self._t4 = t4\n        self._label2id: dict[str, int] = {\n            category.name: category.index for category in self._t4.category\n        }\n        self._sample_data_to_lidarseg_filename: dict[str, str] = {\n            lidarseg.sample_data_token: lidarseg.filename for lidarseg in self._t4.lidarseg\n        }\n\n        self._executor = concurrent.futures.ThreadPoolExecutor()\n\n    def _has_lidarseg(self) -&gt; bool:\n        return bool(self._sample_data_to_lidarseg_filename)\n\n    def _find_lidarseg_file(self, sample_data_token: str) -&gt; str | None:\n        return self._sample_data_to_lidarseg_filename.get(sample_data_token)\n\n    def _init_viewer(\n        self,\n        app_id: str,\n        *,\n        contents: list[str] | None = None,\n        render_ann: bool = True,\n        save_dir: str | None = None,\n    ) -&gt; RerunViewer:\n        \"\"\"Initialize viewer instance.\n\n        Args:\n            app_id (str): Viewer application ID.\n            contents (list[str] | None, optional): List of contents to project 3D objects onto 2D spaces.\n            render_ann (bool, optional): Indicates whether to render annotations.\n            save_dir (str | None, optional): Directory path to save the rendering record.\n        \"\"\"\n        cameras = [\n            sensor.channel for sensor in self._t4.sensor if sensor.modality == SensorModality.CAMERA\n        ]\n\n        builder = (\n            ViewerBuilder().with_spatial3d().with_spatial2d(cameras=cameras, contents=contents)\n        )\n\n        if render_ann:\n            builder = builder.with_labels(self._label2id)\n\n        global_map_filepath = osp.join(self._t4.data_root, \"map/global_map_center.pcd.yaml\")\n        if osp.exists(global_map_filepath):\n            with open(global_map_filepath) as f:\n                map_metadata: dict = yaml.safe_load(f)\n            map_origin: dict = map_metadata[\"/**\"][\"ros__parameters\"][\"map_origin\"]\n            latitude, longitude = map_origin[\"latitude\"], map_origin[\"longitude\"]\n            builder = builder.with_streetmap((latitude, longitude))\n        elif osp.exists(osp.join(self._t4.map_dir, \"lanelet2_map.osm\")):\n            builder = builder.with_streetmap()\n\n        return builder.build(app_id, save_dir=save_dir)\n\n    def _load_contents(self, mode: RenderingMode, entity_child: str = \"\") -&gt; list[str] | None:\n        \"\"\"Load contents to project 3D objects onto 2D spaces.\n\n        Args:\n            mode (RenderingMode): RenderingMode enum.\n            entity_child (str, optional): Child entity path.\n\n        Returns:\n            list[str] | None: List of entity paths to be used as 2D projection contents.\n                Returns `None` to indicate that no 3D entities should be projected onto\n                2D spaces (e.g., when 2D annotations are available).\n        \"\"\"\n        match mode:\n            case RenderingMode.SCENE | RenderingMode.INSTANCE:\n                # project 3D boxes/velocities/futures on image if there is no 2D annotation\n                entity_root = format_entity(EntityPath.MAP, entity_child)\n                if len(self._t4.object_ann) == 0 and len(self._t4.surface_ann) == 0:\n                    contents = [\n                        format_entity(entity_root, EntityPath.BOX),\n                        format_entity(entity_root, EntityPath.VELOCITY),\n                        format_entity(entity_root, EntityPath.FUTURE),\n                    ]\n                else:\n                    contents = None\n            case RenderingMode.POINTCLOUD:\n                contents = [format_entity(EntityPath.BASE_LINK, entity_child)]\n\n        return contents\n\n    def render_scene(\n        self,\n        *,\n        max_time_seconds: float = np.inf,\n        future_seconds: float = 0.0,\n        save_dir: str | None = None,\n    ) -&gt; None:\n        \"\"\"Render specified scene.\n\n        Args:\n            max_time_seconds (float, optional): Max time length to be rendered [s].\n            future_seconds (float, optional): Future time in [s].\n            save_dir (str | None, optional): Directory path to save the recording.\n                Viewer will be spawned if it is None, otherwise not.\n        \"\"\"\n        # search first sample data tokens\n        first_lidar_tokens: list[str] = [\n            sensor.first_sd_token\n            for sensor in self._t4.sensor\n            if sensor.modality == SensorModality.LIDAR\n        ]\n        first_radar_tokens: list[str] = [\n            sensor.first_sd_token\n            for sensor in self._t4.sensor\n            if sensor.modality == SensorModality.RADAR\n        ]\n        first_camera_tokens: list[str] = [\n            sensor.first_sd_token\n            for sensor in self._t4.sensor\n            if sensor.modality == SensorModality.CAMERA\n        ]\n\n        app_id = f\"scene@{self._t4.dataset_id}\"\n        contents = self._load_contents(RenderingMode.SCENE)\n        viewer = self._init_viewer(app_id, contents=contents, render_ann=True, save_dir=save_dir)\n\n        self._try_render_map(viewer)\n\n        scene: Scene = self._t4.scene[0]\n        first_sample: Sample = self._t4.get(\"sample\", scene.first_sample_token)\n        max_timestamp_us = first_sample.timestamp + seconds2microseconds(max_time_seconds)\n\n        pointcloud_color_mode = (\n            PointCloudColorMode.SEGMENTATION\n            if self._has_lidarseg()\n            else PointCloudColorMode.DISTANCE\n        )\n\n        futures = (\n            self._render_lidar_and_ego(\n                viewer=viewer,\n                first_lidar_tokens=first_lidar_tokens,\n                max_timestamp_us=max_timestamp_us,\n                color_mode=pointcloud_color_mode,\n            )\n            + self._render_radars(\n                viewer=viewer,\n                first_radar_tokens=first_radar_tokens,\n                max_timestamp_us=max_timestamp_us,\n            )\n            + self._render_cameras(\n                viewer=viewer,\n                first_camera_tokens=first_camera_tokens,\n                max_timestamp_us=max_timestamp_us,\n            )\n            + [\n                self._executor.submit(\n                    self._render_annotation3ds,\n                    viewer=viewer,\n                    first_sample_token=scene.first_sample_token,\n                    max_timestamp_us=max_timestamp_us,\n                    future_seconds=future_seconds,\n                ),\n                self._executor.submit(\n                    self._render_annotation2ds,\n                    viewer=viewer,\n                    first_sample_token=scene.first_sample_token,\n                    max_timestamp_us=max_timestamp_us,\n                ),\n            ]\n        )\n\n        _handle_futures(futures)\n\n    def render_instance(\n        self,\n        instance_token: str | Sequence[str],\n        *,\n        future_seconds: float = 0.0,\n        save_dir: str | None = None,\n    ) -&gt; None:\n        \"\"\"Render particular instance.\n\n        Args:\n            instance_token (str | Sequence[str]): Instance token(s).\n            future_seconds (float, optional): Future time in [s].\n            save_dir (str | None, optional): Directory path to save the recording.\n                Viewer will be spawned if it is None, otherwise not.\n\n        \"\"\"\n        instance_tokens = [instance_token] if isinstance(instance_token, str) else instance_token\n\n        first_sample: Sample | None = None\n        last_sample: Sample | None = None\n        for token in instance_tokens:\n            instance: Instance = self._t4.get(\"instance\", token)\n            first_ann: SampleAnnotation = self._t4.get(\n                \"sample_annotation\", instance.first_annotation_token\n            )\n            current_first_sample: Sample = self._t4.get(\"sample\", first_ann.sample_token)\n            if first_sample is None or current_first_sample.timestamp &lt; first_sample.timestamp:\n                first_sample = current_first_sample\n\n            last_ann: SampleAnnotation = self._t4.get(\n                \"sample_annotation\", instance.last_annotation_token\n            )\n            current_last_sample: Sample = self._t4.get(\"sample\", last_ann.sample_token)\n            if last_sample is None or current_last_sample.timestamp &gt; last_sample.timestamp:\n                last_sample = current_last_sample\n\n        if first_sample is None or last_sample is None:\n            warnings.warn(\n                f\"There is no sample for the corresponding instance(s): {instance_tokens}\",\n                stacklevel=2,\n            )\n            return\n\n        max_timestamp_us = last_sample.timestamp\n\n        # search first sample data tokens\n        first_lidar_tokens: list[str] = [\n            sensor.first_sd_token\n            for sensor in self._t4.sensor\n            if sensor.modality == SensorModality.LIDAR\n        ]\n        first_radar_tokens: list[str] = [\n            sensor.first_sd_token\n            for sensor in self._t4.sensor\n            if sensor.modality == SensorModality.RADAR\n        ]\n        first_camera_tokens: list[str] = [\n            sensor.first_sd_token\n            for sensor in self._t4.sensor\n            if sensor.modality == SensorModality.CAMERA\n        ]\n\n        app_id = f\"instance@{self._t4.dataset_id}\"\n        contents = self._load_contents(RenderingMode.INSTANCE)\n        viewer = self._init_viewer(app_id, contents=contents, render_ann=True, save_dir=save_dir)\n\n        self._try_render_map(viewer)\n\n        pointcloud_color_mode = (\n            PointCloudColorMode.SEGMENTATION\n            if self._has_lidarseg()\n            else PointCloudColorMode.DISTANCE\n        )\n\n        futures = (\n            self._render_lidar_and_ego(\n                viewer=viewer,\n                first_lidar_tokens=first_lidar_tokens,\n                max_timestamp_us=max_timestamp_us,\n                color_mode=pointcloud_color_mode,\n            )\n            + self._render_radars(\n                viewer=viewer,\n                first_radar_tokens=first_radar_tokens,\n                max_timestamp_us=max_timestamp_us,\n            )\n            + self._render_cameras(\n                viewer=viewer,\n                first_camera_tokens=first_camera_tokens,\n                max_timestamp_us=max_timestamp_us,\n            )\n            + [\n                self._executor.submit(\n                    self._render_annotation3ds,\n                    viewer=viewer,\n                    first_sample_token=first_sample.token,\n                    max_timestamp_us=max_timestamp_us,\n                    future_seconds=future_seconds,\n                    instance_tokens=instance_tokens,\n                ),\n                self._executor.submit(\n                    self._render_annotation2ds,\n                    viewer=viewer,\n                    first_sample_token=first_sample.token,\n                    max_timestamp_us=max_timestamp_us,\n                    instance_tokens=instance_tokens,\n                ),\n            ]\n        )\n\n        _handle_futures(futures)\n\n    def render_pointcloud(\n        self,\n        *,\n        max_time_seconds: float = np.inf,\n        save_dir: str | None = None,\n    ) -&gt; None:\n        \"\"\"Render pointcloud on 3D and 2D view.\n\n        Args:\n            max_time_seconds (float, optional): Max time length to be rendered [s].\n            save_dir (str | None, optional): Directory path to save the recording.\n                Viewer will be spawned if it is None, otherwise not.\n\n        TODO:\n            Add an option of rendering radar channels.\n        \"\"\"\n        # search first lidar sample data token\n        first_lidar_token: str | None = None\n        first_camera_tokens: list[str] = []\n        for sensor in self._t4.sensor:\n            if sensor.modality == SensorModality.LIDAR:\n                first_lidar_token = sensor.first_sd_token\n            elif sensor.modality == SensorModality.CAMERA:\n                first_camera_tokens.append(sensor.first_sd_token)\n\n        if first_lidar_token is None:\n            raise ValueError(\"There is no 3D pointcloud data.\")\n\n        first_lidar_sample_data: SampleData = self._t4.get(\"sample_data\", first_lidar_token)\n        max_timestamp_us = first_lidar_sample_data.timestamp + seconds2microseconds(\n            max_time_seconds\n        )\n\n        app_id = f\"pointcloud@{self._t4.dataset_id}\"\n        contents = self._load_contents(\n            RenderingMode.POINTCLOUD,\n            entity_child=first_lidar_sample_data.channel,\n        )\n        viewer = self._init_viewer(app_id, contents=contents, render_ann=False, save_dir=save_dir)\n\n        self._try_render_map(viewer)\n\n        # TODO: support rendering segmentation pointcloud on camera\n        futures = self._render_lidar_and_ego(\n            viewer=viewer,\n            first_lidar_tokens=[first_lidar_token],\n            max_timestamp_us=max_timestamp_us,\n        ) + self._render_cameras(\n            viewer=viewer,\n            first_camera_tokens=first_camera_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n\n        _handle_futures(futures)\n\n    def _try_render_map(self, viewer: RerunViewer) -&gt; None:\n        lanelet_path = osp.join(self._t4.map_dir, \"lanelet2_map.osm\")\n        if not osp.exists(lanelet_path):\n            return\n        viewer.render_map(lanelet_path)\n\n    def _render_sensor_calibration(self, viewer: RerunViewer, sample_data_token: str) -&gt; None:\n        sample_data: SampleData = self._t4.get(\"sample_data\", sample_data_token)\n        calibration: CalibratedSensor = self._t4.get(\n            \"calibrated_sensor\", sample_data.calibrated_sensor_token\n        )\n        sensor: Sensor = self._t4.get(\"sensor\", calibration.sensor_token)\n        resolution = (\n            (sample_data.width, sample_data.height)\n            if sensor.modality == SensorModality.CAMERA\n            else None\n        )\n        viewer.render_calibration(sensor=sensor, calibration=calibration, resolution=resolution)\n\n    def _render_lidar_and_ego(\n        self,\n        viewer: RerunViewer,\n        first_lidar_tokens: list[str],\n        max_timestamp_us: float,\n        *,\n        color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n    ) -&gt; list[Future]:\n        def _render_single_lidar(first_lidar_token: str) -&gt; None:\n            self._render_sensor_calibration(viewer=viewer, sample_data_token=first_lidar_token)\n\n            current_lidar_token = first_lidar_token\n            while current_lidar_token != \"\":\n                sample_data: SampleData = self._t4.get(\"sample_data\", current_lidar_token)\n                current_lidar_token = sample_data.next\n\n                if max_timestamp_us &lt; sample_data.timestamp:\n                    break\n\n                ego_pose: EgoPose = self._t4.get(\"ego_pose\", sample_data.ego_pose_token)\n                viewer.render_ego(ego_pose=ego_pose)\n\n                # render segmentation pointcloud if available, otherwise render raw pointcloud\n                if color_mode == PointCloudColorMode.SEGMENTATION:\n                    label_filename = self._find_lidarseg_file(sample_data.token)\n                    if label_filename is None:\n                        continue\n\n                    pointcloud = SegmentationPointCloud.from_file(\n                        point_filepath=osp.join(self._t4.data_root, sample_data.filename),\n                        label_filepath=osp.join(self._t4.data_root, label_filename),\n                    )\n                else:\n                    pointcloud = LidarPointCloud.from_file(\n                        osp.join(self._t4.data_root, sample_data.filename)\n                    )\n\n                viewer.render_pointcloud(\n                    seconds=microseconds2seconds(sample_data.timestamp),\n                    channel=sample_data.channel,\n                    pointcloud=pointcloud,\n                    color_mode=color_mode,\n                )\n\n        return [self._executor.submit(_render_single_lidar, token) for token in first_lidar_tokens]\n\n    def _render_radars(\n        self,\n        viewer: RerunViewer,\n        first_radar_tokens: list[str],\n        max_timestamp_us: float,\n    ) -&gt; list[Future]:\n        def _render_single_radar(first_radar_token: str) -&gt; None:\n            self._render_sensor_calibration(viewer=viewer, sample_data_token=first_radar_token)\n\n            current_radar_token = first_radar_token\n            while current_radar_token != \"\":\n                sample_data: SampleData = self._t4.get(\"sample_data\", current_radar_token)\n\n                if max_timestamp_us &lt; sample_data.timestamp:\n                    break\n\n                pointcloud = RadarPointCloud.from_file(\n                    osp.join(self._t4.data_root, sample_data.filename)\n                )\n                viewer.render_pointcloud(\n                    seconds=microseconds2seconds(sample_data.timestamp),\n                    channel=sample_data.channel,\n                    pointcloud=pointcloud,\n                )\n\n                current_radar_token = sample_data.next\n\n        return [self._executor.submit(_render_single_radar, token) for token in first_radar_tokens]\n\n    def _render_cameras(\n        self,\n        viewer: RerunViewer,\n        first_camera_tokens: list[str],\n        max_timestamp_us: float,\n    ) -&gt; list[Future]:\n        def _render_single_camera(first_camera_token: str) -&gt; None:\n            self._render_sensor_calibration(viewer=viewer, sample_data_token=first_camera_token)\n\n            current_camera_token = first_camera_token\n            while current_camera_token != \"\":\n                sample_data: SampleData = self._t4.get(\"sample_data\", current_camera_token)\n\n                if max_timestamp_us &lt; sample_data.timestamp:\n                    break\n\n                viewer.render_image(\n                    seconds=microseconds2seconds(sample_data.timestamp),\n                    camera=sample_data.channel,\n                    image=osp.join(self._t4.data_root, sample_data.filename),\n                )\n\n                current_camera_token = sample_data.next\n\n        return [\n            self._executor.submit(_render_single_camera, token) for token in first_camera_tokens\n        ]\n\n    def _render_annotation3ds(\n        self,\n        viewer: RerunViewer,\n        first_sample_token: str,\n        max_timestamp_us: float,\n        *,\n        future_seconds: float = 0.0,\n        instance_tokens: Sequence[str] | None = None,\n    ) -&gt; None:\n        current_sample_token = first_sample_token\n        while current_sample_token != \"\":\n            sample: Sample = self._t4.get(\"sample\", current_sample_token)\n\n            if max_timestamp_us &lt; sample.timestamp:\n                break\n\n            if instance_tokens is not None:\n                boxes = []\n                for ann_token in sample.ann_3ds:\n                    ann: SampleAnnotation = self._t4.get(\"sample_annotation\", ann_token)\n                    if ann.instance_token in instance_tokens:\n                        boxes.append(self._t4.get_box3d(ann_token, future_seconds=future_seconds))\n            else:\n                boxes = [\n                    self._t4.get_box3d(token, future_seconds=future_seconds)\n                    for token in sample.ann_3ds\n                ]\n            viewer.render_box3ds(microseconds2seconds(sample.timestamp), boxes)\n\n            current_sample_token = sample.next\n\n    def _render_annotation2ds(\n        self,\n        viewer: RerunViewer,\n        first_sample_token: str,\n        max_timestamp_us: float,\n        *,\n        instance_tokens: Sequence[str] | None = None,\n    ) -&gt; None:\n        current_sample_token = first_sample_token\n        while current_sample_token != \"\":\n            sample: Sample = self._t4.get(\"sample\", current_sample_token)\n\n            if max_timestamp_us &lt; sample.timestamp:\n                break\n\n            boxes = []\n            # For segmentation masks\n            # TODO: declare specific class for segmentation mask in `dataclass`\n            camera_masks: dict[str, dict[str, list]] = {}\n\n            # Object Annotation\n            for obj_ann_token in sample.ann_2ds:\n                obj_ann: ObjectAnn = self._t4.get(\"object_ann\", obj_ann_token)\n                box = self._t4.get_box2d(obj_ann_token)\n                if instance_tokens is not None:\n                    if obj_ann.instance_token not in instance_tokens:\n                        continue\n                    boxes.append(box)\n                    sample_data: SampleData = self._t4.get(\"sample_data\", obj_ann.sample_data_token)\n                    camera_masks = _append_mask(\n                        camera_masks,\n                        camera=sample_data.channel,\n                        ann=obj_ann,\n                        class_id=self._label2id[obj_ann.category_name],\n                        uuid=box.uuid,\n                    )\n                else:\n                    boxes.append(box)\n                    sample_data: SampleData = self._t4.get(\"sample_data\", obj_ann.sample_data_token)\n                    camera_masks = _append_mask(\n                        camera_masks,\n                        camera=sample_data.channel,\n                        ann=obj_ann,\n                        class_id=self._label2id[obj_ann.category_name],\n                        uuid=box.uuid,\n                    )\n\n            # Render 2D box\n            viewer.render_box2ds(microseconds2seconds(sample.timestamp), boxes)\n\n            if instance_tokens is None:\n                # Surface Annotation\n                for ann_token in sample.surface_anns:\n                    surface_ann: SurfaceAnn = self._t4.get(\"surface_ann\", ann_token)\n                    sample_data: SampleData = self._t4.get(\n                        \"sample_data\", surface_ann.sample_data_token\n                    )\n                    camera_masks = _append_mask(\n                        camera_masks,\n                        camera=sample_data.channel,\n                        ann=surface_ann,\n                        class_id=self._label2id[surface_ann.category_name],\n                    )\n\n            # Render 2D segmentation image\n            for camera, data in camera_masks.items():\n                viewer.render_segmentation2d(\n                    seconds=microseconds2seconds(sample.timestamp), camera=camera, **data\n                )\n\n            # TODO: add support of rendering keypoints\n            current_sample_token = sample.next\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper.__init__","title":"<code>__init__(t4)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>t4</code> <code>Tier4</code> <p><code>Tier4</code> instance.</p> required Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def __init__(self, t4: Tier4) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        t4 (Tier4): `Tier4` instance.\n    \"\"\"\n    self._t4 = t4\n    self._label2id: dict[str, int] = {\n        category.name: category.index for category in self._t4.category\n    }\n    self._sample_data_to_lidarseg_filename: dict[str, str] = {\n        lidarseg.sample_data_token: lidarseg.filename for lidarseg in self._t4.lidarseg\n    }\n\n    self._executor = concurrent.futures.ThreadPoolExecutor()\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper.render_instance","title":"<code>render_instance(instance_token, *, future_seconds=0.0, save_dir=None)</code>","text":"<p>Render particular instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance_token</code> <code>str | Sequence[str]</code> <p>Instance token(s).</p> required <code>future_seconds</code> <code>float</code> <p>Future time in [s].</p> <code>0.0</code> <code>save_dir</code> <code>str | None</code> <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> <code>None</code> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def render_instance(\n    self,\n    instance_token: str | Sequence[str],\n    *,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render particular instance.\n\n    Args:\n        instance_token (str | Sequence[str]): Instance token(s).\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n\n    \"\"\"\n    instance_tokens = [instance_token] if isinstance(instance_token, str) else instance_token\n\n    first_sample: Sample | None = None\n    last_sample: Sample | None = None\n    for token in instance_tokens:\n        instance: Instance = self._t4.get(\"instance\", token)\n        first_ann: SampleAnnotation = self._t4.get(\n            \"sample_annotation\", instance.first_annotation_token\n        )\n        current_first_sample: Sample = self._t4.get(\"sample\", first_ann.sample_token)\n        if first_sample is None or current_first_sample.timestamp &lt; first_sample.timestamp:\n            first_sample = current_first_sample\n\n        last_ann: SampleAnnotation = self._t4.get(\n            \"sample_annotation\", instance.last_annotation_token\n        )\n        current_last_sample: Sample = self._t4.get(\"sample\", last_ann.sample_token)\n        if last_sample is None or current_last_sample.timestamp &gt; last_sample.timestamp:\n            last_sample = current_last_sample\n\n    if first_sample is None or last_sample is None:\n        warnings.warn(\n            f\"There is no sample for the corresponding instance(s): {instance_tokens}\",\n            stacklevel=2,\n        )\n        return\n\n    max_timestamp_us = last_sample.timestamp\n\n    # search first sample data tokens\n    first_lidar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.LIDAR\n    ]\n    first_radar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.RADAR\n    ]\n    first_camera_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.CAMERA\n    ]\n\n    app_id = f\"instance@{self._t4.dataset_id}\"\n    contents = self._load_contents(RenderingMode.INSTANCE)\n    viewer = self._init_viewer(app_id, contents=contents, render_ann=True, save_dir=save_dir)\n\n    self._try_render_map(viewer)\n\n    pointcloud_color_mode = (\n        PointCloudColorMode.SEGMENTATION\n        if self._has_lidarseg()\n        else PointCloudColorMode.DISTANCE\n    )\n\n    futures = (\n        self._render_lidar_and_ego(\n            viewer=viewer,\n            first_lidar_tokens=first_lidar_tokens,\n            max_timestamp_us=max_timestamp_us,\n            color_mode=pointcloud_color_mode,\n        )\n        + self._render_radars(\n            viewer=viewer,\n            first_radar_tokens=first_radar_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + self._render_cameras(\n            viewer=viewer,\n            first_camera_tokens=first_camera_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + [\n            self._executor.submit(\n                self._render_annotation3ds,\n                viewer=viewer,\n                first_sample_token=first_sample.token,\n                max_timestamp_us=max_timestamp_us,\n                future_seconds=future_seconds,\n                instance_tokens=instance_tokens,\n            ),\n            self._executor.submit(\n                self._render_annotation2ds,\n                viewer=viewer,\n                first_sample_token=first_sample.token,\n                max_timestamp_us=max_timestamp_us,\n                instance_tokens=instance_tokens,\n            ),\n        ]\n    )\n\n    _handle_futures(futures)\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper.render_pointcloud","title":"<code>render_pointcloud(*, max_time_seconds=np.inf, save_dir=None)</code>","text":"<p>Render pointcloud on 3D and 2D view.</p> <p>Parameters:</p> Name Type Description Default <code>max_time_seconds</code> <code>float</code> <p>Max time length to be rendered [s].</p> <code>inf</code> <code>save_dir</code> <code>str | None</code> <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> <code>None</code> TODO <p>Add an option of rendering radar channels.</p> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def render_pointcloud(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render pointcloud on 3D and 2D view.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n\n    TODO:\n        Add an option of rendering radar channels.\n    \"\"\"\n    # search first lidar sample data token\n    first_lidar_token: str | None = None\n    first_camera_tokens: list[str] = []\n    for sensor in self._t4.sensor:\n        if sensor.modality == SensorModality.LIDAR:\n            first_lidar_token = sensor.first_sd_token\n        elif sensor.modality == SensorModality.CAMERA:\n            first_camera_tokens.append(sensor.first_sd_token)\n\n    if first_lidar_token is None:\n        raise ValueError(\"There is no 3D pointcloud data.\")\n\n    first_lidar_sample_data: SampleData = self._t4.get(\"sample_data\", first_lidar_token)\n    max_timestamp_us = first_lidar_sample_data.timestamp + seconds2microseconds(\n        max_time_seconds\n    )\n\n    app_id = f\"pointcloud@{self._t4.dataset_id}\"\n    contents = self._load_contents(\n        RenderingMode.POINTCLOUD,\n        entity_child=first_lidar_sample_data.channel,\n    )\n    viewer = self._init_viewer(app_id, contents=contents, render_ann=False, save_dir=save_dir)\n\n    self._try_render_map(viewer)\n\n    # TODO: support rendering segmentation pointcloud on camera\n    futures = self._render_lidar_and_ego(\n        viewer=viewer,\n        first_lidar_tokens=[first_lidar_token],\n        max_timestamp_us=max_timestamp_us,\n    ) + self._render_cameras(\n        viewer=viewer,\n        first_camera_tokens=first_camera_tokens,\n        max_timestamp_us=max_timestamp_us,\n    )\n\n    _handle_futures(futures)\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.RenderingHelper.render_scene","title":"<code>render_scene(*, max_time_seconds=np.inf, future_seconds=0.0, save_dir=None)</code>","text":"<p>Render specified scene.</p> <p>Parameters:</p> Name Type Description Default <code>max_time_seconds</code> <code>float</code> <p>Max time length to be rendered [s].</p> <code>inf</code> <code>future_seconds</code> <code>float</code> <p>Future time in [s].</p> <code>0.0</code> <code>save_dir</code> <code>str | None</code> <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> <code>None</code> Source code in <code>t4_devkit/helper/rendering.py</code> <pre><code>def render_scene(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render specified scene.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n    \"\"\"\n    # search first sample data tokens\n    first_lidar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.LIDAR\n    ]\n    first_radar_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.RADAR\n    ]\n    first_camera_tokens: list[str] = [\n        sensor.first_sd_token\n        for sensor in self._t4.sensor\n        if sensor.modality == SensorModality.CAMERA\n    ]\n\n    app_id = f\"scene@{self._t4.dataset_id}\"\n    contents = self._load_contents(RenderingMode.SCENE)\n    viewer = self._init_viewer(app_id, contents=contents, render_ann=True, save_dir=save_dir)\n\n    self._try_render_map(viewer)\n\n    scene: Scene = self._t4.scene[0]\n    first_sample: Sample = self._t4.get(\"sample\", scene.first_sample_token)\n    max_timestamp_us = first_sample.timestamp + seconds2microseconds(max_time_seconds)\n\n    pointcloud_color_mode = (\n        PointCloudColorMode.SEGMENTATION\n        if self._has_lidarseg()\n        else PointCloudColorMode.DISTANCE\n    )\n\n    futures = (\n        self._render_lidar_and_ego(\n            viewer=viewer,\n            first_lidar_tokens=first_lidar_tokens,\n            max_timestamp_us=max_timestamp_us,\n            color_mode=pointcloud_color_mode,\n        )\n        + self._render_radars(\n            viewer=viewer,\n            first_radar_tokens=first_radar_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + self._render_cameras(\n            viewer=viewer,\n            first_camera_tokens=first_camera_tokens,\n            max_timestamp_us=max_timestamp_us,\n        )\n        + [\n            self._executor.submit(\n                self._render_annotation3ds,\n                viewer=viewer,\n                first_sample_token=scene.first_sample_token,\n                max_timestamp_us=max_timestamp_us,\n                future_seconds=future_seconds,\n            ),\n            self._executor.submit(\n                self._render_annotation2ds,\n                viewer=viewer,\n                first_sample_token=scene.first_sample_token,\n                max_timestamp_us=max_timestamp_us,\n            ),\n        ]\n    )\n\n    _handle_futures(futures)\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.TimeseriesHelper","title":"<code>TimeseriesHelper</code>","text":"<p>Help <code>Tier4</code> class with timeseries relevant operations.</p> Source code in <code>t4_devkit/helper/timeseries.py</code> <pre><code>class TimeseriesHelper:\n    \"\"\"Help `Tier4` class with timeseries relevant operations.\"\"\"\n\n    def __init__(self, t4: Tier4) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            t4 (Tier4): `Tier4` instance.\n        \"\"\"\n        self._t4 = t4\n\n        self._sample_and_instance_to_ann3d: dict[tuple[str, str], str] = {\n            (ann.sample_token, ann.instance_token): ann.token for ann in self._t4.sample_annotation\n        }\n        self._sample_data_and_instance_to_ann2d: dict[tuple[str, str], str] = {\n            (ann.sample_data_token, ann.instance_token): ann.token for ann in self._t4.object_ann\n        }\n\n    def get_sample_annotations_until(\n        self,\n        instance_token: str,\n        sample_token: str,\n        seconds: float,\n    ) -&gt; tuple[list[int], list[SampleAnnotation]]:\n        \"\"\"Return a list of sample annotations until the specified seconds.\n\n        If `seconds&gt;=0` explores future, otherwise past.\n\n        Args:\n            instance_token (str): Instance token of any sample annotations.\n            sample_token (str): Start sample token.\n            seconds (float): Time seconds until. If `&gt;=0` explore future, otherwise past.\n\n        Returns:\n            List of timestamps and associated sample annotation records of the specified instance.\n        \"\"\"\n        start_sample: Sample = self._t4.get(\"sample\", sample_token)\n\n        timestamps: list[int] = []\n        anns: list[SampleAnnotation] = []\n        is_successor = seconds &gt;= 0\n        current_sample_token = start_sample.next if is_successor else start_sample.prev\n        while current_sample_token != \"\":\n            current_sample: Sample = self._t4.get(\"sample\", current_sample_token)\n\n            if abs(microseconds2seconds(current_sample.timestamp - start_sample.timestamp)) &gt; abs(\n                seconds\n            ):\n                break\n\n            ann_token = self._sample_and_instance_to_ann3d.get(\n                (current_sample_token, instance_token)\n            )\n            if ann_token is not None:\n                timestamps.append(current_sample.timestamp)\n                anns.append(self._t4.get(\"sample_annotation\", ann_token))\n\n            current_sample_token = current_sample.next if is_successor else current_sample.prev\n\n        return timestamps, anns\n\n    def get_object_anns_until(\n        self,\n        instance_token: str,\n        sample_data_token: str,\n        seconds: float,\n    ) -&gt; tuple[list[int], list[ObjectAnn]]:\n        \"\"\"Return a list of object anns until the specified seconds.\n\n        If `seconds&gt;=0` explores future, otherwise past.\n\n        Args:\n            instance_token (str): Instance token of any object anns.\n            sample_data_token (str): Start sample data token.\n            seconds (float): Time seconds until. If `&gt;=0` explore future, otherwise past.\n\n        Returns:\n            List of timestamps and associated object annotation records of the specified instance.\n        \"\"\"\n        start_sample_data: SampleData = self._t4.get(\"sample_data\", sample_data_token)\n\n        timestamps: list[int] = []\n        anns: list[ObjectAnn] = []\n        is_successor = seconds &gt;= 0\n        current_sample_data_token = (\n            start_sample_data.next if is_successor else start_sample_data.prev\n        )\n        while current_sample_data_token != \"\":\n            current_sample_data: SampleData = self._t4.get(\"sample_data\", current_sample_data_token)\n\n            if abs(\n                microseconds2seconds(current_sample_data.timestamp - start_sample_data.timestamp)\n            ) &gt; abs(seconds):\n                break\n\n            ann_token = self._sample_data_and_instance_to_ann2d.get(\n                (current_sample_data_token, instance_token)\n            )\n            if ann_token is not None:\n                timestamps.append(current_sample_data.timestamp)\n                anns.append(self._t4.get(\"object_ann\", ann_token))\n\n            current_sample_data_token = (\n                current_sample_data.next if is_successor else current_sample_data.prev\n            )\n\n        return timestamps, anns\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.TimeseriesHelper.__init__","title":"<code>__init__(t4)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>t4</code> <code>Tier4</code> <p><code>Tier4</code> instance.</p> required Source code in <code>t4_devkit/helper/timeseries.py</code> <pre><code>def __init__(self, t4: Tier4) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        t4 (Tier4): `Tier4` instance.\n    \"\"\"\n    self._t4 = t4\n\n    self._sample_and_instance_to_ann3d: dict[tuple[str, str], str] = {\n        (ann.sample_token, ann.instance_token): ann.token for ann in self._t4.sample_annotation\n    }\n    self._sample_data_and_instance_to_ann2d: dict[tuple[str, str], str] = {\n        (ann.sample_data_token, ann.instance_token): ann.token for ann in self._t4.object_ann\n    }\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.TimeseriesHelper.get_object_anns_until","title":"<code>get_object_anns_until(instance_token, sample_data_token, seconds)</code>","text":"<p>Return a list of object anns until the specified seconds.</p> <p>If <code>seconds&gt;=0</code> explores future, otherwise past.</p> <p>Parameters:</p> Name Type Description Default <code>instance_token</code> <code>str</code> <p>Instance token of any object anns.</p> required <code>sample_data_token</code> <code>str</code> <p>Start sample data token.</p> required <code>seconds</code> <code>float</code> <p>Time seconds until. If <code>&gt;=0</code> explore future, otherwise past.</p> required <p>Returns:</p> Type Description <code>tuple[list[int], list[ObjectAnn]]</code> <p>List of timestamps and associated object annotation records of the specified instance.</p> Source code in <code>t4_devkit/helper/timeseries.py</code> <pre><code>def get_object_anns_until(\n    self,\n    instance_token: str,\n    sample_data_token: str,\n    seconds: float,\n) -&gt; tuple[list[int], list[ObjectAnn]]:\n    \"\"\"Return a list of object anns until the specified seconds.\n\n    If `seconds&gt;=0` explores future, otherwise past.\n\n    Args:\n        instance_token (str): Instance token of any object anns.\n        sample_data_token (str): Start sample data token.\n        seconds (float): Time seconds until. If `&gt;=0` explore future, otherwise past.\n\n    Returns:\n        List of timestamps and associated object annotation records of the specified instance.\n    \"\"\"\n    start_sample_data: SampleData = self._t4.get(\"sample_data\", sample_data_token)\n\n    timestamps: list[int] = []\n    anns: list[ObjectAnn] = []\n    is_successor = seconds &gt;= 0\n    current_sample_data_token = (\n        start_sample_data.next if is_successor else start_sample_data.prev\n    )\n    while current_sample_data_token != \"\":\n        current_sample_data: SampleData = self._t4.get(\"sample_data\", current_sample_data_token)\n\n        if abs(\n            microseconds2seconds(current_sample_data.timestamp - start_sample_data.timestamp)\n        ) &gt; abs(seconds):\n            break\n\n        ann_token = self._sample_data_and_instance_to_ann2d.get(\n            (current_sample_data_token, instance_token)\n        )\n        if ann_token is not None:\n            timestamps.append(current_sample_data.timestamp)\n            anns.append(self._t4.get(\"object_ann\", ann_token))\n\n        current_sample_data_token = (\n            current_sample_data.next if is_successor else current_sample_data.prev\n        )\n\n    return timestamps, anns\n</code></pre>"},{"location":"apis/helper/#t4_devkit.helper.TimeseriesHelper.get_sample_annotations_until","title":"<code>get_sample_annotations_until(instance_token, sample_token, seconds)</code>","text":"<p>Return a list of sample annotations until the specified seconds.</p> <p>If <code>seconds&gt;=0</code> explores future, otherwise past.</p> <p>Parameters:</p> Name Type Description Default <code>instance_token</code> <code>str</code> <p>Instance token of any sample annotations.</p> required <code>sample_token</code> <code>str</code> <p>Start sample token.</p> required <code>seconds</code> <code>float</code> <p>Time seconds until. If <code>&gt;=0</code> explore future, otherwise past.</p> required <p>Returns:</p> Type Description <code>tuple[list[int], list[SampleAnnotation]]</code> <p>List of timestamps and associated sample annotation records of the specified instance.</p> Source code in <code>t4_devkit/helper/timeseries.py</code> <pre><code>def get_sample_annotations_until(\n    self,\n    instance_token: str,\n    sample_token: str,\n    seconds: float,\n) -&gt; tuple[list[int], list[SampleAnnotation]]:\n    \"\"\"Return a list of sample annotations until the specified seconds.\n\n    If `seconds&gt;=0` explores future, otherwise past.\n\n    Args:\n        instance_token (str): Instance token of any sample annotations.\n        sample_token (str): Start sample token.\n        seconds (float): Time seconds until. If `&gt;=0` explore future, otherwise past.\n\n    Returns:\n        List of timestamps and associated sample annotation records of the specified instance.\n    \"\"\"\n    start_sample: Sample = self._t4.get(\"sample\", sample_token)\n\n    timestamps: list[int] = []\n    anns: list[SampleAnnotation] = []\n    is_successor = seconds &gt;= 0\n    current_sample_token = start_sample.next if is_successor else start_sample.prev\n    while current_sample_token != \"\":\n        current_sample: Sample = self._t4.get(\"sample\", current_sample_token)\n\n        if abs(microseconds2seconds(current_sample.timestamp - start_sample.timestamp)) &gt; abs(\n            seconds\n        ):\n            break\n\n        ann_token = self._sample_and_instance_to_ann3d.get(\n            (current_sample_token, instance_token)\n        )\n        if ann_token is not None:\n            timestamps.append(current_sample.timestamp)\n            anns.append(self._t4.get(\"sample_annotation\", ann_token))\n\n        current_sample_token = current_sample.next if is_successor else current_sample.prev\n\n    return timestamps, anns\n</code></pre>"},{"location":"apis/sanity/","title":"<code>sanity</code>","text":""},{"location":"apis/sanity/#t4_devkit.sanity.Checker","title":"<code>Checker</code>","text":"<p>Base class for sanity checkers.</p> Source code in <code>t4_devkit/sanity/checker.py</code> <pre><code>class Checker(ABC):\n    \"\"\"Base class for sanity checkers.\"\"\"\n\n    id: RuleID\n    name: RuleName\n    description: str\n    severity: Severity\n\n    def __call__(self, context: SanityContext, fix: bool = False) -&gt; Report:\n        \"\"\"Run the checker and return a report.\n\n        The issues will be fixed if the checker is fixable, `fix` is True and\n            the checker returns a list of failure or warning reasons (not `None`).\n\n        Args:\n            context (SanityContext): The sanity context.\n            fix (bool, optional): Whether to attempt to fix the issue.\n\n        Returns:\n            A report containing the results of the checker.\n        \"\"\"\n        match self.can_skip(context):\n            case Some(skip):\n                return make_skipped(self.id, self.name, self.severity, self.description, skip)\n\n        reasons = self.check(context)\n        fixed = self.fix(context) if fix and reasons else False\n        return make_report(self.id, self.name, self.severity, self.description, reasons, fixed)\n\n    def can_skip(self, context: SanityContext) -&gt; Maybe[Reason]:\n        \"\"\"Return a skip reason if the checker should be skipped.\n\n        Args:\n            context (SanityContext): The sanity context.\n\n        Returns:\n            A skip reason if the checker should be skipped, or Nothing if it should not be skipped.\n        \"\"\"\n        return Nothing\n\n    @abstractmethod\n    def check(self, context: SanityContext) -&gt; list[Reason] | None:\n        \"\"\"Return a list of reasons if the checker fails, or None if it passes.\n\n        Args:\n            context (SanityContext): The sanity context.\n\n        Returns:\n            A list of reasons if the checker fails, or None if it passes.\n        \"\"\"\n        pass\n\n    def fix(self, context: SanityContext) -&gt; bool:\n        \"\"\"Fix the issue reported by the checker.\n\n        Args:\n            context (SanityContext): The sanity context.\n\n        Returns:\n            True if the issue was fixed, False otherwise.\n        \"\"\"\n        return False\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Checker.__call__","title":"<code>__call__(context, fix=False)</code>","text":"<p>Run the checker and return a report.</p> <p>The issues will be fixed if the checker is fixable, <code>fix</code> is True and     the checker returns a list of failure or warning reasons (not <code>None</code>).</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SanityContext</code> <p>The sanity context.</p> required <code>fix</code> <code>bool</code> <p>Whether to attempt to fix the issue.</p> <code>False</code> <p>Returns:</p> Type Description <code>Report</code> <p>A report containing the results of the checker.</p> Source code in <code>t4_devkit/sanity/checker.py</code> <pre><code>def __call__(self, context: SanityContext, fix: bool = False) -&gt; Report:\n    \"\"\"Run the checker and return a report.\n\n    The issues will be fixed if the checker is fixable, `fix` is True and\n        the checker returns a list of failure or warning reasons (not `None`).\n\n    Args:\n        context (SanityContext): The sanity context.\n        fix (bool, optional): Whether to attempt to fix the issue.\n\n    Returns:\n        A report containing the results of the checker.\n    \"\"\"\n    match self.can_skip(context):\n        case Some(skip):\n            return make_skipped(self.id, self.name, self.severity, self.description, skip)\n\n    reasons = self.check(context)\n    fixed = self.fix(context) if fix and reasons else False\n    return make_report(self.id, self.name, self.severity, self.description, reasons, fixed)\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Checker.can_skip","title":"<code>can_skip(context)</code>","text":"<p>Return a skip reason if the checker should be skipped.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SanityContext</code> <p>The sanity context.</p> required <p>Returns:</p> Type Description <code>Maybe[Reason]</code> <p>A skip reason if the checker should be skipped, or Nothing if it should not be skipped.</p> Source code in <code>t4_devkit/sanity/checker.py</code> <pre><code>def can_skip(self, context: SanityContext) -&gt; Maybe[Reason]:\n    \"\"\"Return a skip reason if the checker should be skipped.\n\n    Args:\n        context (SanityContext): The sanity context.\n\n    Returns:\n        A skip reason if the checker should be skipped, or Nothing if it should not be skipped.\n    \"\"\"\n    return Nothing\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Checker.check","title":"<code>check(context)</code>  <code>abstractmethod</code>","text":"<p>Return a list of reasons if the checker fails, or None if it passes.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SanityContext</code> <p>The sanity context.</p> required <p>Returns:</p> Type Description <code>list[Reason] | None</code> <p>A list of reasons if the checker fails, or None if it passes.</p> Source code in <code>t4_devkit/sanity/checker.py</code> <pre><code>@abstractmethod\ndef check(self, context: SanityContext) -&gt; list[Reason] | None:\n    \"\"\"Return a list of reasons if the checker fails, or None if it passes.\n\n    Args:\n        context (SanityContext): The sanity context.\n\n    Returns:\n        A list of reasons if the checker fails, or None if it passes.\n    \"\"\"\n    pass\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Checker.fix","title":"<code>fix(context)</code>","text":"<p>Fix the issue reported by the checker.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SanityContext</code> <p>The sanity context.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the issue was fixed, False otherwise.</p> Source code in <code>t4_devkit/sanity/checker.py</code> <pre><code>def fix(self, context: SanityContext) -&gt; bool:\n    \"\"\"Fix the issue reported by the checker.\n\n    Args:\n        context (SanityContext): The sanity context.\n\n    Returns:\n        True if the issue was fixed, False otherwise.\n    \"\"\"\n    return False\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.CheckerRegistry","title":"<code>CheckerRegistry</code>","text":"Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>class CheckerRegistry(dict[RuleGroup, dict[RuleID, type[Checker]]]):\n    def register(self) -&gt; Callable:\n        \"\"\"Register a checker class.\n\n        Returns:\n            A decorator function that registers the checker class.\n        \"\"\"\n\n        def _register_decorator(module: type[Checker]) -&gt; type[Checker]:\n            self._add_module(module)\n            return module\n\n        return _register_decorator\n\n    def _add_module(self, module: type[Checker]) -&gt; None:\n        if not inspect.isclass(module):\n            raise TypeError(f\"module must be a class, but got {type(module)}.\")\n\n        group = RuleGroup.to_group(module.id)\n\n        if group is None:\n            raise ValueError(\n                f\"'{module.id}' doesn't belong to any rule groups: {RuleGroup.values()}\"\n            )\n\n        if group not in self:\n            self[group] = {}\n\n        if module.id in self[group]:\n            raise ValueError(f\"'{module.id}' has already been registered.\")\n\n        self[group][module.id] = module\n\n    def build(self, excludes: Sequence[str] | None = None) -&gt; list[Checker]:\n        \"\"\"Build a list of checkers from the registry.\n\n        Args:\n            excludes (Sequence[str] | None, optional): A list of rule IDs or rule groups to exclude.\n\n        Returns:\n            A list of checkers.\n        \"\"\"\n        if excludes is None:\n            excludes = []\n\n        return [\n            checker()\n            for group, values in self.items()\n            for id, checker in values.items()\n            if id not in excludes and group.value not in excludes\n        ]\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.CheckerRegistry.build","title":"<code>build(excludes=None)</code>","text":"<p>Build a list of checkers from the registry.</p> <p>Parameters:</p> Name Type Description Default <code>excludes</code> <code>Sequence[str] | None</code> <p>A list of rule IDs or rule groups to exclude.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[Checker]</code> <p>A list of checkers.</p> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>def build(self, excludes: Sequence[str] | None = None) -&gt; list[Checker]:\n    \"\"\"Build a list of checkers from the registry.\n\n    Args:\n        excludes (Sequence[str] | None, optional): A list of rule IDs or rule groups to exclude.\n\n    Returns:\n        A list of checkers.\n    \"\"\"\n    if excludes is None:\n        excludes = []\n\n    return [\n        checker()\n        for group, values in self.items()\n        for id, checker in values.items()\n        if id not in excludes and group.value not in excludes\n    ]\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.CheckerRegistry.register","title":"<code>register()</code>","text":"<p>Register a checker class.</p> <p>Returns:</p> Type Description <code>Callable</code> <p>A decorator function that registers the checker class.</p> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>def register(self) -&gt; Callable:\n    \"\"\"Register a checker class.\n\n    Returns:\n        A decorator function that registers the checker class.\n    \"\"\"\n\n    def _register_decorator(module: type[Checker]) -&gt; type[Checker]:\n        self._add_module(module)\n        return module\n\n    return _register_decorator\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Report","title":"<code>Report</code>","text":"<p>A report for a rule.</p> <p>Attributes:</p> Name Type Description <code>id</code> <code>RuleID</code> <p>The ID of the rule.</p> <code>name</code> <code>RuleName</code> <p>The name of the rule.</p> <code>severity</code> <code>Severity</code> <p>The severity of the rule.</p> <code>description</code> <code>str</code> <p>The description of the rule.</p> <code>status</code> <code>Status</code> <p>The status of the report.</p> <code>reasons</code> <code>list[Reason] | None</code> <p>The list of reasons for the report if the report is a failure or skipped.</p> <code>fixed</code> <code>bool</code> <p>Whether the report is fixed.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>@define\nclass Report:\n    \"\"\"A report for a rule.\n\n    Attributes:\n        id (RuleID): The ID of the rule.\n        name (RuleName): The name of the rule.\n        severity (Severity): The severity of the rule.\n        description (str): The description of the rule.\n        status (Status): The status of the report.\n        reasons (list[Reason] | None): The list of reasons for the report if the report is a failure or skipped.\n        fixed (bool): Whether the report is fixed.\n    \"\"\"\n\n    id: RuleID\n    name: RuleName\n    severity: Severity\n    description: str\n    status: Status\n    reasons: list[Reason] | None = field(default=None)\n    fixed: bool = False\n\n    def __attrs_post_init__(self) -&gt; None:\n        if self.status == Status.PASSED:\n            assert self.reasons is None, \"Passed report cannot have reasons\"\n        else:\n            assert self.reasons is not None, \"Non-passed report must have reasons\"\n\n    def is_passed(self, *, strict: bool = False) -&gt; bool:\n        \"\"\"Check if the status is passed.\"\"\"\n        return (\n            self.status == Status.PASSED\n            or self.is_skipped()\n            or (not strict and self.severity.is_warning())\n            or self.fixed\n        )\n\n    def is_failed(self, *, strict: bool = False) -&gt; bool:\n        \"\"\"Check if the status is failed.\"\"\"\n        return (self.status == Status.FAILED and self.severity.is_error()) or not (\n            self.is_passed(strict=strict) or self.is_skipped()\n        )\n\n    def is_skipped(self) -&gt; bool:\n        \"\"\"Check if the status is skipped.\"\"\"\n        return self.status == Status.SKIPPED\n\n    def to_str(self, *, strict: bool = False) -&gt; str:\n        \"\"\"Return a string representation of the report.\n\n        Args:\n            strict (bool): Whether to consider warnings as failures.\n\n        Returns:\n            A string representation of the report.\n        \"\"\"\n        parts = []\n        if not self.is_passed(strict=strict):\n            # print failure reasons\n            parts.append(f\"{Fore.RED}  {self.id}:\\n\")\n            for reason in self.reasons or []:\n                parts.append(f\"{Fore.RED}     - {reason}\\n\")\n        elif self.is_skipped():\n            # print skipped reasons\n            parts.append(f\"{Fore.CYAN}  {self.id}: [SKIPPED]\\n\")\n            for reason in self.reasons or []:\n                parts.append(f\"{Fore.CYAN}     - {reason}\\n\")\n        elif self.severity.is_warning() and self.reasons:\n            # print warning reasons\n            parts.append(f\"{Fore.YELLOW}  {self.id}:\\n\")\n            for reason in self.reasons or []:\n                parts.append(f\"{Fore.YELLOW}     - {reason}\\n\")\n        elif self.is_passed() and self.fixed:\n            # print failure or warning but fixed reasons\n            parts.append(f\"{Fore.GREEN}  {self.id}: --&gt; FIXED \u2705\\n\")\n            for reason in self.reasons or []:\n                parts.append(f\"{Fore.GREEN}     - {reason}\\n\")\n        else:\n            # print passed\n            parts.append(f\"{Fore.GREEN}  {self.id}: \u2705\\n\")\n        parts.append(f\"{Fore.RESET}\")\n        return \"\".join(parts)\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Report.is_failed","title":"<code>is_failed(*, strict=False)</code>","text":"<p>Check if the status is failed.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_failed(self, *, strict: bool = False) -&gt; bool:\n    \"\"\"Check if the status is failed.\"\"\"\n    return (self.status == Status.FAILED and self.severity.is_error()) or not (\n        self.is_passed(strict=strict) or self.is_skipped()\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Report.is_passed","title":"<code>is_passed(*, strict=False)</code>","text":"<p>Check if the status is passed.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_passed(self, *, strict: bool = False) -&gt; bool:\n    \"\"\"Check if the status is passed.\"\"\"\n    return (\n        self.status == Status.PASSED\n        or self.is_skipped()\n        or (not strict and self.severity.is_warning())\n        or self.fixed\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Report.is_skipped","title":"<code>is_skipped()</code>","text":"<p>Check if the status is skipped.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_skipped(self) -&gt; bool:\n    \"\"\"Check if the status is skipped.\"\"\"\n    return self.status == Status.SKIPPED\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Report.to_str","title":"<code>to_str(*, strict=False)</code>","text":"<p>Return a string representation of the report.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>Whether to consider warnings as failures.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the report.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def to_str(self, *, strict: bool = False) -&gt; str:\n    \"\"\"Return a string representation of the report.\n\n    Args:\n        strict (bool): Whether to consider warnings as failures.\n\n    Returns:\n        A string representation of the report.\n    \"\"\"\n    parts = []\n    if not self.is_passed(strict=strict):\n        # print failure reasons\n        parts.append(f\"{Fore.RED}  {self.id}:\\n\")\n        for reason in self.reasons or []:\n            parts.append(f\"{Fore.RED}     - {reason}\\n\")\n    elif self.is_skipped():\n        # print skipped reasons\n        parts.append(f\"{Fore.CYAN}  {self.id}: [SKIPPED]\\n\")\n        for reason in self.reasons or []:\n            parts.append(f\"{Fore.CYAN}     - {reason}\\n\")\n    elif self.severity.is_warning() and self.reasons:\n        # print warning reasons\n        parts.append(f\"{Fore.YELLOW}  {self.id}:\\n\")\n        for reason in self.reasons or []:\n            parts.append(f\"{Fore.YELLOW}     - {reason}\\n\")\n    elif self.is_passed() and self.fixed:\n        # print failure or warning but fixed reasons\n        parts.append(f\"{Fore.GREEN}  {self.id}: --&gt; FIXED \u2705\\n\")\n        for reason in self.reasons or []:\n            parts.append(f\"{Fore.GREEN}     - {reason}\\n\")\n    else:\n        # print passed\n        parts.append(f\"{Fore.GREEN}  {self.id}: \u2705\\n\")\n    parts.append(f\"{Fore.RESET}\")\n    return \"\".join(parts)\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.RuleGroup","title":"<code>RuleGroup</code>","text":"Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>@unique\nclass RuleGroup(Enum):\n    STRUCTURE = \"STR\"\n    RECORD = \"REC\"\n    REFERENCE = \"REF\"\n    FORMAT = \"FMT\"\n    TIERIV = \"TIV\"\n\n    @classmethod\n    def values(cls) -&gt; list[str]:\n        \"\"\"Return a list of all rule group values.\"\"\"\n        return [group.value for group in cls]\n\n    @classmethod\n    def to_group(cls, id: RuleID) -&gt; RuleGroup | None:\n        \"\"\"Convert a rule ID to a rule group.\n\n        Args:\n            id (RuleID): The ID of the rule.\n\n        Returns:\n            The rule group if the rule ID belongs to any rule group, otherwise None.\n        \"\"\"\n        for g in RuleGroup:\n            if g.value in id:\n                return g\n        return None\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.RuleGroup.to_group","title":"<code>to_group(id)</code>  <code>classmethod</code>","text":"<p>Convert a rule ID to a rule group.</p> <p>Parameters:</p> Name Type Description Default <code>id</code> <code>RuleID</code> <p>The ID of the rule.</p> required <p>Returns:</p> Type Description <code>RuleGroup | None</code> <p>The rule group if the rule ID belongs to any rule group, otherwise None.</p> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>@classmethod\ndef to_group(cls, id: RuleID) -&gt; RuleGroup | None:\n    \"\"\"Convert a rule ID to a rule group.\n\n    Args:\n        id (RuleID): The ID of the rule.\n\n    Returns:\n        The rule group if the rule ID belongs to any rule group, otherwise None.\n    \"\"\"\n    for g in RuleGroup:\n        if g.value in id:\n            return g\n    return None\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.RuleGroup.values","title":"<code>values()</code>  <code>classmethod</code>","text":"<p>Return a list of all rule group values.</p> Source code in <code>t4_devkit/sanity/registry.py</code> <pre><code>@classmethod\ndef values(cls) -&gt; list[str]:\n    \"\"\"Return a list of all rule group values.\"\"\"\n    return [group.value for group in cls]\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult","title":"<code>SanityResult</code>","text":"<p>The result of a Sanity check.</p> <p>Attributes:</p> Name Type Description <code>dataset_id</code> <code>str</code> <p>The ID of the dataset.</p> <code>version</code> <code>str | None</code> <p>The version of the dataset.</p> <code>reports</code> <code>list[Report]</code> <p>The list of reports.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>@define\nclass SanityResult:\n    \"\"\"The result of a Sanity check.\n\n    Attributes:\n        dataset_id (str): The ID of the dataset.\n        version (str | None): The version of the dataset.\n        reports (list[Report]): The list of reports.\n    \"\"\"\n\n    dataset_id: str\n    version: str | None\n    reports: list[Report]\n\n    @classmethod\n    def from_context(cls, context: SanityContext, reports: list[Report]) -&gt; Self:\n        \"\"\"Create a SanityResult from a SanityContext and a list of reports.\n\n        Args:\n            context (SanityContext): The SanityContext to use.\n            reports (list[Report]): The list of reports to include in the result.\n\n        Returns:\n            The created SanityResult.\n        \"\"\"\n        return cls(\n            dataset_id=context.dataset_id.value_or(\"UNKNOWN\"),\n            version=context.version.value_or(None),\n            reports=reports,\n        )\n\n    def is_passed(self, *, strict: bool = False) -&gt; bool:\n        \"\"\"Return True if all reports are passed, False otherwise.\n\n        Args:\n            strict (bool): Whether to consider warnings as failures.\n\n        Returns:\n            True if all reports are passed, False otherwise.\n        \"\"\"\n        return all(report.is_passed(strict=strict) for report in self.reports)\n\n    def to_str(self, *, strict: bool = False) -&gt; str:\n        \"\"\"Return a string representation of the result.\n\n        Args:\n            strict (bool): Whether to consider warnings as failures.\n\n        Returns:\n            A string representation of the result.\n        \"\"\"\n        return f\"=== DatasetID: {self.dataset_id} ===\\n\" + \"\".join(\n            report.to_str(strict=strict) for report in self.reports\n        )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult.from_context","title":"<code>from_context(context, reports)</code>  <code>classmethod</code>","text":"<p>Create a SanityResult from a SanityContext and a list of reports.</p> <p>Parameters:</p> Name Type Description Default <code>context</code> <code>SanityContext</code> <p>The SanityContext to use.</p> required <code>reports</code> <code>list[Report]</code> <p>The list of reports to include in the result.</p> required <p>Returns:</p> Type Description <code>Self</code> <p>The created SanityResult.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>@classmethod\ndef from_context(cls, context: SanityContext, reports: list[Report]) -&gt; Self:\n    \"\"\"Create a SanityResult from a SanityContext and a list of reports.\n\n    Args:\n        context (SanityContext): The SanityContext to use.\n        reports (list[Report]): The list of reports to include in the result.\n\n    Returns:\n        The created SanityResult.\n    \"\"\"\n    return cls(\n        dataset_id=context.dataset_id.value_or(\"UNKNOWN\"),\n        version=context.version.value_or(None),\n        reports=reports,\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult.is_passed","title":"<code>is_passed(*, strict=False)</code>","text":"<p>Return True if all reports are passed, False otherwise.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>Whether to consider warnings as failures.</p> <code>False</code> <p>Returns:</p> Type Description <code>bool</code> <p>True if all reports are passed, False otherwise.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def is_passed(self, *, strict: bool = False) -&gt; bool:\n    \"\"\"Return True if all reports are passed, False otherwise.\n\n    Args:\n        strict (bool): Whether to consider warnings as failures.\n\n    Returns:\n        True if all reports are passed, False otherwise.\n    \"\"\"\n    return all(report.is_passed(strict=strict) for report in self.reports)\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.SanityResult.to_str","title":"<code>to_str(*, strict=False)</code>","text":"<p>Return a string representation of the result.</p> <p>Parameters:</p> Name Type Description Default <code>strict</code> <code>bool</code> <p>Whether to consider warnings as failures.</p> <code>False</code> <p>Returns:</p> Type Description <code>str</code> <p>A string representation of the result.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def to_str(self, *, strict: bool = False) -&gt; str:\n    \"\"\"Return a string representation of the result.\n\n    Args:\n        strict (bool): Whether to consider warnings as failures.\n\n    Returns:\n        A string representation of the result.\n    \"\"\"\n    return f\"=== DatasetID: {self.dataset_id} ===\\n\" + \"\".join(\n        report.to_str(strict=strict) for report in self.reports\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.Status","title":"<code>Status</code>","text":"<p>Runtime outcome per checker.</p> Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>class Status(str, Enum):\n    \"\"\"Runtime outcome per checker.\"\"\"\n\n    PASSED = \"PASSED\"\n    FAILED = \"FAILED\"\n    SKIPPED = \"SKIPPED\"\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.print_sanity_result","title":"<code>print_sanity_result(result, *, strict=False)</code>","text":"<p>Print detailed and summary results of a sanity check.</p> <p>Parameters:</p> Name Type Description Default <code>result</code> <code>SanityResult</code> <p>The result of a sanity check.</p> required Source code in <code>t4_devkit/sanity/result.py</code> <pre><code>def print_sanity_result(result: SanityResult, *, strict: bool = False) -&gt; None:\n    \"\"\"Print detailed and summary results of a sanity check.\n\n    Args:\n        result (SanityResult): The result of a sanity check.\n    \"\"\"\n    # print detailed result\n    print(result.to_str(strict=strict))\n\n    # print summary result\n    passed = sum(1 for rp in result.reports if rp.is_passed(strict=strict))\n    failed = sum(1 for rp in result.reports if not rp.is_passed(strict=strict))\n    skipped = sum(1 for rp in result.reports if rp.is_skipped())\n\n    # just count the number of warnings\n    warnings = sum(1 for rp in result.reports if rp.severity.is_warning() and rp.reasons)\n\n    # count the number of fixed issues\n    fixed = sum(1 for rp in result.reports if rp.fixed)\n\n    summary_rows = [[result.dataset_id, result.version, passed, failed, skipped, warnings, fixed]]\n\n    print(\n        tabulate(\n            summary_rows,\n            headers=[\"DatasetID\", \"Version\", \"Passed\", \"Failed\", \"Skipped\", \"Warnings\", \"Fixed\"],\n            tablefmt=\"pretty\",\n        ),\n    )\n</code></pre>"},{"location":"apis/sanity/#t4_devkit.sanity.sanity_check","title":"<code>sanity_check(data_root, revision=None, *, excludes=None, fix=False)</code>","text":"<p>Run sanity checks on the given data root.</p> <p>Parameters:</p> Name Type Description Default <code>data_root</code> <code>str</code> <p>The root directory of the data.</p> required <code>revision</code> <code>str | None</code> <p>The revision to check. If None, the latest revision is used.</p> <code>None</code> <code>excludes</code> <code>Sequence[str] | None</code> <p>A list of rule names or groups to exclude.</p> <code>None</code> <code>fix</code> <code>bool</code> <p>Attempt to fix the issues reported by the sanity check.</p> <code>False</code> <p>Returns:</p> Type Description <code>SanityResult</code> <p>A SanityResult object.</p> Source code in <code>t4_devkit/sanity/run.py</code> <pre><code>def sanity_check(\n    data_root: str,\n    revision: str | None = None,\n    *,\n    excludes: Sequence[str] | None = None,\n    fix: bool = False,\n) -&gt; SanityResult:\n    \"\"\"Run sanity checks on the given data root.\n\n    Args:\n        data_root (str): The root directory of the data.\n        revision (str | None, optional): The revision to check. If None, the latest revision is used.\n        excludes (Sequence[str] | None, optional): A list of rule names or groups to exclude.\n        fix (bool, optional): Attempt to fix the issues reported by the sanity check.\n\n    Returns:\n        A SanityResult object.\n    \"\"\"\n    context = SanityContext.from_path(data_root, revision=revision)\n\n    checkers = CHECKERS.build(excludes=excludes)\n    reports = [checker(context, fix=fix) for checker in checkers]\n\n    return SanityResult.from_context(context, reports)\n</code></pre>"},{"location":"apis/tier4/","title":"TIER IV API","text":""},{"location":"apis/tier4/#t4_devkit.tier4.DBMetadata","title":"<code>DBMetadata</code>","text":"<p>A dataclass to represent dataset metadata.</p> <p>Attributes:</p> Name Type Description <code>data_root</code> <code>str</code> <p>Root directory path.</p> <code>dataset_id</code> <code>str</code> <p>Unique dataset ID.</p> <code>version</code> <code>str | None</code> <p>Dataset version.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>@define\nclass DBMetadata:\n    \"\"\"A dataclass to represent dataset metadata.\n\n    Attributes:\n        data_root (str): Root directory path.\n        dataset_id (str): Unique dataset ID.\n        version (str | None): Dataset version.\n    \"\"\"\n\n    data_root: str\n    dataset_id: str\n    version: str | None\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4","title":"<code>Tier4</code>","text":"<p>Database class for T4 dataset to help query and retrieve information from the database.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>class Tier4:\n    \"\"\"Database class for T4 dataset to help query and retrieve information from the database.\"\"\"\n\n    def __init__(\n        self,\n        data_root: str,\n        revision: str | None = None,\n        verbose: bool = True,\n    ) -&gt; None:\n        \"\"\"Load database and creates reverse indexes and shortcuts.\n\n        Args:\n            data_root (str): Path to the root directory of dataset.\n            revision (str | None, optional): You can specify any specific version if you want.\n                If None, search the latest one.\n            verbose (bool, optional): Whether to display status during load.\n\n        Examples:\n            &gt;&gt;&gt; from t4_devkit import Tier4\n            &gt;&gt;&gt; t4 = Tier4(\"data/tier4\")\n            ======\n            Loading T4 tables in `annotation`...\n            Reverse indexing...\n            Done reverse indexing in 0.010 seconds.\n            ======\n            21 category\n            8 attribute\n            4 visibility\n            31 instance\n            7 sensor\n            7 calibrated_sensor\n            2529 ego_pose\n            1 log\n            1 scene\n            88 sample\n            2529 sample_data\n            1919 sample_annotation\n            0 object_ann\n            0 surface_ann\n            0 keypoint\n            1 map\n            Done loading in 0.046 seconds.\n            ======\n\n        \"\"\"\n        self._metadata = load_metadata(data_root, revision)\n\n        if not osp.exists(self.data_root):\n            raise FileNotFoundError(f\"Database directory is not found: {self.data_root}\")\n\n        if self.version is None:\n            warnings.warn(\n                f\"DatasetID: {self.dataset_id} does't contain any versions.\", DeprecationWarning\n            )\n\n        start_time = time.time()\n        if verbose:\n            print(\"======\\nLoading T4 tables...\")\n\n        # assign tables explicitly\n        self.attribute: list[Attribute] = load_table(self.annotation_dir, SchemaName.ATTRIBUTE)\n        self.calibrated_sensor: list[CalibratedSensor] = load_table(\n            self.annotation_dir, SchemaName.CALIBRATED_SENSOR\n        )\n        self.category: list[Category] = load_table(self.annotation_dir, SchemaName.CATEGORY)\n        self.category = fix_category_table(self.category)\n\n        self.ego_pose: list[EgoPose] = load_table(self.annotation_dir, SchemaName.EGO_POSE)\n        self.instance: list[Instance] = load_table(self.annotation_dir, SchemaName.INSTANCE)\n        self.keypoint: list[Keypoint] = load_table(self.annotation_dir, SchemaName.KEYPOINT)\n        self.lidarseg: list[LidarSeg] = load_table(self.annotation_dir, SchemaName.LIDARSEG)\n        self.log: list[Log] = load_table(self.annotation_dir, SchemaName.LOG)\n        self.map: list[Map] = load_table(self.annotation_dir, SchemaName.MAP)\n        self.object_ann: list[ObjectAnn] = load_table(self.annotation_dir, SchemaName.OBJECT_ANN)\n        self.sample_annotation: list[SampleAnnotation] = load_table(\n            self.annotation_dir, SchemaName.SAMPLE_ANNOTATION\n        )\n        self.sample_data: list[SampleData] = load_table(self.annotation_dir, SchemaName.SAMPLE_DATA)\n        self.sample: list[Sample] = load_table(self.annotation_dir, SchemaName.SAMPLE)\n        self.scene: list[Scene] = load_table(self.annotation_dir, SchemaName.SCENE)\n        self.sensor: list[Sensor] = load_table(self.annotation_dir, SchemaName.SENSOR)\n        self.surface_ann: list[SurfaceAnn] = load_table(self.annotation_dir, SchemaName.SURFACE_ANN)\n        self.vehicle_state: list[VehicleState] = load_table(\n            self.annotation_dir, SchemaName.VEHICLE_STATE\n        )\n        self.visibility: list[Visibility] = load_table(self.annotation_dir, SchemaName.VISIBILITY)\n\n        # make reverse indexes for common lookups\n        self.__make_reverse_index__(verbose)\n\n        if verbose:\n            for schema in SchemaName:\n                print(f\"{len(self.get_table(schema))} {schema.value}\")\n            elapsed_time = time.time() - start_time\n            print(f\"Done loading in {elapsed_time:.3f} seconds.\\n======\")\n\n        # initialize helpers after finishing construction of Tier4\n        self._timeseries_helper = TimeseriesHelper(self)\n        self._rendering_helper = RenderingHelper(self)\n\n    @property\n    def data_root(self) -&gt; str:\n        \"\"\"Return the path to dataset root directory.\"\"\"\n        return self._metadata.data_root\n\n    @property\n    def dataset_id(self) -&gt; str:\n        \"\"\"Return the dataset ID.\"\"\"\n        return self._metadata.dataset_id\n\n    @property\n    def version(self) -&gt; str | None:\n        \"\"\"Return the dataset version, or None if it is failed to lookup.\"\"\"\n        return self._metadata.version\n\n    @property\n    def annotation_dir(self) -&gt; str:\n        \"\"\"Return the path to annotation directory.\"\"\"\n        return osp.join(self.data_root, \"annotation\")\n\n    @property\n    def map_dir(self) -&gt; str:\n        \"\"\"Return the path to map directory.\"\"\"\n        return osp.join(self.data_root, \"map\")\n\n    @property\n    def bag_dir(self) -&gt; str:\n        \"\"\"Return the path to ROS bag directory.\"\"\"\n        return osp.join(self.data_root, \"input_bag\")\n\n    def __make_reverse_index__(self, verbose: bool) -&gt; None:\n        \"\"\"De-normalize database to create reverse indices for common cases.\n\n        Args:\n            verbose (bool): Whether to display outputs.\n\n        Raises:\n            ValueError: Expecting `map` table has `log_tokens` key.\n        \"\"\"\n        start_time = time.time()\n        if verbose:\n            print(\"Reverse indexing...\")\n\n        self._token2idx: dict[str, dict[str, int]] = {\n            schema.value: {\n                table.token: idx for idx, table in enumerate(self.get_table(schema.value))\n            }\n            for schema in SchemaName\n        }\n\n        self._label2id: dict[str, int] = {\n            category.name: category.index for category in self.category\n        }\n\n        # add shortcuts\n        for record in self.sample_annotation:\n            instance: Instance = self.get(\"instance\", record.instance_token)\n            category: Category = self.get(\"category\", instance.category_token)\n            record.category_name = category.name\n\n        for record in self.object_ann:\n            category: Category = self.get(\"category\", record.category_token)\n            record.category_name = category.name\n\n        for record in self.surface_ann:\n            if record.category_token == \"\":  # NOTE: Some database contains this case\n                warnings.warn(f\"Category token is empty for surface ann: {record.token}\")\n                continue\n            category: Category = self.get(\"category\", record.category_token)\n            record.category_name = category.name\n\n        registered_channels: list[str] = []\n        for record in self.sample_data:\n            cs_record: CalibratedSensor = self.get(\n                \"calibrated_sensor\", record.calibrated_sensor_token\n            )\n            sensor_record: Sensor = self.get(\"sensor\", cs_record.sensor_token)\n            record.modality = sensor_record.modality\n            record.channel = sensor_record.channel\n            # set first sample data token to the corresponding sensor channel,\n            # as premise for sample data is ordered by time stamp order.\n            if sensor_record.channel not in registered_channels:\n                sensor_record.first_sd_token = record.token\n                registered_channels.append(sensor_record.channel)\n\n            # set sample data\n            if record.is_key_frame:\n                sample_record: Sample = self.get(\"sample\", record.sample_token)\n                sample_record.data[record.channel] = record.token\n\n        for ann_record in self.sample_annotation:\n            sample_record: Sample = self.get(\"sample\", ann_record.sample_token)\n            sample_record.ann_3ds.append(ann_record.token)\n\n        for ann_record in self.object_ann:\n            sd_record: SampleData = self.get(\"sample_data\", ann_record.sample_data_token)\n            sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n            sample_record.ann_2ds.append(ann_record.token)\n\n        for ann_record in self.surface_ann:\n            sd_record: SampleData = self.get(\"sample_data\", ann_record.sample_data_token)\n            sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n            sample_record.surface_anns.append(ann_record.token)\n\n        log_to_map: dict[str, str] = {}\n        for map_record in self.map:\n            for log_token in map_record.log_tokens:\n                log_to_map[log_token] = map_record.token\n        for log_record in self.log:\n            log_record.map_token = log_to_map[log_record.token]\n\n        if verbose:\n            elapsed_time = time.time() - start_time\n            print(f\"Done reverse indexing in {elapsed_time:.3f} seconds.\\n======\")\n\n    def get_table(self, schema: str | SchemaName) -&gt; list[SchemaTable]:\n        \"\"\"Return the list of dataclasses corresponding to the schema table.\n\n        Args:\n            schema (str | SchemaName): Name of schema table.\n\n        Returns:\n            List of dataclasses.\n        \"\"\"\n        return getattr(self, SchemaName(schema))\n\n    def get(self, schema: str | SchemaName, token: str) -&gt; SchemaTable:\n        \"\"\"Return a record identified by the associated token.\n\n        Args:\n            schema (str | SchemaName): Name of schema.\n            token (str): Token to identify the specific record.\n\n        Returns:\n            Table record of the corresponding token.\n        \"\"\"\n        return self.get_table(schema)[self.get_idx(schema, token)]\n\n    def get_idx(self, schema: str | SchemaName, token: str) -&gt; int:\n        \"\"\"Return the index of the record in a table in constant runtime.\n\n        Args:\n            schema (str | SchemaName): Name of schema.\n            token (str): Token of record.\n\n        Returns:\n            The index of the record in table.\n        \"\"\"\n        schema = SchemaName(schema)\n        if self._token2idx.get(schema) is None:\n            raise KeyError(f\"{schema} is not registered.\")\n        if self._token2idx[schema].get(token) is None:\n            raise KeyError(f\"{token} is not registered in {schema}.\")\n        return self._token2idx[schema][token]\n\n    def get_sample_data_path(self, sample_data_token: str) -&gt; str:\n        \"\"\"Return the file path to a raw data recorded in `sample_data`.\n\n        Args:\n            sample_data_token (str): Token of `sample_data`.\n\n        Returns:\n            File path.\n        \"\"\"\n        sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n        return osp.join(self.data_root, sd_record.filename)\n\n    def get_sample_data(\n        self,\n        sample_data_token: str,\n        *,\n        selected_ann_tokens: list[str] | None = None,\n        as_3d: bool = True,\n        as_sensor_coord: bool = True,\n        future_seconds: float = 0.0,\n        visibility: VisibilityLevel = VisibilityLevel.NONE,\n    ) -&gt; tuple[str, list[BoxLike], CameraIntrinsicLike | None]:\n        \"\"\"Return the data path as well as all annotations related to that `sample_data`.\n        Note that output boxes is w.r.t base link or sensor coordinate system.\n\n        Args:\n            sample_data_token (str): Token of `sample_data`.\n            selected_ann_tokens (list[str] | None, optional):\n                Specify if you want to extract only particular annotations.\n            as_3d (bool, optional): Whether to return 3D or 2D boxes.\n            as_sensor_coord (bool, optional): Whether to transform boxes as sensor origin coordinate system.\n            visibility (VisibilityLevel, optional): If `sample_data` is an image,\n                this sets required visibility for only 3D boxes.\n\n        Returns:\n            Data path, a list of boxes and 3x3 camera intrinsic matrix.\n        \"\"\"\n        # Retrieve sensor &amp; pose records\n        sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n        cs_record: CalibratedSensor = self.get(\n            \"calibrated_sensor\", sd_record.calibrated_sensor_token\n        )\n        sensor_record: Sensor = self.get(\"sensor\", cs_record.sensor_token)\n        pose_record: EgoPose = self.get(\"ego_pose\", sd_record.ego_pose_token)\n\n        data_path = self.get_sample_data_path(sample_data_token)\n\n        if sensor_record.modality == SensorModality.CAMERA:\n            cam_intrinsic = cs_record.camera_intrinsic\n            img_size = (sd_record.width, sd_record.height)\n        else:\n            cam_intrinsic = None\n            img_size = None\n\n        # Retrieve all sample annotations and map to sensor coordinate system.\n        boxes: list[BoxLike]\n        if selected_ann_tokens is not None:\n            boxes = (\n                [\n                    self.get_box3d(token, future_seconds=future_seconds)\n                    for token in selected_ann_tokens\n                ]\n                if as_3d\n                else list(map(self.get_box2d, selected_ann_tokens))\n            )\n        else:\n            boxes = (\n                self.get_box3ds(sample_data_token, future_seconds=future_seconds)\n                if as_3d\n                else self.get_box2ds(sample_data_token)\n            )\n\n        if not as_3d:\n            return data_path, boxes, cam_intrinsic\n\n        # Make list of Box objects including coord system transforms.\n        box_list: list[Box3D] = []\n        for box in boxes:\n            # Move box to ego vehicle coord system.\n            box.translate(-pose_record.translation)\n            box.rotate(pose_record.rotation.inverse)\n            box.frame_id = \"base_link\"\n\n            if as_sensor_coord:\n                #  Move box to sensor coord system.\n                box.translate(-cs_record.translation)\n                box.rotate(cs_record.rotation.inverse)\n                box.frame_id = sensor_record.channel\n\n            if sensor_record.modality == SensorModality.CAMERA and not is_box_in_image(\n                box,\n                cam_intrinsic,\n                img_size,\n                visibility=visibility,\n            ):\n                continue\n            box_list.append(box)\n\n        return data_path, box_list, cam_intrinsic\n\n    def get_semantic_label(\n        self,\n        category_token: str,\n        attribute_tokens: list[str] | None = None,\n    ) -&gt; SemanticLabel:\n        \"\"\"Return a SemanticLabel instance from specified `category_token` and `attribute_tokens`.\n\n        Args:\n            category_token (str): Token of `Category` table.\n            attribute_tokens (list[str] | None, optional): List of attribute tokens.\n\n        Returns:\n            Instantiated SemanticLabel.\n        \"\"\"\n        category: Category = self.get(\"category\", category_token)\n        attributes: list[str] = (\n            [self.get(\"attribute\", token).name for token in attribute_tokens]\n            if attribute_tokens is not None\n            else []\n        )\n\n        return SemanticLabel(category.name, attributes)\n\n    def get_box3d(self, sample_annotation_token: str, *, future_seconds: float = 0.0) -&gt; Box3D:\n        \"\"\"Return a Box3D class from a `sample_annotation` record.\n\n        Args:\n            sample_annotation_token (str): Token of `sample_annotation`.\n            future_seconds (float, optional): Future time in [s].\n\n        Returns:\n            Instantiated Box3D.\n        \"\"\"\n        ann: SampleAnnotation = self.get(\"sample_annotation\", sample_annotation_token)\n        instance: Instance = self.get(\"instance\", ann.instance_token)\n        sample: Sample = self.get(\"sample\", ann.sample_token)\n        visibility: Visibility = self.get(\"visibility\", ann.visibility_token)\n\n        # semantic label\n        semantic_label = self.get_semantic_label(\n            category_token=instance.category_token,\n            attribute_tokens=ann.attribute_tokens,\n        )\n\n        shape = Shape(shape_type=ShapeType.BOUNDING_BOX, size=ann.size)\n\n        # velocity\n        velocity = self.box_velocity(sample_annotation_token=sample_annotation_token)\n\n        box = Box3D(\n            unix_time=sample.timestamp,\n            frame_id=\"map\",\n            semantic_label=semantic_label,\n            position=ann.translation,\n            rotation=ann.rotation,\n            shape=shape,\n            velocity=velocity,\n            confidence=1.0,\n            uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n            num_points=ann.num_lidar_pts,\n            visibility=visibility.level,\n        )\n\n        if future_seconds &gt; 0.0:\n            # NOTE: Future trajectory is map coordinate frame\n            timestamps, anns = self._timeseries_helper.get_sample_annotations_until(\n                ann.instance_token, ann.sample_token, future_seconds\n            )\n            if len(anns) == 0:\n                return box\n            waypoints = [ann.translation for ann in anns]\n            return box.with_future(timestamps=timestamps, confidences=[1.0], waypoints=[waypoints])\n        else:\n            return box\n\n    def get_box2d(self, object_ann_token: str) -&gt; Box2D:\n        \"\"\"Return a Box2D class from a `object_ann` record.\n\n        Args:\n            object_ann_token (str): Token of `object_ann`.\n\n        Returns:\n            Instantiated Box2D.\n        \"\"\"\n        ann: ObjectAnn = self.get(\"object_ann\", object_ann_token)\n        instance: Instance = self.get(\"instance\", ann.instance_token)\n        sample_data: SampleData = self.get(\"sample_data\", ann.sample_data_token)\n\n        semantic_label = self.get_semantic_label(\n            category_token=ann.category_token,\n            attribute_tokens=ann.attribute_tokens,\n        )\n\n        return Box2D(\n            unix_time=sample_data.timestamp,\n            frame_id=sample_data.channel,\n            semantic_label=semantic_label,\n            roi=ann.bbox,\n            confidence=1.0,\n            uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n        )\n\n    def get_box3ds(self, sample_data_token: str, *, future_seconds: float = 0.0) -&gt; list[Box3D]:\n        \"\"\"Rerun a list of Box3D classes for all annotations of a particular `sample_data` record.\n        It the `sample_data` is a keyframe, this returns annotations for the corresponding `sample`.\n\n        Args:\n            sample_data_token (str): Token of `sample_data`.\n            future_seconds (float, optional): Future time in [s].\n\n        Returns:\n            List of instantiated Box3D classes.\n        \"\"\"\n        # Retrieve sensor &amp; pose records\n        sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n        curr_sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n\n        if curr_sample_record.prev == \"\" or sd_record.is_key_frame:\n            # If no previous annotations available, or if sample_data is keyframe just return the current ones.\n            boxes = [\n                self.get_box3d(token, future_seconds=future_seconds)\n                for token in curr_sample_record.ann_3ds\n            ]\n\n        else:\n            prev_sample_record: Sample = self.get(\"sample\", curr_sample_record.prev)\n\n            curr_ann_recs: list[SampleAnnotation] = [\n                self.get(\"sample_annotation\", token) for token in curr_sample_record.ann_3ds\n            ]\n            prev_ann_recs: list[SampleAnnotation] = [\n                self.get(\"sample_annotation\", token) for token in prev_sample_record.ann_3ds\n            ]\n\n            # Maps instance tokens to prev_ann records\n            prev_inst_map = {entry.instance_token: entry for entry in prev_ann_recs}\n\n            t0 = prev_sample_record.timestamp\n            t1 = curr_sample_record.timestamp\n            t = sd_record.timestamp\n\n            # There are rare situations where the timestamps in the DB are off so ensure that t0 &lt; t &lt; t1.\n            t = max(t0, min(t1, t))\n\n            boxes: list[Box3D] = []\n            for curr_ann in curr_ann_recs:\n                if curr_ann.instance_token in prev_inst_map:\n                    # If the annotated instance existed in the previous frame, interpolate center &amp; orientation.\n                    prev_ann = prev_inst_map[curr_ann.instance_token]\n\n                    # Interpolate center.\n                    position = [\n                        np.interp(t, [t0, t1], [c0, c1])\n                        for c0, c1 in zip(\n                            prev_ann.translation,\n                            curr_ann.translation,\n                            strict=True,\n                        )\n                    ]\n\n                    # Interpolate orientation.\n                    rotation = Quaternion.slerp(\n                        q0=prev_ann.rotation,\n                        q1=curr_ann.rotation,\n                        amount=(t - t0) / (t1 - t0),\n                    )\n\n                    instance: Instance = self.get(\"instance\", curr_ann.instance_token)\n                    semantic_label = self.get_semantic_label(\n                        instance.category_token, curr_ann.attribute_tokens\n                    )\n                    velocity = self.box_velocity(curr_ann.token)\n                    visibility: Visibility = self.get(\"visibility\", curr_ann.visibility_token)\n\n                    box = Box3D(\n                        unix_time=t,\n                        frame_id=\"map\",\n                        semantic_label=semantic_label,\n                        position=position,\n                        rotation=rotation,\n                        shape=Shape(ShapeType.BOUNDING_BOX, curr_ann.size),\n                        velocity=velocity,\n                        confidence=1.0,\n                        uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n                        num_points=curr_ann.num_lidar_pts,\n                        visibility=visibility.level,\n                    )\n                else:\n                    # If not, simply grab the current annotation.\n                    box = self.get_box3d(curr_ann.token, future_seconds=future_seconds)\n                boxes.append(box)\n\n        return boxes\n\n    def get_box2ds(self, sample_data_token: str) -&gt; list[Box2D]:\n        \"\"\"Rerun a list of Box2D classes for all annotations of a particular `sample_data` record.\n        It the `sample_data` is a keyframe, this returns annotations for the corresponding `sample`.\n\n        Args:\n            sample_data_token (str): Token of `sample_data`.\n\n        Returns:\n            List of instantiated Box2D classes.\n        \"\"\"\n        sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n        sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n        return list(map(self.get_box2d, sample_record.ann_2ds))\n\n    def box_velocity(self, sample_annotation_token: str, max_time_diff: float = 1.5) -&gt; Vector3:\n        \"\"\"Return the velocity of an annotation.\n        If corresponding annotation has a true velocity, this returns it.\n        Otherwise, this estimates the velocity by computing the difference\n        between the previous and next frame.\n        If it is failed to estimate the velocity, values are set to np.nan.\n\n        Args:\n            sample_annotation_token (str): Token of `sample_annotation`.\n            max_time_diff (float, optional): Max allowed time difference\n                between consecutive samples.\n\n        Returns:\n            Vector3: Velocity in the order of (vx, vy, vz) in m/s.\n\n        TODO:\n            Currently, velocity coordinates is with respect to map, but\n            if should be each box.\n        \"\"\"\n        current: SampleAnnotation = self.get(\"sample_annotation\", sample_annotation_token)\n\n        # If the real velocity is annotated, returns it\n        if current.velocity is not None:\n            return current.velocity\n\n        has_prev = current.prev != \"\"\n        has_next = current.next != \"\"\n\n        # Cannot estimate velocity for a single annotation.\n        if not has_prev and not has_next:\n            return np.array([np.nan, np.nan, np.nan])\n\n        first: SampleAnnotation = (\n            self.get(\"sample_annotation\", current.prev) if has_prev else current\n        )\n\n        last: SampleAnnotation = (\n            self.get(\"sample_annotation\", current.next) if has_next else current\n        )\n\n        pos_last = last.translation\n        pos_first = first.translation\n        pos_diff = pos_last - pos_first\n\n        last_sample: Sample = self.get(\"sample\", last.sample_token)\n        first_sample: Sample = self.get(\"sample\", first.sample_token)\n        time_last = 1e-6 * last_sample.timestamp\n        time_first = 1e-6 * first_sample.timestamp\n        time_diff = time_last - time_first\n\n        if has_next and has_prev:\n            # If doing centered difference, allow for up to double the max_time_diff.\n            max_time_diff *= 2\n\n        if time_diff &gt; max_time_diff:\n            # If time_diff is too big, don't return an estimate.\n            return np.array([np.nan, np.nan, np.nan])\n        else:\n            return pos_diff / time_diff\n\n    def render_scene(\n        self,\n        *,\n        max_time_seconds: float = np.inf,\n        future_seconds: float = 0.0,\n        save_dir: str | None = None,\n    ) -&gt; None:\n        \"\"\"Render specified scene.\n\n        Args:\n            max_time_seconds (float, optional): Max time length to be rendered [s].\n            future_seconds (float, optional): Future time in [s].\n            save_dir (str | None, optional): Directory path to save the recording.\n        \"\"\"\n        self._rendering_helper.render_scene(\n            max_time_seconds=max_time_seconds,\n            future_seconds=future_seconds,\n            save_dir=save_dir,\n        )\n\n    def render_instance(\n        self,\n        instance_token: str | Sequence[str],\n        *,\n        future_seconds: float = 0.0,\n        save_dir: str | None = None,\n    ) -&gt; None:\n        \"\"\"Render particular instance.\n\n        Args:\n            instance_token (str | Sequence[str]): Instance token(s).\n            future_seconds (float, optional): Future time in [s].\n            save_dir (str | None, optional): Directory path to save the recording.\n        \"\"\"\n        self._rendering_helper.render_instance(\n            instance_token=instance_token,\n            future_seconds=future_seconds,\n            save_dir=save_dir,\n        )\n\n    def render_pointcloud(\n        self,\n        *,\n        max_time_seconds: float = np.inf,\n        save_dir: str | None = None,\n    ) -&gt; None:\n        \"\"\"Render pointcloud on 3D and 2D view.\n\n        Args:\n            max_time_seconds (float, optional): Max time length to be rendered [s].\n            save_dir (str | None, optional): Directory path to save the recording.\n\n        TODO:\n            Add an option of rendering radar channels.\n        \"\"\"\n        self._rendering_helper.render_pointcloud(\n            max_time_seconds=max_time_seconds,\n            save_dir=save_dir,\n        )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.annotation_dir","title":"<code>annotation_dir</code>  <code>property</code>","text":"<p>Return the path to annotation directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.bag_dir","title":"<code>bag_dir</code>  <code>property</code>","text":"<p>Return the path to ROS bag directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.data_root","title":"<code>data_root</code>  <code>property</code>","text":"<p>Return the path to dataset root directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.dataset_id","title":"<code>dataset_id</code>  <code>property</code>","text":"<p>Return the dataset ID.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.map_dir","title":"<code>map_dir</code>  <code>property</code>","text":"<p>Return the path to map directory.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.version","title":"<code>version</code>  <code>property</code>","text":"<p>Return the dataset version, or None if it is failed to lookup.</p>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.__init__","title":"<code>__init__(data_root, revision=None, verbose=True)</code>","text":"<p>Load database and creates reverse indexes and shortcuts.</p> <p>Parameters:</p> Name Type Description Default <code>data_root</code> <code>str</code> <p>Path to the root directory of dataset.</p> required <code>revision</code> <code>str | None</code> <p>You can specify any specific version if you want. If None, search the latest one.</p> <code>None</code> <code>verbose</code> <code>bool</code> <p>Whether to display status during load.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from t4_devkit import Tier4\n&gt;&gt;&gt; t4 = Tier4(\"data/tier4\")\n======\nLoading T4 tables in `annotation`...\nReverse indexing...\nDone reverse indexing in 0.010 seconds.\n======\n21 category\n8 attribute\n4 visibility\n31 instance\n7 sensor\n7 calibrated_sensor\n2529 ego_pose\n1 log\n1 scene\n88 sample\n2529 sample_data\n1919 sample_annotation\n0 object_ann\n0 surface_ann\n0 keypoint\n1 map\nDone loading in 0.046 seconds.\n======\n</code></pre> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def __init__(\n    self,\n    data_root: str,\n    revision: str | None = None,\n    verbose: bool = True,\n) -&gt; None:\n    \"\"\"Load database and creates reverse indexes and shortcuts.\n\n    Args:\n        data_root (str): Path to the root directory of dataset.\n        revision (str | None, optional): You can specify any specific version if you want.\n            If None, search the latest one.\n        verbose (bool, optional): Whether to display status during load.\n\n    Examples:\n        &gt;&gt;&gt; from t4_devkit import Tier4\n        &gt;&gt;&gt; t4 = Tier4(\"data/tier4\")\n        ======\n        Loading T4 tables in `annotation`...\n        Reverse indexing...\n        Done reverse indexing in 0.010 seconds.\n        ======\n        21 category\n        8 attribute\n        4 visibility\n        31 instance\n        7 sensor\n        7 calibrated_sensor\n        2529 ego_pose\n        1 log\n        1 scene\n        88 sample\n        2529 sample_data\n        1919 sample_annotation\n        0 object_ann\n        0 surface_ann\n        0 keypoint\n        1 map\n        Done loading in 0.046 seconds.\n        ======\n\n    \"\"\"\n    self._metadata = load_metadata(data_root, revision)\n\n    if not osp.exists(self.data_root):\n        raise FileNotFoundError(f\"Database directory is not found: {self.data_root}\")\n\n    if self.version is None:\n        warnings.warn(\n            f\"DatasetID: {self.dataset_id} does't contain any versions.\", DeprecationWarning\n        )\n\n    start_time = time.time()\n    if verbose:\n        print(\"======\\nLoading T4 tables...\")\n\n    # assign tables explicitly\n    self.attribute: list[Attribute] = load_table(self.annotation_dir, SchemaName.ATTRIBUTE)\n    self.calibrated_sensor: list[CalibratedSensor] = load_table(\n        self.annotation_dir, SchemaName.CALIBRATED_SENSOR\n    )\n    self.category: list[Category] = load_table(self.annotation_dir, SchemaName.CATEGORY)\n    self.category = fix_category_table(self.category)\n\n    self.ego_pose: list[EgoPose] = load_table(self.annotation_dir, SchemaName.EGO_POSE)\n    self.instance: list[Instance] = load_table(self.annotation_dir, SchemaName.INSTANCE)\n    self.keypoint: list[Keypoint] = load_table(self.annotation_dir, SchemaName.KEYPOINT)\n    self.lidarseg: list[LidarSeg] = load_table(self.annotation_dir, SchemaName.LIDARSEG)\n    self.log: list[Log] = load_table(self.annotation_dir, SchemaName.LOG)\n    self.map: list[Map] = load_table(self.annotation_dir, SchemaName.MAP)\n    self.object_ann: list[ObjectAnn] = load_table(self.annotation_dir, SchemaName.OBJECT_ANN)\n    self.sample_annotation: list[SampleAnnotation] = load_table(\n        self.annotation_dir, SchemaName.SAMPLE_ANNOTATION\n    )\n    self.sample_data: list[SampleData] = load_table(self.annotation_dir, SchemaName.SAMPLE_DATA)\n    self.sample: list[Sample] = load_table(self.annotation_dir, SchemaName.SAMPLE)\n    self.scene: list[Scene] = load_table(self.annotation_dir, SchemaName.SCENE)\n    self.sensor: list[Sensor] = load_table(self.annotation_dir, SchemaName.SENSOR)\n    self.surface_ann: list[SurfaceAnn] = load_table(self.annotation_dir, SchemaName.SURFACE_ANN)\n    self.vehicle_state: list[VehicleState] = load_table(\n        self.annotation_dir, SchemaName.VEHICLE_STATE\n    )\n    self.visibility: list[Visibility] = load_table(self.annotation_dir, SchemaName.VISIBILITY)\n\n    # make reverse indexes for common lookups\n    self.__make_reverse_index__(verbose)\n\n    if verbose:\n        for schema in SchemaName:\n            print(f\"{len(self.get_table(schema))} {schema.value}\")\n        elapsed_time = time.time() - start_time\n        print(f\"Done loading in {elapsed_time:.3f} seconds.\\n======\")\n\n    # initialize helpers after finishing construction of Tier4\n    self._timeseries_helper = TimeseriesHelper(self)\n    self._rendering_helper = RenderingHelper(self)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.__make_reverse_index__","title":"<code>__make_reverse_index__(verbose)</code>","text":"<p>De-normalize database to create reverse indices for common cases.</p> <p>Parameters:</p> Name Type Description Default <code>verbose</code> <code>bool</code> <p>Whether to display outputs.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>Expecting <code>map</code> table has <code>log_tokens</code> key.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def __make_reverse_index__(self, verbose: bool) -&gt; None:\n    \"\"\"De-normalize database to create reverse indices for common cases.\n\n    Args:\n        verbose (bool): Whether to display outputs.\n\n    Raises:\n        ValueError: Expecting `map` table has `log_tokens` key.\n    \"\"\"\n    start_time = time.time()\n    if verbose:\n        print(\"Reverse indexing...\")\n\n    self._token2idx: dict[str, dict[str, int]] = {\n        schema.value: {\n            table.token: idx for idx, table in enumerate(self.get_table(schema.value))\n        }\n        for schema in SchemaName\n    }\n\n    self._label2id: dict[str, int] = {\n        category.name: category.index for category in self.category\n    }\n\n    # add shortcuts\n    for record in self.sample_annotation:\n        instance: Instance = self.get(\"instance\", record.instance_token)\n        category: Category = self.get(\"category\", instance.category_token)\n        record.category_name = category.name\n\n    for record in self.object_ann:\n        category: Category = self.get(\"category\", record.category_token)\n        record.category_name = category.name\n\n    for record in self.surface_ann:\n        if record.category_token == \"\":  # NOTE: Some database contains this case\n            warnings.warn(f\"Category token is empty for surface ann: {record.token}\")\n            continue\n        category: Category = self.get(\"category\", record.category_token)\n        record.category_name = category.name\n\n    registered_channels: list[str] = []\n    for record in self.sample_data:\n        cs_record: CalibratedSensor = self.get(\n            \"calibrated_sensor\", record.calibrated_sensor_token\n        )\n        sensor_record: Sensor = self.get(\"sensor\", cs_record.sensor_token)\n        record.modality = sensor_record.modality\n        record.channel = sensor_record.channel\n        # set first sample data token to the corresponding sensor channel,\n        # as premise for sample data is ordered by time stamp order.\n        if sensor_record.channel not in registered_channels:\n            sensor_record.first_sd_token = record.token\n            registered_channels.append(sensor_record.channel)\n\n        # set sample data\n        if record.is_key_frame:\n            sample_record: Sample = self.get(\"sample\", record.sample_token)\n            sample_record.data[record.channel] = record.token\n\n    for ann_record in self.sample_annotation:\n        sample_record: Sample = self.get(\"sample\", ann_record.sample_token)\n        sample_record.ann_3ds.append(ann_record.token)\n\n    for ann_record in self.object_ann:\n        sd_record: SampleData = self.get(\"sample_data\", ann_record.sample_data_token)\n        sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n        sample_record.ann_2ds.append(ann_record.token)\n\n    for ann_record in self.surface_ann:\n        sd_record: SampleData = self.get(\"sample_data\", ann_record.sample_data_token)\n        sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n        sample_record.surface_anns.append(ann_record.token)\n\n    log_to_map: dict[str, str] = {}\n    for map_record in self.map:\n        for log_token in map_record.log_tokens:\n            log_to_map[log_token] = map_record.token\n    for log_record in self.log:\n        log_record.map_token = log_to_map[log_record.token]\n\n    if verbose:\n        elapsed_time = time.time() - start_time\n        print(f\"Done reverse indexing in {elapsed_time:.3f} seconds.\\n======\")\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.box_velocity","title":"<code>box_velocity(sample_annotation_token, max_time_diff=1.5)</code>","text":"<p>Return the velocity of an annotation. If corresponding annotation has a true velocity, this returns it. Otherwise, this estimates the velocity by computing the difference between the previous and next frame. If it is failed to estimate the velocity, values are set to np.nan.</p> <p>Parameters:</p> Name Type Description Default <code>sample_annotation_token</code> <code>str</code> <p>Token of <code>sample_annotation</code>.</p> required <code>max_time_diff</code> <code>float</code> <p>Max allowed time difference between consecutive samples.</p> <code>1.5</code> <p>Returns:</p> Name Type Description <code>Vector3</code> <code>Vector3</code> <p>Velocity in the order of (vx, vy, vz) in m/s.</p> TODO <p>Currently, velocity coordinates is with respect to map, but if should be each box.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def box_velocity(self, sample_annotation_token: str, max_time_diff: float = 1.5) -&gt; Vector3:\n    \"\"\"Return the velocity of an annotation.\n    If corresponding annotation has a true velocity, this returns it.\n    Otherwise, this estimates the velocity by computing the difference\n    between the previous and next frame.\n    If it is failed to estimate the velocity, values are set to np.nan.\n\n    Args:\n        sample_annotation_token (str): Token of `sample_annotation`.\n        max_time_diff (float, optional): Max allowed time difference\n            between consecutive samples.\n\n    Returns:\n        Vector3: Velocity in the order of (vx, vy, vz) in m/s.\n\n    TODO:\n        Currently, velocity coordinates is with respect to map, but\n        if should be each box.\n    \"\"\"\n    current: SampleAnnotation = self.get(\"sample_annotation\", sample_annotation_token)\n\n    # If the real velocity is annotated, returns it\n    if current.velocity is not None:\n        return current.velocity\n\n    has_prev = current.prev != \"\"\n    has_next = current.next != \"\"\n\n    # Cannot estimate velocity for a single annotation.\n    if not has_prev and not has_next:\n        return np.array([np.nan, np.nan, np.nan])\n\n    first: SampleAnnotation = (\n        self.get(\"sample_annotation\", current.prev) if has_prev else current\n    )\n\n    last: SampleAnnotation = (\n        self.get(\"sample_annotation\", current.next) if has_next else current\n    )\n\n    pos_last = last.translation\n    pos_first = first.translation\n    pos_diff = pos_last - pos_first\n\n    last_sample: Sample = self.get(\"sample\", last.sample_token)\n    first_sample: Sample = self.get(\"sample\", first.sample_token)\n    time_last = 1e-6 * last_sample.timestamp\n    time_first = 1e-6 * first_sample.timestamp\n    time_diff = time_last - time_first\n\n    if has_next and has_prev:\n        # If doing centered difference, allow for up to double the max_time_diff.\n        max_time_diff *= 2\n\n    if time_diff &gt; max_time_diff:\n        # If time_diff is too big, don't return an estimate.\n        return np.array([np.nan, np.nan, np.nan])\n    else:\n        return pos_diff / time_diff\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get","title":"<code>get(schema, token)</code>","text":"<p>Return a record identified by the associated token.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str | SchemaName</code> <p>Name of schema.</p> required <code>token</code> <code>str</code> <p>Token to identify the specific record.</p> required <p>Returns:</p> Type Description <code>SchemaTable</code> <p>Table record of the corresponding token.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get(self, schema: str | SchemaName, token: str) -&gt; SchemaTable:\n    \"\"\"Return a record identified by the associated token.\n\n    Args:\n        schema (str | SchemaName): Name of schema.\n        token (str): Token to identify the specific record.\n\n    Returns:\n        Table record of the corresponding token.\n    \"\"\"\n    return self.get_table(schema)[self.get_idx(schema, token)]\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box2d","title":"<code>get_box2d(object_ann_token)</code>","text":"<p>Return a Box2D class from a <code>object_ann</code> record.</p> <p>Parameters:</p> Name Type Description Default <code>object_ann_token</code> <code>str</code> <p>Token of <code>object_ann</code>.</p> required <p>Returns:</p> Type Description <code>Box2D</code> <p>Instantiated Box2D.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box2d(self, object_ann_token: str) -&gt; Box2D:\n    \"\"\"Return a Box2D class from a `object_ann` record.\n\n    Args:\n        object_ann_token (str): Token of `object_ann`.\n\n    Returns:\n        Instantiated Box2D.\n    \"\"\"\n    ann: ObjectAnn = self.get(\"object_ann\", object_ann_token)\n    instance: Instance = self.get(\"instance\", ann.instance_token)\n    sample_data: SampleData = self.get(\"sample_data\", ann.sample_data_token)\n\n    semantic_label = self.get_semantic_label(\n        category_token=ann.category_token,\n        attribute_tokens=ann.attribute_tokens,\n    )\n\n    return Box2D(\n        unix_time=sample_data.timestamp,\n        frame_id=sample_data.channel,\n        semantic_label=semantic_label,\n        roi=ann.bbox,\n        confidence=1.0,\n        uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box2ds","title":"<code>get_box2ds(sample_data_token)</code>","text":"<p>Rerun a list of Box2D classes for all annotations of a particular <code>sample_data</code> record. It the <code>sample_data</code> is a keyframe, this returns annotations for the corresponding <code>sample</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sample_data_token</code> <code>str</code> <p>Token of <code>sample_data</code>.</p> required <p>Returns:</p> Type Description <code>list[Box2D]</code> <p>List of instantiated Box2D classes.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box2ds(self, sample_data_token: str) -&gt; list[Box2D]:\n    \"\"\"Rerun a list of Box2D classes for all annotations of a particular `sample_data` record.\n    It the `sample_data` is a keyframe, this returns annotations for the corresponding `sample`.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n\n    Returns:\n        List of instantiated Box2D classes.\n    \"\"\"\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n    return list(map(self.get_box2d, sample_record.ann_2ds))\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box3d","title":"<code>get_box3d(sample_annotation_token, *, future_seconds=0.0)</code>","text":"<p>Return a Box3D class from a <code>sample_annotation</code> record.</p> <p>Parameters:</p> Name Type Description Default <code>sample_annotation_token</code> <code>str</code> <p>Token of <code>sample_annotation</code>.</p> required <code>future_seconds</code> <code>float</code> <p>Future time in [s].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>Box3D</code> <p>Instantiated Box3D.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box3d(self, sample_annotation_token: str, *, future_seconds: float = 0.0) -&gt; Box3D:\n    \"\"\"Return a Box3D class from a `sample_annotation` record.\n\n    Args:\n        sample_annotation_token (str): Token of `sample_annotation`.\n        future_seconds (float, optional): Future time in [s].\n\n    Returns:\n        Instantiated Box3D.\n    \"\"\"\n    ann: SampleAnnotation = self.get(\"sample_annotation\", sample_annotation_token)\n    instance: Instance = self.get(\"instance\", ann.instance_token)\n    sample: Sample = self.get(\"sample\", ann.sample_token)\n    visibility: Visibility = self.get(\"visibility\", ann.visibility_token)\n\n    # semantic label\n    semantic_label = self.get_semantic_label(\n        category_token=instance.category_token,\n        attribute_tokens=ann.attribute_tokens,\n    )\n\n    shape = Shape(shape_type=ShapeType.BOUNDING_BOX, size=ann.size)\n\n    # velocity\n    velocity = self.box_velocity(sample_annotation_token=sample_annotation_token)\n\n    box = Box3D(\n        unix_time=sample.timestamp,\n        frame_id=\"map\",\n        semantic_label=semantic_label,\n        position=ann.translation,\n        rotation=ann.rotation,\n        shape=shape,\n        velocity=velocity,\n        confidence=1.0,\n        uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n        num_points=ann.num_lidar_pts,\n        visibility=visibility.level,\n    )\n\n    if future_seconds &gt; 0.0:\n        # NOTE: Future trajectory is map coordinate frame\n        timestamps, anns = self._timeseries_helper.get_sample_annotations_until(\n            ann.instance_token, ann.sample_token, future_seconds\n        )\n        if len(anns) == 0:\n            return box\n        waypoints = [ann.translation for ann in anns]\n        return box.with_future(timestamps=timestamps, confidences=[1.0], waypoints=[waypoints])\n    else:\n        return box\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_box3ds","title":"<code>get_box3ds(sample_data_token, *, future_seconds=0.0)</code>","text":"<p>Rerun a list of Box3D classes for all annotations of a particular <code>sample_data</code> record. It the <code>sample_data</code> is a keyframe, this returns annotations for the corresponding <code>sample</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sample_data_token</code> <code>str</code> <p>Token of <code>sample_data</code>.</p> required <code>future_seconds</code> <code>float</code> <p>Future time in [s].</p> <code>0.0</code> <p>Returns:</p> Type Description <code>list[Box3D]</code> <p>List of instantiated Box3D classes.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_box3ds(self, sample_data_token: str, *, future_seconds: float = 0.0) -&gt; list[Box3D]:\n    \"\"\"Rerun a list of Box3D classes for all annotations of a particular `sample_data` record.\n    It the `sample_data` is a keyframe, this returns annotations for the corresponding `sample`.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n        future_seconds (float, optional): Future time in [s].\n\n    Returns:\n        List of instantiated Box3D classes.\n    \"\"\"\n    # Retrieve sensor &amp; pose records\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    curr_sample_record: Sample = self.get(\"sample\", sd_record.sample_token)\n\n    if curr_sample_record.prev == \"\" or sd_record.is_key_frame:\n        # If no previous annotations available, or if sample_data is keyframe just return the current ones.\n        boxes = [\n            self.get_box3d(token, future_seconds=future_seconds)\n            for token in curr_sample_record.ann_3ds\n        ]\n\n    else:\n        prev_sample_record: Sample = self.get(\"sample\", curr_sample_record.prev)\n\n        curr_ann_recs: list[SampleAnnotation] = [\n            self.get(\"sample_annotation\", token) for token in curr_sample_record.ann_3ds\n        ]\n        prev_ann_recs: list[SampleAnnotation] = [\n            self.get(\"sample_annotation\", token) for token in prev_sample_record.ann_3ds\n        ]\n\n        # Maps instance tokens to prev_ann records\n        prev_inst_map = {entry.instance_token: entry for entry in prev_ann_recs}\n\n        t0 = prev_sample_record.timestamp\n        t1 = curr_sample_record.timestamp\n        t = sd_record.timestamp\n\n        # There are rare situations where the timestamps in the DB are off so ensure that t0 &lt; t &lt; t1.\n        t = max(t0, min(t1, t))\n\n        boxes: list[Box3D] = []\n        for curr_ann in curr_ann_recs:\n            if curr_ann.instance_token in prev_inst_map:\n                # If the annotated instance existed in the previous frame, interpolate center &amp; orientation.\n                prev_ann = prev_inst_map[curr_ann.instance_token]\n\n                # Interpolate center.\n                position = [\n                    np.interp(t, [t0, t1], [c0, c1])\n                    for c0, c1 in zip(\n                        prev_ann.translation,\n                        curr_ann.translation,\n                        strict=True,\n                    )\n                ]\n\n                # Interpolate orientation.\n                rotation = Quaternion.slerp(\n                    q0=prev_ann.rotation,\n                    q1=curr_ann.rotation,\n                    amount=(t - t0) / (t1 - t0),\n                )\n\n                instance: Instance = self.get(\"instance\", curr_ann.instance_token)\n                semantic_label = self.get_semantic_label(\n                    instance.category_token, curr_ann.attribute_tokens\n                )\n                velocity = self.box_velocity(curr_ann.token)\n                visibility: Visibility = self.get(\"visibility\", curr_ann.visibility_token)\n\n                box = Box3D(\n                    unix_time=t,\n                    frame_id=\"map\",\n                    semantic_label=semantic_label,\n                    position=position,\n                    rotation=rotation,\n                    shape=Shape(ShapeType.BOUNDING_BOX, curr_ann.size),\n                    velocity=velocity,\n                    confidence=1.0,\n                    uuid=instance.token,  # TODO(ktro2828): extract uuid from `instance_name`.\n                    num_points=curr_ann.num_lidar_pts,\n                    visibility=visibility.level,\n                )\n            else:\n                # If not, simply grab the current annotation.\n                box = self.get_box3d(curr_ann.token, future_seconds=future_seconds)\n            boxes.append(box)\n\n    return boxes\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_idx","title":"<code>get_idx(schema, token)</code>","text":"<p>Return the index of the record in a table in constant runtime.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str | SchemaName</code> <p>Name of schema.</p> required <code>token</code> <code>str</code> <p>Token of record.</p> required <p>Returns:</p> Type Description <code>int</code> <p>The index of the record in table.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_idx(self, schema: str | SchemaName, token: str) -&gt; int:\n    \"\"\"Return the index of the record in a table in constant runtime.\n\n    Args:\n        schema (str | SchemaName): Name of schema.\n        token (str): Token of record.\n\n    Returns:\n        The index of the record in table.\n    \"\"\"\n    schema = SchemaName(schema)\n    if self._token2idx.get(schema) is None:\n        raise KeyError(f\"{schema} is not registered.\")\n    if self._token2idx[schema].get(token) is None:\n        raise KeyError(f\"{token} is not registered in {schema}.\")\n    return self._token2idx[schema][token]\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_sample_data","title":"<code>get_sample_data(sample_data_token, *, selected_ann_tokens=None, as_3d=True, as_sensor_coord=True, future_seconds=0.0, visibility=VisibilityLevel.NONE)</code>","text":"<p>Return the data path as well as all annotations related to that <code>sample_data</code>. Note that output boxes is w.r.t base link or sensor coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>sample_data_token</code> <code>str</code> <p>Token of <code>sample_data</code>.</p> required <code>selected_ann_tokens</code> <code>list[str] | None</code> <p>Specify if you want to extract only particular annotations.</p> <code>None</code> <code>as_3d</code> <code>bool</code> <p>Whether to return 3D or 2D boxes.</p> <code>True</code> <code>as_sensor_coord</code> <code>bool</code> <p>Whether to transform boxes as sensor origin coordinate system.</p> <code>True</code> <code>visibility</code> <code>VisibilityLevel</code> <p>If <code>sample_data</code> is an image, this sets required visibility for only 3D boxes.</p> <code>NONE</code> <p>Returns:</p> Type Description <code>tuple[str, list[BoxLike], CameraIntrinsicLike | None]</code> <p>Data path, a list of boxes and 3x3 camera intrinsic matrix.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_sample_data(\n    self,\n    sample_data_token: str,\n    *,\n    selected_ann_tokens: list[str] | None = None,\n    as_3d: bool = True,\n    as_sensor_coord: bool = True,\n    future_seconds: float = 0.0,\n    visibility: VisibilityLevel = VisibilityLevel.NONE,\n) -&gt; tuple[str, list[BoxLike], CameraIntrinsicLike | None]:\n    \"\"\"Return the data path as well as all annotations related to that `sample_data`.\n    Note that output boxes is w.r.t base link or sensor coordinate system.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n        selected_ann_tokens (list[str] | None, optional):\n            Specify if you want to extract only particular annotations.\n        as_3d (bool, optional): Whether to return 3D or 2D boxes.\n        as_sensor_coord (bool, optional): Whether to transform boxes as sensor origin coordinate system.\n        visibility (VisibilityLevel, optional): If `sample_data` is an image,\n            this sets required visibility for only 3D boxes.\n\n    Returns:\n        Data path, a list of boxes and 3x3 camera intrinsic matrix.\n    \"\"\"\n    # Retrieve sensor &amp; pose records\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    cs_record: CalibratedSensor = self.get(\n        \"calibrated_sensor\", sd_record.calibrated_sensor_token\n    )\n    sensor_record: Sensor = self.get(\"sensor\", cs_record.sensor_token)\n    pose_record: EgoPose = self.get(\"ego_pose\", sd_record.ego_pose_token)\n\n    data_path = self.get_sample_data_path(sample_data_token)\n\n    if sensor_record.modality == SensorModality.CAMERA:\n        cam_intrinsic = cs_record.camera_intrinsic\n        img_size = (sd_record.width, sd_record.height)\n    else:\n        cam_intrinsic = None\n        img_size = None\n\n    # Retrieve all sample annotations and map to sensor coordinate system.\n    boxes: list[BoxLike]\n    if selected_ann_tokens is not None:\n        boxes = (\n            [\n                self.get_box3d(token, future_seconds=future_seconds)\n                for token in selected_ann_tokens\n            ]\n            if as_3d\n            else list(map(self.get_box2d, selected_ann_tokens))\n        )\n    else:\n        boxes = (\n            self.get_box3ds(sample_data_token, future_seconds=future_seconds)\n            if as_3d\n            else self.get_box2ds(sample_data_token)\n        )\n\n    if not as_3d:\n        return data_path, boxes, cam_intrinsic\n\n    # Make list of Box objects including coord system transforms.\n    box_list: list[Box3D] = []\n    for box in boxes:\n        # Move box to ego vehicle coord system.\n        box.translate(-pose_record.translation)\n        box.rotate(pose_record.rotation.inverse)\n        box.frame_id = \"base_link\"\n\n        if as_sensor_coord:\n            #  Move box to sensor coord system.\n            box.translate(-cs_record.translation)\n            box.rotate(cs_record.rotation.inverse)\n            box.frame_id = sensor_record.channel\n\n        if sensor_record.modality == SensorModality.CAMERA and not is_box_in_image(\n            box,\n            cam_intrinsic,\n            img_size,\n            visibility=visibility,\n        ):\n            continue\n        box_list.append(box)\n\n    return data_path, box_list, cam_intrinsic\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_sample_data_path","title":"<code>get_sample_data_path(sample_data_token)</code>","text":"<p>Return the file path to a raw data recorded in <code>sample_data</code>.</p> <p>Parameters:</p> Name Type Description Default <code>sample_data_token</code> <code>str</code> <p>Token of <code>sample_data</code>.</p> required <p>Returns:</p> Type Description <code>str</code> <p>File path.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_sample_data_path(self, sample_data_token: str) -&gt; str:\n    \"\"\"Return the file path to a raw data recorded in `sample_data`.\n\n    Args:\n        sample_data_token (str): Token of `sample_data`.\n\n    Returns:\n        File path.\n    \"\"\"\n    sd_record: SampleData = self.get(\"sample_data\", sample_data_token)\n    return osp.join(self.data_root, sd_record.filename)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_semantic_label","title":"<code>get_semantic_label(category_token, attribute_tokens=None)</code>","text":"<p>Return a SemanticLabel instance from specified <code>category_token</code> and <code>attribute_tokens</code>.</p> <p>Parameters:</p> Name Type Description Default <code>category_token</code> <code>str</code> <p>Token of <code>Category</code> table.</p> required <code>attribute_tokens</code> <code>list[str] | None</code> <p>List of attribute tokens.</p> <code>None</code> <p>Returns:</p> Type Description <code>SemanticLabel</code> <p>Instantiated SemanticLabel.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_semantic_label(\n    self,\n    category_token: str,\n    attribute_tokens: list[str] | None = None,\n) -&gt; SemanticLabel:\n    \"\"\"Return a SemanticLabel instance from specified `category_token` and `attribute_tokens`.\n\n    Args:\n        category_token (str): Token of `Category` table.\n        attribute_tokens (list[str] | None, optional): List of attribute tokens.\n\n    Returns:\n        Instantiated SemanticLabel.\n    \"\"\"\n    category: Category = self.get(\"category\", category_token)\n    attributes: list[str] = (\n        [self.get(\"attribute\", token).name for token in attribute_tokens]\n        if attribute_tokens is not None\n        else []\n    )\n\n    return SemanticLabel(category.name, attributes)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.get_table","title":"<code>get_table(schema)</code>","text":"<p>Return the list of dataclasses corresponding to the schema table.</p> <p>Parameters:</p> Name Type Description Default <code>schema</code> <code>str | SchemaName</code> <p>Name of schema table.</p> required <p>Returns:</p> Type Description <code>list[SchemaTable]</code> <p>List of dataclasses.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def get_table(self, schema: str | SchemaName) -&gt; list[SchemaTable]:\n    \"\"\"Return the list of dataclasses corresponding to the schema table.\n\n    Args:\n        schema (str | SchemaName): Name of schema table.\n\n    Returns:\n        List of dataclasses.\n    \"\"\"\n    return getattr(self, SchemaName(schema))\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.render_instance","title":"<code>render_instance(instance_token, *, future_seconds=0.0, save_dir=None)</code>","text":"<p>Render particular instance.</p> <p>Parameters:</p> Name Type Description Default <code>instance_token</code> <code>str | Sequence[str]</code> <p>Instance token(s).</p> required <code>future_seconds</code> <code>float</code> <p>Future time in [s].</p> <code>0.0</code> <code>save_dir</code> <code>str | None</code> <p>Directory path to save the recording.</p> <code>None</code> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def render_instance(\n    self,\n    instance_token: str | Sequence[str],\n    *,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render particular instance.\n\n    Args:\n        instance_token (str | Sequence[str]): Instance token(s).\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n    \"\"\"\n    self._rendering_helper.render_instance(\n        instance_token=instance_token,\n        future_seconds=future_seconds,\n        save_dir=save_dir,\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.render_pointcloud","title":"<code>render_pointcloud(*, max_time_seconds=np.inf, save_dir=None)</code>","text":"<p>Render pointcloud on 3D and 2D view.</p> <p>Parameters:</p> Name Type Description Default <code>max_time_seconds</code> <code>float</code> <p>Max time length to be rendered [s].</p> <code>inf</code> <code>save_dir</code> <code>str | None</code> <p>Directory path to save the recording.</p> <code>None</code> TODO <p>Add an option of rendering radar channels.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def render_pointcloud(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render pointcloud on 3D and 2D view.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n\n    TODO:\n        Add an option of rendering radar channels.\n    \"\"\"\n    self._rendering_helper.render_pointcloud(\n        max_time_seconds=max_time_seconds,\n        save_dir=save_dir,\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.Tier4.render_scene","title":"<code>render_scene(*, max_time_seconds=np.inf, future_seconds=0.0, save_dir=None)</code>","text":"<p>Render specified scene.</p> <p>Parameters:</p> Name Type Description Default <code>max_time_seconds</code> <code>float</code> <p>Max time length to be rendered [s].</p> <code>inf</code> <code>future_seconds</code> <code>float</code> <p>Future time in [s].</p> <code>0.0</code> <code>save_dir</code> <code>str | None</code> <p>Directory path to save the recording.</p> <code>None</code> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def render_scene(\n    self,\n    *,\n    max_time_seconds: float = np.inf,\n    future_seconds: float = 0.0,\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Render specified scene.\n\n    Args:\n        max_time_seconds (float, optional): Max time length to be rendered [s].\n        future_seconds (float, optional): Future time in [s].\n        save_dir (str | None, optional): Directory path to save the recording.\n    \"\"\"\n    self._rendering_helper.render_scene(\n        max_time_seconds=max_time_seconds,\n        future_seconds=future_seconds,\n        save_dir=save_dir,\n    )\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.load_metadata","title":"<code>load_metadata(db_root, revision=None)</code>","text":"<p>Load metadata of T4 dataset including root directory path, dataset ID, and version.</p> <p>Parameters:</p> Name Type Description Default <code>db_root</code> <code>str</code> <p>Path to root directory of database.</p> required <code>revision</code> <code>str | None</code> <p>Specify version of the dataset. If None, search the latest one.</p> <code>None</code> <p>Returns:</p> Type Description <code>DBMetadata</code> <p>Metadata of T4 dataset.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def load_metadata(db_root: str, revision: str | None = None) -&gt; DBMetadata:\n    \"\"\"Load metadata of T4 dataset including root directory path, dataset ID, and version.\n\n    Args:\n        db_root (str): Path to root directory of database.\n        revision (str | None, optional): Specify version of the dataset.\n            If None, search the latest one.\n\n    Returns:\n        Metadata of T4 dataset.\n    \"\"\"\n    db_root_path = Path(db_root)\n    dataset_id = db_root_path.name\n\n    version_pattern = re.compile(r\".*/\\d+$\")\n    version_candidates = [\n        int(d.name) for d in db_root_path.iterdir() if version_pattern.match(d.as_posix())\n    ]\n\n    if revision is None:\n        if version_candidates:  # try to load the latest one\n            version = str(max(version_candidates))\n            data_root = db_root_path.joinpath(version).as_posix()\n        else:\n            version = None\n            data_root = db_root_path.as_posix()\n    else:\n        version = revision\n        data_root = db_root_path.joinpath(version).as_posix()\n\n    return DBMetadata(data_root=data_root, dataset_id=dataset_id, version=version)\n</code></pre>"},{"location":"apis/tier4/#t4_devkit.tier4.load_table","title":"<code>load_table(annotation_dir, schema)</code>","text":"<p>Load schema table from a JSON file.</p> <p>If the schema is optional and there is no corresponding JSON file in dataset, returns empty list.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_dir</code> <code>str</code> <p>Path to the directory of JSON annotation schema files.</p> required <code>schema</code> <code>SchemaName</code> <p>An enum member of <code>SchemaName</code>.</p> required <p>Returns:</p> Type Description <code>list[SchemaTable]</code> <p>Loaded table data saved in <code>.json</code>.</p> Source code in <code>t4_devkit/tier4.py</code> <pre><code>def load_table(annotation_dir: str, schema: SchemaName) -&gt; list[SchemaTable]:\n    \"\"\"Load schema table from a JSON file.\n\n    If the schema is optional and there is no corresponding JSON file in dataset,\n    returns empty list.\n\n    Args:\n        annotation_dir (str): Path to the directory of JSON annotation schema files.\n        schema (SchemaName): An enum member of `SchemaName`.\n\n    Returns:\n        Loaded table data saved in `.json`.\n    \"\"\"\n    filepath = osp.join(annotation_dir, schema.filename)\n    if not osp.exists(filepath) and schema.is_optional():\n        return []\n\n    if not osp.exists(filepath):\n        raise FileNotFoundError(f\"{schema.value} is mandatory.\")\n\n    return build_schema(schema, filepath)\n</code></pre>"},{"location":"apis/typing/","title":"<code>typing</code>","text":""},{"location":"apis/typing/#t4_devkit.typing.CameraDistortionLike","title":"<code>CameraDistortionLike = Union[CameraDistortion, ArrayLike, Sequence[float], list[float]]</code>  <code>module-attribute</code>","text":"<p>Type alias for camera distortion inputs.</p> Accepts <ul> <li>CameraDistortion instances</li> <li>NumPy arrays with shape (5,)</li> <li>Sequence of float values</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.CameraIntrinsicLike","title":"<code>CameraIntrinsicLike = Union[CameraIntrinsic, ArrayLike, Sequence[Sequence[float]], list[list[float]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for camera parameter inputs.</p> Accepts <ul> <li>CameraIntrinsic instances</li> <li>NumPy arrays with shape (3, 3)</li> <li>Nested sequences of float values</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Matrix3x3Like","title":"<code>Matrix3x3Like = Union[Matrix3x3, ArrayLike, Sequence[Sequence[float]], list[list[float]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for 3x3 matrix inputs.</p> Accepts <ul> <li>NumPy arrays with shape (3, 3)</li> <li>Nested lists: [[a, b, c], [d, e, f], [g, h, i]]</li> <li>Any nested sequence representing a 3x3 matrix</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Matrix4x4Like","title":"<code>Matrix4x4Like = Union[Matrix4x4, ArrayLike, Sequence[Sequence[float]], list[list[float]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for 4x4 matrix inputs.</p> Accepts <ul> <li>NumPy arrays with shape (4, 4)</li> <li>Nested lists: 4x4 structure</li> <li>Any nested sequence representing a 4x4 matrix</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.PointLike","title":"<code>PointLike = Union[Vector2Like, Vector3Like]</code>  <code>module-attribute</code>","text":"<p>Type alias for single point inputs (2D or 3D).</p>"},{"location":"apis/typing/#t4_devkit.typing.PointsLike","title":"<code>PointsLike = Union[ArrayLike, Sequence[Sequence[float]], list[list[float]], list[tuple[float, ...]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for multiple points inputs.</p> Accepts <ul> <li>NumPy arrays with shape (N, 2) or (N, 3)</li> <li>Lists of lists: [[x1, y1], [x2, y2], ...]</li> <li>Lists of tuples: [(x1, y1), (x2, y2), ...]</li> <li>Any nested sequence representing multiple points</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.QuaternionLike","title":"<code>QuaternionLike = Union[Quaternion, ArrayLike, Sequence[float], tuple[float, float, float, float], list[float]]</code>  <code>module-attribute</code>","text":"<p>Type alias for quaternion inputs.</p> Accepts <ul> <li>Quaternion instances</li> <li>NumPy arrays with shape (4,) - [w, x, y, z]</li> <li>Lists: [w, x, y, z]</li> <li>Tuples: (w, x, y, z)</li> <li>Any sequence with 4 float elements representing quaternion components</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.RoiLike","title":"<code>RoiLike = Union[Roi, ArrayLike, Sequence[float], tuple[float, float, float, float], list[float]]</code>  <code>module-attribute</code>","text":"<p>Type alias for Region of Interest (ROI) inputs.</p> Accepts <ul> <li>Roi instances</li> <li>NumPy arrays with shape (4,)</li> <li>Lists: [xmin, ymin, xmax, ymax]</li> <li>Tuples: (xmin, ymin, xmax, ymax)</li> <li>Any sequence with 4 float elements representing bounding box coordinates</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.RotationLike","title":"<code>RotationLike = Union[QuaternionLike, ArrayLike]</code>  <code>module-attribute</code>","text":"<p>Type alias for general rotation inputs.</p> Accepts <ul> <li>All QuaternionLike inputs</li> <li>3x3 rotation matrices as NumPy arrays</li> <li>Any array-like object representing rotations</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.ScalarLike","title":"<code>ScalarLike = Union[int, float, np.number]</code>  <code>module-attribute</code>","text":"<p>Type alias for scalar numeric inputs.</p> Accepts <ul> <li>Python int or float</li> <li>NumPy scalar types</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.TrajectoryLike","title":"<code>TrajectoryLike = Union[ArrayLike, Sequence[Sequence[Sequence[float]]], list[list[list[float]]]]</code>  <code>module-attribute</code>","text":"<p>Type alias for trajectory inputs.</p> Accepts <ul> <li>NumPy arrays with shape (M, T, D) where:</li> <li>M = number of modes</li> <li>T = number of timesteps</li> <li>D = spatial dimensions (usually 3)</li> <li>Triple-nested sequences with same structure</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Vector2Like","title":"<code>Vector2Like = Union[Vector2, ArrayLike, Sequence[float], tuple[float, float], list[float]]</code>  <code>module-attribute</code>","text":"<p>Type alias for 2D vector inputs.</p> Accepts <ul> <li>Vector2 instances</li> <li>NumPy arrays with shape (2,)</li> <li>Lists: [x, y]</li> <li>Tuples: (x, y)</li> <li>Any sequence with 2 float elements</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Vector3Like","title":"<code>Vector3Like = Union[Vector3, ArrayLike, Sequence[float], tuple[float, float, float], list[float]]</code>  <code>module-attribute</code>","text":"<p>Type alias for 3D vector inputs.</p> Accepts <ul> <li>Vector3 instances</li> <li>NumPy arrays with shape (3,)</li> <li>Lists: [x, y, z]</li> <li>Tuples: (x, y, z)</li> <li>Any sequence with 3 float elements</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.Vector6Like","title":"<code>Vector6Like = Union[Vector6, ArrayLike, Sequence[float], tuple[float, ...], list[float]]</code>  <code>module-attribute</code>","text":"<p>Type alias for 6D vector inputs.</p> Accepts <ul> <li>Vector6 instances</li> <li>NumPy arrays with shape (6,)</li> <li>Lists: [x1, x2, x3, x4, x5, x6]</li> <li>Tuples: (x1, x2, x3, x4, x5, x6)</li> <li>Any sequence with 6 float elements</li> </ul>"},{"location":"apis/typing/#t4_devkit.typing.CameraDistortion","title":"<code>CameraDistortion</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>A 1D array representing camera lens distortion coefficients.</p> <p>This class represents the distortion parameters for a camera lens following the OpenCV distortion model. It supports arrays of length 4, 5, 8, 12, or 14 elements, corresponding to different distortion models.</p> <p>The distortion coefficients follow the OpenCV convention: (k1, k2, p1, p2[, k3[, k4, k5, k6[, s1, s2, s3, s4[, \u03c4x, \u03c4y]]]])</p> Coefficient meanings <ul> <li>k1, k2, k3, k4, k5, k6: Radial distortion coefficients</li> <li>p1, p2: Tangential distortion coefficients</li> <li>s1, s2, s3, s4: Thin prism distortion coefficients</li> <li>\u03c4x, \u03c4y: Tilted sensor distortion coefficients</li> </ul> Supported array lengths <ul> <li>4 elements: (k1, k2, p1, p2) - Basic radial and tangential</li> <li>5 elements: (k1, k2, p1, p2, k3) - Extended radial distortion</li> <li>8 elements: (k1, k2, p1, p2, k3, k4, k5, k6) - Rational model</li> <li>12 elements: (k1, k2, p1, p2, k3, k4, k5, k6, s1, s2, s3, s4) - With thin prism</li> <li>14 elements: (k1, k2, p1, p2, k3, k4, k5, k6, s1, s2, s3, s4, \u03c4x, \u03c4y) - Full model</li> </ul> <p>Note that for non-camera, the array can be empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; d = CameraDistortion([0, 0, 0, 0])                     # 4 elements: basic model\n&gt;&gt;&gt; d = CameraDistortion([0, 0, 0, 0, 0])                  # 5 elements: with k3\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5])                  # 5 elements: valid coefficients\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8])         # 8 elements: rational model\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])  # 12 elements: with thin prism\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])  # 14 elements: full model\n&gt;&gt;&gt; d = CameraDistortion([])                               # Empty array for non-camera\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3])                        # ValueError: invalid length\n&gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6])               # ValueError: invalid length\n</code></pre> Source code in <code>t4_devkit/typing/camera.py</code> <pre><code>class CameraDistortion(np.ndarray):\n    \"\"\"A 1D array representing camera lens distortion coefficients.\n\n    This class represents the distortion parameters for a camera lens following\n    the OpenCV distortion model. It supports arrays of length 4, 5, 8, 12, or 14\n    elements, corresponding to different distortion models.\n\n    The distortion coefficients follow the OpenCV convention:\n    (k1, k2, p1, p2[, k3[, k4, k5, k6[, s1, s2, s3, s4[, \u03c4x, \u03c4y]]]])\n\n    Coefficient meanings:\n        - k1, k2, k3, k4, k5, k6: Radial distortion coefficients\n        - p1, p2: Tangential distortion coefficients\n        - s1, s2, s3, s4: Thin prism distortion coefficients\n        - \u03c4x, \u03c4y: Tilted sensor distortion coefficients\n\n    Supported array lengths:\n        - 4 elements: (k1, k2, p1, p2) - Basic radial and tangential\n        - 5 elements: (k1, k2, p1, p2, k3) - Extended radial distortion\n        - 8 elements: (k1, k2, p1, p2, k3, k4, k5, k6) - Rational model\n        - 12 elements: (k1, k2, p1, p2, k3, k4, k5, k6, s1, s2, s3, s4) - With thin prism\n        - 14 elements: (k1, k2, p1, p2, k3, k4, k5, k6, s1, s2, s3, s4, \u03c4x, \u03c4y) - Full model\n\n    Note that for non-camera, the array can be empty.\n\n    Examples:\n        &gt;&gt;&gt; d = CameraDistortion([0, 0, 0, 0])                     # 4 elements: basic model\n        &gt;&gt;&gt; d = CameraDistortion([0, 0, 0, 0, 0])                  # 5 elements: with k3\n        &gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5])                  # 5 elements: valid coefficients\n        &gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8])         # 8 elements: rational model\n        &gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12])  # 12 elements: with thin prism\n        &gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14])  # 14 elements: full model\n        &gt;&gt;&gt; d = CameraDistortion([])                               # Empty array for non-camera\n        &gt;&gt;&gt; d = CameraDistortion([1, 2, 3])                        # ValueError: invalid length\n        &gt;&gt;&gt; d = CameraDistortion([1, 2, 3, 4, 5, 6])               # ValueError: invalid length\n    \"\"\"\n\n    def __new__(cls, input_array: ArrayLike) -&gt; CameraDistortion:\n        obj = np.array(input_array).view(cls)\n\n        # skip validation if the array is empty for non-camera\n        if obj.size == 0:\n            return obj\n\n        # validate the shape of the array\n        # OpenCV supports distortion coefficient arrays of length 4, 5, 8, 12, or 14\n        valid_lengths = (4, 5, 8, 12, 14)\n        if obj.ndim != 1 or obj.shape[0] not in valid_lengths:\n            raise ValueError(\n                f\"CameraDistortion must be a 1D array of length {valid_lengths}, got: {obj.shape}\"\n            )\n\n        return obj\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.CameraIntrinsic","title":"<code>CameraIntrinsic</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>A 3x3 camera intrinsic matrix with validation.</p> <p>This class ensures that the input array is a 3x3 matrix and raises a ValueError if it is not. It can be constructed from a 3x3 array or 9 elements array.</p> <p>Note that for non-camera, the array can be empty.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; i = CameraIntrinsic(np.eye(3))                          # OK\n&gt;&gt;&gt; i = CameraIntrinsic([1, 0, 0, 0, 1, 0, 0, 0, 1])        # OK\n&gt;&gt;&gt; i = CameraIntrinsic([[1, 0, 0], [0, 1, 0], [0, 0, 1]])  # OK\n&gt;&gt;&gt; i = CameraIntrinsic([])                                 # OK\n&gt;&gt;&gt; i = CameraIntrinsic(np.eye(2))                          # ValueError\n&gt;&gt;&gt; i = CameraIntrinsic([1, 0, 0, 0, 1, 0, 0, 0])           # ValueError\n</code></pre> Source code in <code>t4_devkit/typing/camera.py</code> <pre><code>class CameraIntrinsic(np.ndarray):\n    \"\"\"A 3x3 camera intrinsic matrix with validation.\n\n    This class ensures that the input array is a 3x3 matrix and raises a ValueError if it is not.\n    It can be constructed from a 3x3 array or 9 elements array.\n\n    Note that for non-camera, the array can be empty.\n\n    Examples:\n        &gt;&gt;&gt; i = CameraIntrinsic(np.eye(3))                          # OK\n        &gt;&gt;&gt; i = CameraIntrinsic([1, 0, 0, 0, 1, 0, 0, 0, 1])        # OK\n        &gt;&gt;&gt; i = CameraIntrinsic([[1, 0, 0], [0, 1, 0], [0, 0, 1]])  # OK\n        &gt;&gt;&gt; i = CameraIntrinsic([])                                 # OK\n        &gt;&gt;&gt; i = CameraIntrinsic(np.eye(2))                          # ValueError\n        &gt;&gt;&gt; i = CameraIntrinsic([1, 0, 0, 0, 1, 0, 0, 0])           # ValueError\n    \"\"\"\n\n    def __new__(cls, input_array: ArrayLike) -&gt; CameraIntrinsic:\n        obj = np.array(input_array).view(cls)\n\n        # skip validation if the array is empty for non-camera\n        if obj.size == 0:\n            return obj\n\n        if obj.ndim == 1 and obj.shape == (9,):\n            obj = obj.reshape((3, 3))\n\n        # validate the shape of the array\n        if obj.shape != (3, 3):\n            raise ValueError(f\"CameraIntrinsic must be a 3x3 array, got: {obj.shape}\")\n\n        return obj\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Matrix3x3","title":"<code>Matrix3x3</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>A 3x3 matrix with validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; matrix = Matrix3x3([[1, 2, 3], [4, 5, 6], [7, 8, 9]])   # OK\n&gt;&gt;&gt; matrix = Matrix3x3(np.eye(3))                           # OK\n&gt;&gt;&gt; matrix = Matrix3x3([[1, 2], [4, 5], [7, 8]])            # ValueError\n&gt;&gt;&gt; matrix = Matrix3x3(np.eye(2))                           # ValueError\n</code></pre> Source code in <code>t4_devkit/typing/matrix.py</code> <pre><code>class Matrix3x3(np.ndarray):\n    \"\"\"A 3x3 matrix with validation.\n\n    Examples:\n        &gt;&gt;&gt; matrix = Matrix3x3([[1, 2, 3], [4, 5, 6], [7, 8, 9]])   # OK\n        &gt;&gt;&gt; matrix = Matrix3x3(np.eye(3))                           # OK\n        &gt;&gt;&gt; matrix = Matrix3x3([[1, 2], [4, 5], [7, 8]])            # ValueError\n        &gt;&gt;&gt; matrix = Matrix3x3(np.eye(2))                           # ValueError\n    \"\"\"\n\n    def __new__(cls, input_array: ArrayLike) -&gt; Matrix3x3:\n        obj = np.array(input_array).view(cls)\n        if obj.shape != (3, 3):\n            raise ValueError(f\"Input array must be of shape (3, 3), got: {obj.shape}\")\n        return obj\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Matrix4x4","title":"<code>Matrix4x4</code>","text":"<p>               Bases: <code>ndarray</code></p> <p>A 4x4 matrix with validation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; matrix = Matrix4x4([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) # OK\n&gt;&gt;&gt; matrix = Matrix4x4(np.eye(4))                                                       # OK\n&gt;&gt;&gt; matrix = Matrix4x4([[1, 2], [4, 5], [7, 8]])                                        # ValueError\n&gt;&gt;&gt; matrix = Matrix4x4(np.eye(2))                                                       # ValueError\n</code></pre> Source code in <code>t4_devkit/typing/matrix.py</code> <pre><code>class Matrix4x4(np.ndarray):\n    \"\"\"A 4x4 matrix with validation.\n\n    Examples:\n        &gt;&gt;&gt; matrix = Matrix4x4([[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]) # OK\n        &gt;&gt;&gt; matrix = Matrix4x4(np.eye(4))                                                       # OK\n        &gt;&gt;&gt; matrix = Matrix4x4([[1, 2], [4, 5], [7, 8]])                                        # ValueError\n        &gt;&gt;&gt; matrix = Matrix4x4(np.eye(2))                                                       # ValueError\n    \"\"\"\n\n    def __new__(cls, input_array: ArrayLike) -&gt; Matrix4x4:\n        obj = np.array(input_array).view(cls)\n        if obj.shape != (4, 4):\n            raise ValueError(f\"Input array must be of shape (4, 4), got: {obj.shape}\")\n        return obj\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Quaternion","title":"<code>Quaternion</code>","text":"<p>               Bases: <code>Quaternion</code></p> <p>A quaternion class that wraps the PyQuaternion class.</p> <p>This wrapper exists to provide a consistent and explicit quaternion representation.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; q = Quaternion(1, 2, 3, 4)\n&gt;&gt;&gt; q\nQuaternion(1.000000, 2.000000, 3.000000, 4.000000)\n&gt;&gt;&gt; q.conjugate()\nQuaternion(1.000000, -2.000000, -3.000000, -4.000000)\n&gt;&gt;&gt; q.norm()\n5.477226\n&gt;&gt;&gt; q.inverse()\nQuaternion(0.181818, -0.363636, -0.545455, -0.727273)\n&gt;&gt;&gt; q * q.inverse()\nQuaternion(1.000000, 0.000000, 0.000000, 0.000000)\n</code></pre> Source code in <code>t4_devkit/typing/quaternion.py</code> <pre><code>class Quaternion(PyQuaternion):\n    \"\"\"A quaternion class that wraps the PyQuaternion class.\n\n    This wrapper exists to provide a consistent and explicit quaternion representation.\n\n    Examples:\n        &gt;&gt;&gt; q = Quaternion(1, 2, 3, 4)\n        &gt;&gt;&gt; q\n        Quaternion(1.000000, 2.000000, 3.000000, 4.000000)\n        &gt;&gt;&gt; q.conjugate()\n        Quaternion(1.000000, -2.000000, -3.000000, -4.000000)\n        &gt;&gt;&gt; q.norm()\n        5.477226\n        &gt;&gt;&gt; q.inverse()\n        Quaternion(0.181818, -0.363636, -0.545455, -0.727273)\n        &gt;&gt;&gt; q * q.inverse()\n        Quaternion(1.000000, 0.000000, 0.000000, 0.000000)\n    \"\"\"\n\n    pass\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Roi","title":"<code>Roi</code>","text":"<p>               Bases: <code>tuple</code></p> <p>A 4-element tuple representing a region of interest (ROI).</p> <p>This class ensures that the array always has the correct shape and value order. It can be constructed from any array-like object that can be converted to a tuple of length 4, or from individual numeric arguments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; roi = Roi(10, 20, 30, 40)   # OK\n&gt;&gt;&gt; roi = Roi((10, 20, 30, 40)) # OK\n&gt;&gt;&gt; roi = Roi([10, 20, 30, 40]) # OK\n&gt;&gt;&gt; roi = Roi([10, 20])         # ValueError: ROI must be 4-elements\n&gt;&gt;&gt; roi = Roi([40, 30, 20, 10]) # ValueError: ROI must be xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax\n</code></pre> Source code in <code>t4_devkit/typing/roi.py</code> <pre><code>class Roi(tuple):\n    \"\"\"A 4-element tuple representing a region of interest (ROI).\n\n    This class ensures that the array always has the correct shape and value order.\n    It can be constructed from any array-like object that can be converted to a tuple of length 4,\n    or from individual numeric arguments.\n\n    Examples:\n        &gt;&gt;&gt; roi = Roi(10, 20, 30, 40)   # OK\n        &gt;&gt;&gt; roi = Roi((10, 20, 30, 40)) # OK\n        &gt;&gt;&gt; roi = Roi([10, 20, 30, 40]) # OK\n        &gt;&gt;&gt; roi = Roi([10, 20])         # ValueError: ROI must be 4-elements\n        &gt;&gt;&gt; roi = Roi([40, 30, 20, 10]) # ValueError: ROI must be xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax\n    \"\"\"\n\n    def __new__(cls, *args: Any) -&gt; Roi:\n        \"\"\"Create a new Roi instance.\n\n        Args:\n            *args: Either a single array-like object with 4 elements, or 4 individual numeric values.\n\n        Returns:\n            Roi instance.\n\n        Raises:\n            ValueError: If the input is not 4 elements or if the values are not in the correct order.\n        \"\"\"\n        # Handle different input formats\n        if len(args) == 1:\n            # Single argument - should be an iterable\n            try:\n                input_array = tuple(args[0])\n            except TypeError:\n                # Not iterable, treat as single value\n                input_array = args\n        elif len(args) == 4:\n            # Four individual arguments\n            input_array = args\n        else:\n            # Wrong number of arguments\n            input_array = args\n\n        # validate input shape of the array\n        if len(input_array) != 4:\n            raise ValueError(f\"ROI must be a 4-element tuple, got: {input_array}\")\n\n        # validate input value order of the array\n        xmin, ymin, xmax, ymax = input_array\n        if xmax &lt; xmin or ymax &lt; ymin:\n            raise ValueError(\n                f\"ROI must be (xmin, ymin, xmax, ymax) and xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax, got: {input_array}\"\n            )\n\n        return super().__new__(cls, input_array)\n\n    @property\n    def offset(self) -&gt; tuple[ScalarLike, ScalarLike]:\n        \"\"\"Return the xy offset from the image origin at the top left corner.\"\"\"\n        xmin, ymin, *_ = self\n        return xmin, ymin\n\n    @property\n    def size(self) -&gt; tuple[ScalarLike, ScalarLike]:\n        \"\"\"Return the width and height of the ROI.\"\"\"\n        xmin, ymin, xmax, ymax = self\n        return xmax - xmin, ymax - ymin\n\n    @property\n    def width(self) -&gt; ScalarLike:\n        \"\"\"Return the width of the ROI.\"\"\"\n        return self.size[0]\n\n    @property\n    def height(self) -&gt; ScalarLike:\n        \"\"\"Return the height of the ROI.\"\"\"\n        return self.size[1]\n\n    @property\n    def center(self) -&gt; tuple[ScalarLike, ScalarLike]:\n        \"\"\"Return the center position of the ROI.\"\"\"\n        xmin, ymin, xmax, ymax = self\n        return (xmin + xmax) / 2, (ymin + ymax) / 2\n\n    @property\n    def area(self) -&gt; ScalarLike:\n        \"\"\"Return the area of the ROI.\"\"\"\n        return self.width * self.height\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Roi.area","title":"<code>area</code>  <code>property</code>","text":"<p>Return the area of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.center","title":"<code>center</code>  <code>property</code>","text":"<p>Return the center position of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.height","title":"<code>height</code>  <code>property</code>","text":"<p>Return the height of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.offset","title":"<code>offset</code>  <code>property</code>","text":"<p>Return the xy offset from the image origin at the top left corner.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.size","title":"<code>size</code>  <code>property</code>","text":"<p>Return the width and height of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.width","title":"<code>width</code>  <code>property</code>","text":"<p>Return the width of the ROI.</p>"},{"location":"apis/typing/#t4_devkit.typing.Roi.__new__","title":"<code>__new__(*args)</code>","text":"<p>Create a new Roi instance.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <code>Any</code> <p>Either a single array-like object with 4 elements, or 4 individual numeric values.</p> <code>()</code> <p>Returns:</p> Type Description <code>Roi</code> <p>Roi instance.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the input is not 4 elements or if the values are not in the correct order.</p> Source code in <code>t4_devkit/typing/roi.py</code> <pre><code>def __new__(cls, *args: Any) -&gt; Roi:\n    \"\"\"Create a new Roi instance.\n\n    Args:\n        *args: Either a single array-like object with 4 elements, or 4 individual numeric values.\n\n    Returns:\n        Roi instance.\n\n    Raises:\n        ValueError: If the input is not 4 elements or if the values are not in the correct order.\n    \"\"\"\n    # Handle different input formats\n    if len(args) == 1:\n        # Single argument - should be an iterable\n        try:\n            input_array = tuple(args[0])\n        except TypeError:\n            # Not iterable, treat as single value\n            input_array = args\n    elif len(args) == 4:\n        # Four individual arguments\n        input_array = args\n    else:\n        # Wrong number of arguments\n        input_array = args\n\n    # validate input shape of the array\n    if len(input_array) != 4:\n        raise ValueError(f\"ROI must be a 4-element tuple, got: {input_array}\")\n\n    # validate input value order of the array\n    xmin, ymin, xmax, ymax = input_array\n    if xmax &lt; xmin or ymax &lt; ymin:\n        raise ValueError(\n            f\"ROI must be (xmin, ymin, xmax, ymax) and xmin &lt;= xmax &amp;&amp; ymin &lt;= ymax, got: {input_array}\"\n        )\n\n    return super().__new__(cls, input_array)\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Vector2","title":"<code>Vector2</code>","text":"<p>               Bases: <code>BaseVector</code></p> <p>A 2-element numpy array with validation.</p> <p>This class ensures that the array always has exactly 2 elements. It can be constructed from any array-like object that can be converted to a 2-element numpy array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = Vector2([1, 2])             # OK\n&gt;&gt;&gt; v = Vector2(np.array([1, 2]))   # OK\n&gt;&gt;&gt; v = Vector2(1, 2)               # OK\n&gt;&gt;&gt; v = Vector2([1, 2, 3])          # ValueError\n</code></pre> Source code in <code>t4_devkit/typing/vector.py</code> <pre><code>class Vector2(BaseVector):\n    \"\"\"A 2-element numpy array with validation.\n\n    This class ensures that the array always has exactly 2 elements.\n    It can be constructed from any array-like object that can be converted\n    to a 2-element numpy array.\n\n    Examples:\n        &gt;&gt;&gt; v = Vector2([1, 2])             # OK\n        &gt;&gt;&gt; v = Vector2(np.array([1, 2]))   # OK\n        &gt;&gt;&gt; v = Vector2(1, 2)               # OK\n        &gt;&gt;&gt; v = Vector2([1, 2, 3])          # ValueError\n    \"\"\"\n\n    _expected_shape = (2,)\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Vector3","title":"<code>Vector3</code>","text":"<p>               Bases: <code>BaseVector</code></p> <p>A 3-element numpy array with validation.</p> <p>This class ensures that the array always has exactly 3 elements. It can be constructed from any array-like object that can be converted to a 3-element numpy array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = Vector3([1, 2, 3])              # OK\n&gt;&gt;&gt; v = Vector3(np.array([1, 2, 3]))    # OK\n&gt;&gt;&gt; v = Vector3(1, 2, 3)                # OK\n&gt;&gt;&gt; v = Vector3([1, 2])                 # ValueError\n</code></pre> Source code in <code>t4_devkit/typing/vector.py</code> <pre><code>class Vector3(BaseVector):\n    \"\"\"A 3-element numpy array with validation.\n\n    This class ensures that the array always has exactly 3 elements.\n    It can be constructed from any array-like object that can be converted\n    to a 3-element numpy array.\n\n    Examples:\n        &gt;&gt;&gt; v = Vector3([1, 2, 3])              # OK\n        &gt;&gt;&gt; v = Vector3(np.array([1, 2, 3]))    # OK\n        &gt;&gt;&gt; v = Vector3(1, 2, 3)                # OK\n        &gt;&gt;&gt; v = Vector3([1, 2])                 # ValueError\n    \"\"\"\n\n    _expected_shape = (3,)\n</code></pre>"},{"location":"apis/typing/#t4_devkit.typing.Vector6","title":"<code>Vector6</code>","text":"<p>               Bases: <code>BaseVector</code></p> <p>A 6-element numpy array with validation.</p> <p>This class ensures that the array always has exactly 6 elements. It can be constructed from any array-like object that can be converted to a 6-element numpy array.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; v = Vector6([1, 2, 3, 4, 5, 6])             # OK\n&gt;&gt;&gt; v = Vector6(np.array([1, 2, 3, 4, 5, 6]))   # OK\n&gt;&gt;&gt; v = Vector6(1, 2, 3, 4, 5, 6)               # OK\n&gt;&gt;&gt; v = Vector6([1, 2])                         # ValueError\n</code></pre> Source code in <code>t4_devkit/typing/vector.py</code> <pre><code>class Vector6(BaseVector):\n    \"\"\"A 6-element numpy array with validation.\n\n    This class ensures that the array always has exactly 6 elements.\n    It can be constructed from any array-like object that can be converted\n    to a 6-element numpy array.\n\n    Examples:\n        &gt;&gt;&gt; v = Vector6([1, 2, 3, 4, 5, 6])             # OK\n        &gt;&gt;&gt; v = Vector6(np.array([1, 2, 3, 4, 5, 6]))   # OK\n        &gt;&gt;&gt; v = Vector6(1, 2, 3, 4, 5, 6)               # OK\n        &gt;&gt;&gt; v = Vector6([1, 2])                         # ValueError\n    \"\"\"\n\n    _expected_shape = (6,)\n</code></pre>"},{"location":"apis/viewer/","title":"<code>viewer</code>","text":""},{"location":"apis/viewer/#t4_devkit.viewer.EntityPath","title":"<code>EntityPath</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Entity path enumerations.</p> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>@unique\nclass EntityPath(str, Enum):\n    \"\"\"Entity path enumerations.\"\"\"\n\n    TIMELINE = \"timeline\"\n    MAP = \"map\"\n    BASE_LINK = \"map/base_link\"\n    GEOCOORDINATE = \"geocoordinate\"\n    VECTOR_MAP = \"vector_map\"\n    BOX = \"box\"\n    VELOCITY = \"velocity\"\n    FUTURE = \"future\"\n    SEGMENTATION = \"segmentation\"\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.PointCloudColorMode","title":"<code>PointCloudColorMode</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>Color mode of point cloud.</p> Source code in <code>t4_devkit/viewer/color.py</code> <pre><code>@unique\nclass PointCloudColorMode(str, Enum):\n    \"\"\"Color mode of point cloud.\"\"\"\n\n    DISTANCE = \"distance\"\n    INTENSITY = \"intensity\"\n    SEGMENTATION = \"segmentation\"\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer","title":"<code>RerunViewer</code>","text":"<p>A viewer class that renders some components powered by rerun.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>class RerunViewer:\n    \"\"\"A viewer class that renders some components powered by rerun.\"\"\"\n\n    def __init__(\n        self,\n        app_id: str,\n        config: ViewerConfig = ViewerConfig(),\n        save_dir: str | None = None,\n    ) -&gt; None:\n        \"\"\"Construct a new object.\n\n        Args:\n            app_id (str): Application ID.\n            config (ViewerConfig): Configuration of the viewer.\n            save_dir (str | None, optional): Directory path to save the recording.\n                Viewer will be spawned if it is None, otherwise not.\n\n        Examples:\n            &gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n            &gt;&gt;&gt; viewer = (\n                    ViewerBuilder()\n                    .with_spatial3d()\n                    .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n                    .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n                    .with_streetmap(latlon=[48.8566, 2.3522])\n                    .build(app_id=\"my_viewer\")\n                )\n        \"\"\"\n        self.app_id = app_id\n        self.config = config\n        self.blueprint = self.config.to_blueprint()\n\n        rr.init(\n            application_id=self.app_id,\n            recording_id=None,\n            spawn=save_dir is None,\n            default_enabled=True,\n            strict=True,\n            default_blueprint=self.blueprint,\n        )\n\n        # NOTE: rr.save() must be invoked before logging\n        if save_dir is not None:\n            self._start_saving(save_dir=save_dir)\n\n        rr.log(EntityPath.MAP, rr.ViewCoordinates.RIGHT_HAND_Z_UP, static=True)\n\n        rr.log(\n            EntityPath.MAP,\n            rr.AnnotationContext(\n                [\n                    rr.AnnotationInfo(id=label_id, label=label)\n                    for label, label_id in self.label2id.items()\n                ]\n            ),\n            static=True,\n        )\n\n    @property\n    def label2id(self) -&gt; dict[str, int]:\n        return self.config.label2id\n\n    @property\n    def latlon(self) -&gt; Vector2Like | None:\n        return self.config.latlon\n\n    def _start_saving(self, save_dir: str) -&gt; None:\n        \"\"\"Save recording result as `save_dir/{app_id}.rrd`.\n\n        Note:\n            This method must be called before any logging started.\n\n        Args:\n            save_dir (str): Directory path to save the result.\n        \"\"\"\n        filepath = osp.join(save_dir, f\"{self.app_id}.rrd\")\n        rr.save(filepath, default_blueprint=self.blueprint)\n\n    @overload\n    def render_box3ds(self, seconds: float, boxes: Sequence[Box3D]) -&gt; None:\n        \"\"\"Render 3D boxes.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            boxes (Sequence[Box3D]): Sequence of `Box3D`s.\n        \"\"\"\n        pass\n\n    @overload\n    def render_box3ds(\n        self,\n        seconds: float,\n        frame_id: str,\n        centers: Sequence[Vector3Like],\n        rotations: Sequence[RotationLike],\n        sizes: Sequence[Vector3Like],\n        class_ids: Sequence[int],\n        velocities: Sequence[Vector3Like] | None = None,\n        uuids: Sequence[str] | None = None,\n        futures: Sequence[Future] | None = None,\n    ) -&gt; None:\n        \"\"\"Render 3D boxes with its elements.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            frame_id (str): Frame ID.\n            centers (Sequence[Vector3Like]): Sequence of 3D positions in the order of (x, y, z).\n            rotations (Sequence[RotationLike]): Sequence of rotations.\n            sizes (Sequence[Vector3Like]): Sequence of box sizes in the order of (width, length, height).\n            class_ids (Sequence[int]): Sequence of class IDs.\n            velocities (Sequence[Vector3Like] | None, optional): Sequence of velocities.\n            uuids (Sequence[str] | None, optional): Sequence of unique identifiers.\n            futures (Sequence[Future] | None, optional): Sequence future trajectories.\n        \"\"\"\n        pass\n\n    @_check_spatial3d\n    def render_box3ds(self, *args, **kwargs) -&gt; None:\n        \"\"\"Render 3D boxes.\"\"\"\n        if len(args) + len(kwargs) == 2:\n            self._render_box3ds_with_boxes(*args, **kwargs)\n        else:\n            self._render_box3ds_with_elements(*args, **kwargs)\n\n    def _render_box3ds_with_boxes(self, seconds: float, boxes: Sequence[Box3D]) -&gt; None:\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n        batches: dict[str, BatchBox3D] = {}\n        for box in boxes:\n            if box.frame_id not in batches:\n                batches[box.frame_id] = BatchBox3D(label2id=self.label2id)\n            batches[box.frame_id].append(box)\n\n        for frame_id, batch in batches.items():\n            # record boxes 3d\n            rr.log(\n                format_entity(EntityPath.MAP, frame_id, EntityPath.BOX),\n                batch.as_boxes3d(),\n            )\n            # record velocities\n            rr.log(\n                format_entity(EntityPath.MAP, frame_id, EntityPath.VELOCITY),\n                batch.as_arrows3d(),\n            )\n            # record futures\n            rr.log(\n                format_entity(EntityPath.MAP, frame_id, EntityPath.FUTURE),\n                batch.as_linestrips3d(),\n            )\n\n    def _render_box3ds_with_elements(\n        self,\n        seconds: float,\n        frame_id: str,\n        centers: Sequence[Vector3Like],\n        rotations: Sequence[RotationLike],\n        sizes: Sequence[Vector3Like],\n        class_ids: Sequence[int],\n        velocities: Sequence[Vector3Like | None] | None = None,\n        uuids: Sequence[str | None] | None = None,\n        futures: Sequence[Future | None] | None = None,\n    ) -&gt; None:\n        if uuids is None:\n            uuids = [None] * len(centers)\n\n        if velocities is None:\n            velocities = [None] * len(centers)\n            show_arrows = False\n        else:\n            show_arrows = True\n\n        if futures is None:\n            futures = [None] * len(centers)\n            show_futures = False\n        else:\n            show_futures = True\n\n        batch = BatchBox3D(label2id=self.label2id)\n        for center, rotation, size, class_id, velocity, uuid, future in zip(\n            centers,\n            rotations,\n            sizes,\n            class_ids,\n            velocities,\n            uuids,\n            futures,\n            strict=True,\n        ):\n            batch.append(\n                center=center,\n                rotation=rotation,\n                size=size,\n                class_id=class_id,\n                velocity=velocity,\n                uuid=uuid,\n                future=future,\n            )\n\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n        rr.log(format_entity(EntityPath.MAP, frame_id, EntityPath.BOX), batch.as_boxes3d())\n\n        if show_arrows:\n            rr.log(\n                format_entity(EntityPath.MAP, frame_id, EntityPath.VELOCITY),\n                batch.as_arrows3d(),\n            )\n\n        if show_futures:\n            rr.log(\n                format_entity(EntityPath.MAP, frame_id, EntityPath.FUTURE),\n                batch.as_linestrips3d(),\n            )\n\n    @overload\n    def render_box2ds(self, seconds: float, boxes: Sequence[Box2D]) -&gt; None:\n        \"\"\"Render 2D boxes. Note that if the viewer initialized without `cameras=None`,\n        no 2D box will be rendered.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            boxes (Sequence[Box2D]): Sequence of `Box2D`s.\n        \"\"\"\n        pass\n\n    @overload\n    def render_box2ds(\n        self,\n        seconds: float,\n        camera: str,\n        rois: Sequence[RoiLike],\n        class_ids: Sequence[int],\n        uuids: Sequence[str] | None = None,\n    ) -&gt; None:\n        \"\"\"Render 2D boxes with its elements.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            camera (str): Camera name.\n            rois (Sequence[RoiLike]): Sequence of ROIs in the order of (xmin, ymin, xmax, ymax).\n            class_ids (Sequence[int]): Sequence of class IDs.\n            uuids (Sequence[str] | None, optional): Sequence of unique identifiers.\n        \"\"\"\n        pass\n\n    @_check_spatial2d\n    def render_box2ds(self, *args, **kwargs) -&gt; None:\n        \"\"\"Render 2D boxes.\"\"\"\n        if len(args) + len(kwargs) == 2:\n            self._render_box2ds_with_boxes(*args, **kwargs)\n        else:\n            self._render_box2ds_with_elements(*args, **kwargs)\n\n    def _render_box2ds_with_boxes(self, seconds: float, boxes: Sequence[Box2D]) -&gt; None:\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n        batches: dict[str, BatchBox2D] = {}\n        for box in boxes:\n            if box.frame_id not in batches:\n                batches[box.frame_id] = BatchBox2D(label2id=self.label2id)\n            batches[box.frame_id].append(box)\n\n        for frame_id, batch in batches.items():\n            rr.log(\n                format_entity(EntityPath.BASE_LINK, frame_id, EntityPath.BOX),\n                batch.as_boxes2d(),\n            )\n\n    def _render_box2ds_with_elements(\n        self,\n        seconds: float,\n        camera: str,\n        rois: Sequence[RoiLike],\n        class_ids: Sequence[int],\n        uuids: Sequence[str | None] | None = None,\n    ) -&gt; None:\n        if uuids is None:\n            uuids = [None] * len(rois)\n\n        batch = BatchBox2D(label2id=self.label2id)\n        for roi, class_id, uuid in zip(rois, class_ids, uuids, strict=True):\n            batch.append(roi=roi, class_id=class_id, uuid=uuid)\n\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n        rr.log(format_entity(EntityPath.BASE_LINK, camera, EntityPath.BOX), batch.as_boxes2d())\n\n    @_check_spatial2d\n    def render_segmentation2d(\n        self,\n        seconds: float,\n        camera: str,\n        masks: Sequence[NDArrayU8],\n        class_ids: Sequence[int],\n        uuids: Sequence[str | None] | None = None,\n    ) -&gt; None:\n        \"\"\"Render 2D segmentation image.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            camera (str): Name of camera channel.\n            masks (Sequence[NDArrayU8]): Sequence of segmentation mask of each instance,\n                each mask is the shape of (W, H).\n            class_ids (Sequence[int]): Sequence of label ids.\n            uuids (Sequence[str | None] | None, optional): Sequence of each instance ID.\n        \"\"\"\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n        batch = BatchSegmentation2D()\n        if uuids is None:\n            uuids = [None] * len(masks)\n        for mask, class_id, uuid in zip(masks, class_ids, uuids, strict=True):\n            batch.append(mask, class_id, uuid)\n\n        rr.log(\n            format_entity(EntityPath.BASE_LINK, camera, EntityPath.SEGMENTATION),\n            batch.as_segmentation_image(),\n        )\n\n    @_check_spatial3d\n    def render_pointcloud(\n        self,\n        seconds: float,\n        channel: str,\n        pointcloud: PointCloudLike,\n        color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n    ) -&gt; None:\n        \"\"\"Render pointcloud.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            channel (str): Name of the pointcloud sensor channel.\n            pointcloud (PointCloudLike): Inherence object of `PointCloud`.\n            color_mode (PointCloudColorMode, optional): Color mode for pointcloud.\n        \"\"\"\n        # TODO(ktro2828): add support of rendering pointcloud on images\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n        entity_path = format_entity(EntityPath.BASE_LINK, channel)\n        if color_mode == PointCloudColorMode.SEGMENTATION:\n            if not isinstance(pointcloud, SegmentationPointCloud):\n                raise TypeError(\n                    f\"Expected SegmentationPointCloud instance, but got {type(pointcloud)}\"\n                )\n\n            entity = rr.Points3D(pointcloud.points[:3].T, class_ids=pointcloud.labels)\n        else:\n            colors = pointcloud_color(pointcloud, color_mode=color_mode)\n            entity = rr.Points3D(pointcloud.points[:3].T, colors=colors)\n\n        rr.log(entity_path, entity)\n\n    @_check_spatial2d\n    def render_image(self, seconds: float, camera: str, image: str | NDArrayU8) -&gt; None:\n        \"\"\"Render an image.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            camera (str): Name of the camera channel.\n            image (str | NDArrayU8): Image tensor or path of the image file.\n        \"\"\"\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n        entity_path = format_entity(EntityPath.BASE_LINK, camera)\n        entity = rr.ImageEncoded(path=image) if isinstance(image, str) else rr.Image(image)\n\n        rr.log(entity_path, entity)\n\n    @overload\n    def render_ego(self, ego_pose: EgoPose) -&gt; None:\n        \"\"\"Render an ego pose.\n\n        Args:\n            ego_pose (EgoPose): `EgoPose` object.\n        \"\"\"\n        pass\n\n    @overload\n    def render_ego(\n        self,\n        seconds: float,\n        translation: Vector3Like,\n        rotation: RotationLike,\n        geocoordinate: Vector3Like | None = None,\n    ) -&gt; None:\n        \"\"\"Render an ego pose.\n\n        Args:\n            seconds (float): Timestamp in [sec].\n            translation (Vector3Like): 3D position in the map coordinate system\n              , in the order of (x, y, z) in [m].\n            rotation (RotationLike): Rotation in the map coordinate system.\n            geocoordinate (Vector3Like | None, optional): Coordinates in the WGS 84\n                reference ellipsoid (latitude, longitude, altitude) in degrees and meters.\n        \"\"\"\n        pass\n\n    @_check_spatial3d\n    def render_ego(self, *args, **kwargs) -&gt; None:\n        \"\"\"Render an ego pose.\"\"\"\n        if len(args) + len(kwargs) == 1:\n            self._render_ego_with_schema(*args, **kwargs)\n        else:\n            self._render_ego_without_schema(*args, **kwargs)\n\n    def _render_ego_with_schema(self, ego_pose: EgoPose) -&gt; None:\n        self._render_ego_without_schema(\n            seconds=microseconds2seconds(ego_pose.timestamp),\n            translation=ego_pose.translation,\n            rotation=ego_pose.rotation,\n            geocoordinate=ego_pose.geocoordinate,\n        )\n\n    def _render_ego_without_schema(\n        self,\n        seconds: float,\n        translation: Vector3Like,\n        rotation: RotationLike,\n        geocoordinate: Vector3Like | None = None,\n    ) -&gt; None:\n        rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n        rr.log(\n            EntityPath.BASE_LINK,\n            rr.Transform3D(\n                translation=translation,\n                rotation=_to_rerun_quaternion(rotation),\n                relation=rr.TransformRelation.ParentFromChild,\n            ),\n        )\n\n        entity_path = EntityPath.GEOCOORDINATE\n        if geocoordinate is not None:\n            rr.log(entity_path, rr.GeoPoints(lat_lon=geocoordinate[:2]))\n        elif self.latlon is not None:\n            latitude, longitude = calculate_geodetic_point(translation, self.latlon)\n            rr.log(entity_path, rr.GeoPoints(lat_lon=(latitude, longitude)))\n\n    @overload\n    def render_calibration(\n        self,\n        sensor: Sensor,\n        calibration: CalibratedSensor,\n        resolution: Vector2Like | None = None,\n    ) -&gt; None:\n        \"\"\"Render a sensor calibration.\n\n        Args:\n            sensor (Sensor): `Sensor` object.\n            calibration (CalibratedSensor): `CalibratedSensor` object.\n            resolution (Vector2Like | None, optional): Camera resolution (width, height).\n        \"\"\"\n        pass\n\n    @overload\n    def render_calibration(\n        self,\n        channel: str,\n        modality: str | SensorModality,\n        translation: Vector3Like,\n        rotation: RotationLike,\n        camera_intrinsic: CameraIntrinsicLike | None = None,\n        resolution: Vector2Like | None = None,\n    ) -&gt; None:\n        \"\"\"Render a sensor calibration.\n\n        Args:\n            channel (str): Name of the sensor channel.\n            modality (str | SensorModality): Sensor modality.\n            translation (Vector3Like): Sensor translation in ego centric coords.\n            rotation (RotationLike): Sensor rotation in ego centric coords.\n            camera_intrinsic (CameraIntrinsicLike | None, optional): Camera intrinsic matrix.\n            resolution (Vector2Like | None, optional): Camera resolution (width, height).\n        \"\"\"\n        pass\n\n    @_check_spatial3d\n    def render_calibration(self, *args, **kwargs) -&gt; None:\n        \"\"\"Render a sensor calibration.\"\"\"\n        if len(args) + len(kwargs) &lt;= 3:\n            self._render_calibration_with_schema(*args, **kwargs)\n        else:\n            self._render_calibration_without_schema(*args, **kwargs)\n\n    def _render_calibration_with_schema(\n        self,\n        sensor: Sensor,\n        calibration: CalibratedSensor,\n        resolution: Vector2Like | None = None,\n    ) -&gt; None:\n        self._render_calibration_without_schema(\n            channel=sensor.channel,\n            modality=sensor.modality,\n            translation=calibration.translation,\n            rotation=calibration.rotation,\n            camera_intrinsic=calibration.camera_intrinsic,\n            resolution=resolution,\n        )\n\n    def _render_calibration_without_schema(\n        self,\n        channel: str,\n        modality: str | SensorModality,\n        translation: Vector3Like,\n        rotation: RotationLike,\n        camera_intrinsic: CameraIntrinsicLike | None = None,\n        resolution: Vector2Like | None = None,\n    ) -&gt; None:\n        \"\"\"Render a sensor calibration.\n\n        Args:\n            channel (str): Name of the sensor channel.\n            modality (str | SensorModality): Sensor modality.\n            translation (Vector3Like): Sensor translation in ego centric coords.\n            rotation (RotationLike): Sensor rotation in ego centric coords.\n            camera_intrinsic (CameraIntrinsicLike | None, optional): Camera intrinsic matrix.\n            resolution (Vector2Like | None, optional): Camera resolution (width, height).\n        \"\"\"\n        rr.log(\n            format_entity(EntityPath.BASE_LINK, channel),\n            rr.Transform3D(translation=translation, rotation=_to_rerun_quaternion(rotation)),\n            static=True,\n        )\n\n        if modality == SensorModality.CAMERA:\n            rr.log(\n                format_entity(EntityPath.BASE_LINK, channel),\n                rr.Pinhole(image_from_camera=camera_intrinsic, resolution=resolution),\n                static=True,\n            )\n\n    @_check_filepath\n    @_check_spatial3d\n    def render_map(self, filepath: str) -&gt; None:\n        \"\"\"Render vector map.\n\n        Args:\n            filepath (str): Path to OSM file.\n        \"\"\"\n        parser = LaneletParser(filepath, verbose=False)\n\n        root_entity = format_entity(EntityPath.MAP, EntityPath.VECTOR_MAP)\n        render_lanelets(parser, root_entity)\n        render_traffic_elements(parser, root_entity)\n        render_ways(parser, root_entity)\n\n        render_geographic_borders(parser, f\"{EntityPath.GEOCOORDINATE}/{EntityPath.VECTOR_MAP}\")\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.__init__","title":"<code>__init__(app_id, config=ViewerConfig(), save_dir=None)</code>","text":"<p>Construct a new object.</p> <p>Parameters:</p> Name Type Description Default <code>app_id</code> <code>str</code> <p>Application ID.</p> required <code>config</code> <code>ViewerConfig</code> <p>Configuration of the viewer.</p> <code>ViewerConfig()</code> <code>save_dir</code> <code>str | None</code> <p>Directory path to save the recording. Viewer will be spawned if it is None, otherwise not.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n&gt;&gt;&gt; viewer = (\n        ViewerBuilder()\n        .with_spatial3d()\n        .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n        .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n        .with_streetmap(latlon=[48.8566, 2.3522])\n        .build(app_id=\"my_viewer\")\n    )\n</code></pre> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>def __init__(\n    self,\n    app_id: str,\n    config: ViewerConfig = ViewerConfig(),\n    save_dir: str | None = None,\n) -&gt; None:\n    \"\"\"Construct a new object.\n\n    Args:\n        app_id (str): Application ID.\n        config (ViewerConfig): Configuration of the viewer.\n        save_dir (str | None, optional): Directory path to save the recording.\n            Viewer will be spawned if it is None, otherwise not.\n\n    Examples:\n        &gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n        &gt;&gt;&gt; viewer = (\n                ViewerBuilder()\n                .with_spatial3d()\n                .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n                .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n                .with_streetmap(latlon=[48.8566, 2.3522])\n                .build(app_id=\"my_viewer\")\n            )\n    \"\"\"\n    self.app_id = app_id\n    self.config = config\n    self.blueprint = self.config.to_blueprint()\n\n    rr.init(\n        application_id=self.app_id,\n        recording_id=None,\n        spawn=save_dir is None,\n        default_enabled=True,\n        strict=True,\n        default_blueprint=self.blueprint,\n    )\n\n    # NOTE: rr.save() must be invoked before logging\n    if save_dir is not None:\n        self._start_saving(save_dir=save_dir)\n\n    rr.log(EntityPath.MAP, rr.ViewCoordinates.RIGHT_HAND_Z_UP, static=True)\n\n    rr.log(\n        EntityPath.MAP,\n        rr.AnnotationContext(\n            [\n                rr.AnnotationInfo(id=label_id, label=label)\n                for label, label_id in self.label2id.items()\n            ]\n        ),\n        static=True,\n    )\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_box2ds","title":"<code>render_box2ds(*args, **kwargs)</code>","text":"<pre><code>render_box2ds(\n    seconds: float, boxes: Sequence[Box2D]\n) -&gt; None\n</code></pre><pre><code>render_box2ds(\n    seconds: float,\n    camera: str,\n    rois: Sequence[RoiLike],\n    class_ids: Sequence[int],\n    uuids: Sequence[str] | None = None,\n) -&gt; None\n</code></pre> <p>Render 2D boxes.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial2d\ndef render_box2ds(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render 2D boxes.\"\"\"\n    if len(args) + len(kwargs) == 2:\n        self._render_box2ds_with_boxes(*args, **kwargs)\n    else:\n        self._render_box2ds_with_elements(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_box3ds","title":"<code>render_box3ds(*args, **kwargs)</code>","text":"<pre><code>render_box3ds(\n    seconds: float, boxes: Sequence[Box3D]\n) -&gt; None\n</code></pre><pre><code>render_box3ds(\n    seconds: float,\n    frame_id: str,\n    centers: Sequence[Vector3Like],\n    rotations: Sequence[RotationLike],\n    sizes: Sequence[Vector3Like],\n    class_ids: Sequence[int],\n    velocities: Sequence[Vector3Like] | None = None,\n    uuids: Sequence[str] | None = None,\n    futures: Sequence[Future] | None = None,\n) -&gt; None\n</code></pre> <p>Render 3D boxes.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_box3ds(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render 3D boxes.\"\"\"\n    if len(args) + len(kwargs) == 2:\n        self._render_box3ds_with_boxes(*args, **kwargs)\n    else:\n        self._render_box3ds_with_elements(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_calibration","title":"<code>render_calibration(*args, **kwargs)</code>","text":"<pre><code>render_calibration(\n    sensor: Sensor,\n    calibration: CalibratedSensor,\n    resolution: Vector2Like | None = None,\n) -&gt; None\n</code></pre><pre><code>render_calibration(\n    channel: str,\n    modality: str | SensorModality,\n    translation: Vector3Like,\n    rotation: RotationLike,\n    camera_intrinsic: CameraIntrinsicLike | None = None,\n    resolution: Vector2Like | None = None,\n) -&gt; None\n</code></pre> <p>Render a sensor calibration.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_calibration(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render a sensor calibration.\"\"\"\n    if len(args) + len(kwargs) &lt;= 3:\n        self._render_calibration_with_schema(*args, **kwargs)\n    else:\n        self._render_calibration_without_schema(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_ego","title":"<code>render_ego(*args, **kwargs)</code>","text":"<pre><code>render_ego(ego_pose: EgoPose) -&gt; None\n</code></pre><pre><code>render_ego(\n    seconds: float,\n    translation: Vector3Like,\n    rotation: RotationLike,\n    geocoordinate: Vector3Like | None = None,\n) -&gt; None\n</code></pre> <p>Render an ego pose.</p> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_ego(self, *args, **kwargs) -&gt; None:\n    \"\"\"Render an ego pose.\"\"\"\n    if len(args) + len(kwargs) == 1:\n        self._render_ego_with_schema(*args, **kwargs)\n    else:\n        self._render_ego_without_schema(*args, **kwargs)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_image","title":"<code>render_image(seconds, camera, image)</code>","text":"<p>Render an image.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Timestamp in [sec].</p> required <code>camera</code> <code>str</code> <p>Name of the camera channel.</p> required <code>image</code> <code>str | NDArrayU8</code> <p>Image tensor or path of the image file.</p> required Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial2d\ndef render_image(self, seconds: float, camera: str, image: str | NDArrayU8) -&gt; None:\n    \"\"\"Render an image.\n\n    Args:\n        seconds (float): Timestamp in [sec].\n        camera (str): Name of the camera channel.\n        image (str | NDArrayU8): Image tensor or path of the image file.\n    \"\"\"\n    rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n    entity_path = format_entity(EntityPath.BASE_LINK, camera)\n    entity = rr.ImageEncoded(path=image) if isinstance(image, str) else rr.Image(image)\n\n    rr.log(entity_path, entity)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_map","title":"<code>render_map(filepath)</code>","text":"<p>Render vector map.</p> <p>Parameters:</p> Name Type Description Default <code>filepath</code> <code>str</code> <p>Path to OSM file.</p> required Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_filepath\n@_check_spatial3d\ndef render_map(self, filepath: str) -&gt; None:\n    \"\"\"Render vector map.\n\n    Args:\n        filepath (str): Path to OSM file.\n    \"\"\"\n    parser = LaneletParser(filepath, verbose=False)\n\n    root_entity = format_entity(EntityPath.MAP, EntityPath.VECTOR_MAP)\n    render_lanelets(parser, root_entity)\n    render_traffic_elements(parser, root_entity)\n    render_ways(parser, root_entity)\n\n    render_geographic_borders(parser, f\"{EntityPath.GEOCOORDINATE}/{EntityPath.VECTOR_MAP}\")\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_pointcloud","title":"<code>render_pointcloud(seconds, channel, pointcloud, color_mode=PointCloudColorMode.DISTANCE)</code>","text":"<p>Render pointcloud.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Timestamp in [sec].</p> required <code>channel</code> <code>str</code> <p>Name of the pointcloud sensor channel.</p> required <code>pointcloud</code> <code>PointCloudLike</code> <p>Inherence object of <code>PointCloud</code>.</p> required <code>color_mode</code> <code>PointCloudColorMode</code> <p>Color mode for pointcloud.</p> <code>DISTANCE</code> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial3d\ndef render_pointcloud(\n    self,\n    seconds: float,\n    channel: str,\n    pointcloud: PointCloudLike,\n    color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n) -&gt; None:\n    \"\"\"Render pointcloud.\n\n    Args:\n        seconds (float): Timestamp in [sec].\n        channel (str): Name of the pointcloud sensor channel.\n        pointcloud (PointCloudLike): Inherence object of `PointCloud`.\n        color_mode (PointCloudColorMode, optional): Color mode for pointcloud.\n    \"\"\"\n    # TODO(ktro2828): add support of rendering pointcloud on images\n    rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n    entity_path = format_entity(EntityPath.BASE_LINK, channel)\n    if color_mode == PointCloudColorMode.SEGMENTATION:\n        if not isinstance(pointcloud, SegmentationPointCloud):\n            raise TypeError(\n                f\"Expected SegmentationPointCloud instance, but got {type(pointcloud)}\"\n            )\n\n        entity = rr.Points3D(pointcloud.points[:3].T, class_ids=pointcloud.labels)\n    else:\n        colors = pointcloud_color(pointcloud, color_mode=color_mode)\n        entity = rr.Points3D(pointcloud.points[:3].T, colors=colors)\n\n    rr.log(entity_path, entity)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.RerunViewer.render_segmentation2d","title":"<code>render_segmentation2d(seconds, camera, masks, class_ids, uuids=None)</code>","text":"<p>Render 2D segmentation image.</p> <p>Parameters:</p> Name Type Description Default <code>seconds</code> <code>float</code> <p>Timestamp in [sec].</p> required <code>camera</code> <code>str</code> <p>Name of camera channel.</p> required <code>masks</code> <code>Sequence[NDArrayU8]</code> <p>Sequence of segmentation mask of each instance, each mask is the shape of (W, H).</p> required <code>class_ids</code> <code>Sequence[int]</code> <p>Sequence of label ids.</p> required <code>uuids</code> <code>Sequence[str | None] | None</code> <p>Sequence of each instance ID.</p> <code>None</code> Source code in <code>t4_devkit/viewer/viewer.py</code> <pre><code>@_check_spatial2d\ndef render_segmentation2d(\n    self,\n    seconds: float,\n    camera: str,\n    masks: Sequence[NDArrayU8],\n    class_ids: Sequence[int],\n    uuids: Sequence[str | None] | None = None,\n) -&gt; None:\n    \"\"\"Render 2D segmentation image.\n\n    Args:\n        seconds (float): Timestamp in [sec].\n        camera (str): Name of camera channel.\n        masks (Sequence[NDArrayU8]): Sequence of segmentation mask of each instance,\n            each mask is the shape of (W, H).\n        class_ids (Sequence[int]): Sequence of label ids.\n        uuids (Sequence[str | None] | None, optional): Sequence of each instance ID.\n    \"\"\"\n    rr.set_time_seconds(EntityPath.TIMELINE, seconds)\n\n    batch = BatchSegmentation2D()\n    if uuids is None:\n        uuids = [None] * len(masks)\n    for mask, class_id, uuid in zip(masks, class_ids, uuids, strict=True):\n        batch.append(mask, class_id, uuid)\n\n    rr.log(\n        format_entity(EntityPath.BASE_LINK, camera, EntityPath.SEGMENTATION),\n        batch.as_segmentation_image(),\n    )\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerBuilder","title":"<code>ViewerBuilder</code>","text":"<p>Builder for creating a RerunViewer instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n&gt;&gt;&gt; viewer = (\n        ViewerBuilder()\n        .with_spatial3d()\n        .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n        .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n        .with_streetmap(latlon=[48.8566, 2.3522])\n        .build(app_id=\"my_viewer\")\n    )\n</code></pre> Source code in <code>t4_devkit/viewer/builder.py</code> <pre><code>class ViewerBuilder:\n    \"\"\"Builder for creating a RerunViewer instance.\n\n    Examples:\n        &gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n        &gt;&gt;&gt; viewer = (\n                ViewerBuilder()\n                .with_spatial3d()\n                .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n                .with_labels(label2id={\"car\": 1, \"pedestrian\": 2})\n                .with_streetmap(latlon=[48.8566, 2.3522])\n                .build(app_id=\"my_viewer\")\n            )\n    \"\"\"\n\n    def __init__(self) -&gt; None:\n        self._config = ViewerConfig()\n\n    def with_spatial3d(self) -&gt; Self:\n        self._config.spatial3ds.append(rrb.Spatial3DView(name=\"3D\", origin=EntityPath.MAP))\n        return self\n\n    def with_spatial2d(self, cameras: Sequence[str], contents: list[str] | None = None) -&gt; Self:\n        # Preserve the original contents arguments so each camera gets its own view_contents.\n        base_contents = contents\n        for name in cameras:\n            origin = format_entity(EntityPath.BASE_LINK, name)\n\n            default_contents = [format_entity(origin, \"**\")]\n            view_contents = (\n                default_contents if base_contents is None else default_contents + base_contents\n            )\n\n            self._config.spatial2ds.append(\n                rrb.Spatial2DView(name=name, origin=origin, contents=view_contents)\n            )\n        return self\n\n    def with_labels(self, label2id: dict[str, int]) -&gt; Self:\n        self._config.label2id = label2id\n        return self\n\n    def with_streetmap(self, latlon: Vector2Like | None = None) -&gt; Self:\n        self._config.spatial3ds.append(rrb.MapView(name=\"Map\", origin=EntityPath.GEOCOORDINATE))\n        if latlon is not None:\n            self._config.latlon = latlon\n        return self\n\n    def build(self, app_id: str, save_dir: str | None = None) -&gt; RerunViewer:\n        return RerunViewer(app_id=app_id, config=self._config, save_dir=save_dir)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig","title":"<code>ViewerConfig</code>","text":"Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>@define\nclass ViewerConfig:\n    spatial3ds: list[rrb.Spatial3DView | rrb.MapView] = field(factory=list)\n    spatial2ds: list[rrb.Spatial2DView] = field(factory=list)\n    label2id: dict[str, int] = field(factory=dict)\n    latlon: Vector2Like | None = field(default=None)\n\n    def to_blueprint(self) -&gt; rrb.BlueprintLike:\n        \"\"\"Return the recording blueprint.\"\"\"\n        views = []\n        if self.spatial3ds:\n            views.append(rrb.Horizontal(*self.spatial3ds, column_shares=[3, 1]))\n        if self.spatial2ds:\n            views.append(rrb.Grid(*self.spatial2ds))\n\n        return rrb.Vertical(*views, row_shares=[4, 2])\n\n    def has_spatial3d(self) -&gt; bool:\n        \"\"\"Return `True` if the configuration contains 3D view space.\"\"\"\n        return len(self.spatial3ds) &gt; 0\n\n    def has_spatial2d(self) -&gt; bool:\n        \"\"\"Return `True` if the configuration contains 2D view space.\"\"\"\n        return len(self.spatial2ds) &gt; 0\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig.has_spatial2d","title":"<code>has_spatial2d()</code>","text":"<p>Return <code>True</code> if the configuration contains 2D view space.</p> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def has_spatial2d(self) -&gt; bool:\n    \"\"\"Return `True` if the configuration contains 2D view space.\"\"\"\n    return len(self.spatial2ds) &gt; 0\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig.has_spatial3d","title":"<code>has_spatial3d()</code>","text":"<p>Return <code>True</code> if the configuration contains 3D view space.</p> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def has_spatial3d(self) -&gt; bool:\n    \"\"\"Return `True` if the configuration contains 3D view space.\"\"\"\n    return len(self.spatial3ds) &gt; 0\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.ViewerConfig.to_blueprint","title":"<code>to_blueprint()</code>","text":"<p>Return the recording blueprint.</p> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def to_blueprint(self) -&gt; rrb.BlueprintLike:\n    \"\"\"Return the recording blueprint.\"\"\"\n    views = []\n    if self.spatial3ds:\n        views.append(rrb.Horizontal(*self.spatial3ds, column_shares=[3, 1]))\n    if self.spatial2ds:\n        views.append(rrb.Grid(*self.spatial2ds))\n\n    return rrb.Vertical(*views, row_shares=[4, 2])\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.calculate_geodetic_point","title":"<code>calculate_geodetic_point(position, origin)</code>","text":"<p>Transform a position in a map coordinate system to a position in a geodetic coordinate system.</p> <p>Parameters:</p> Name Type Description Default <code>position</code> <code>Vector3Like</code> <p>3D position in a map coordinate system.</p> required <code>origin</code> <code>Vector2Like</code> <p>Map origin position in a geodetic coordinate system, which is (latitude, longitude).</p> required <p>Returns:</p> Type Description <code>Vector2</code> <p>Transformed position in a geodetic coordinate system, which is (latitude, longitude).</p> Source code in <code>t4_devkit/viewer/geography.py</code> <pre><code>def calculate_geodetic_point(position: Vector3Like, origin: Vector2Like) -&gt; Vector2:\n    \"\"\"Transform a position in a map coordinate system to a position in a geodetic coordinate system.\n\n    Args:\n        position (Vector3Like): 3D position in a map coordinate system.\n        origin (Vector2Like): Map origin position in a geodetic coordinate system,\n            which is (latitude, longitude).\n\n    Returns:\n        Transformed position in a geodetic coordinate system, which is (latitude, longitude).\n    \"\"\"\n    x, y, _ = Vector3(position)\n    bearing = math.atan2(x, y)\n    distance = math.hypot(x, y)\n\n    latitude, longitude = np.radians(Vector2(origin))\n    angular_distance = distance / EARTH_RADIUS_METERS\n\n    target_latitude = math.asin(\n        math.sin(latitude) * math.cos(angular_distance)\n        + math.cos(latitude) * math.sin(angular_distance) * math.cos(bearing)\n    )\n    target_longitude = longitude + math.atan2(\n        math.sin(bearing) * math.sin(angular_distance) * math.cos(latitude),\n        math.cos(angular_distance) - math.sin(latitude) * math.sin(target_latitude),\n    )\n\n    return Vector2(math.degrees(target_latitude), math.degrees(target_longitude))\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.format_entity","title":"<code>format_entity(*entities)</code>","text":"<p>Format entity path.</p> <p>Parameters:</p> Name Type Description Default <code>*entities</code> <code>str | EntityPath</code> <p>Entity path(s).</p> <code>()</code> <p>Returns:</p> Type Description <code>str</code> <p>Formatted entity path.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; format_entity(\"map\")\n\"map\"\n&gt;&gt;&gt; format_entity(\"map\", \"map/base_link\")\n\"map/base_link\"\n&gt;&gt;&gt; format_entity(\"map\", \"map/base_link\", \"camera\")\n\"map/base_link/camera\"\n&gt;&gt;&gt; format_entity(EntityPath.BASE_LINK, \"camera\")\n\"map/base_link/camera\"\n</code></pre> Source code in <code>t4_devkit/viewer/config.py</code> <pre><code>def format_entity(*entities: str | EntityPath) -&gt; str:\n    \"\"\"Format entity path.\n\n    Args:\n        *entities (str | EntityPath): Entity path(s).\n\n    Returns:\n        Formatted entity path.\n\n    Examples:\n        &gt;&gt;&gt; format_entity(\"map\")\n        \"map\"\n        &gt;&gt;&gt; format_entity(\"map\", \"map/base_link\")\n        \"map/base_link\"\n        &gt;&gt;&gt; format_entity(\"map\", \"map/base_link\", \"camera\")\n        \"map/base_link/camera\"\n        &gt;&gt;&gt; format_entity(EntityPath.BASE_LINK, \"camera\")\n        \"map/base_link/camera\"\n    \"\"\"\n    if not entities:\n        return \"\"\n\n    flattened = []\n    for entity in entities:\n        for part in entity.split(\"/\"):\n            if part and flattened and flattened[-1] == part:\n                continue\n            flattened.append(part)\n    return \"/\".join(flattened)\n</code></pre>"},{"location":"apis/viewer/#t4_devkit.viewer.pointcloud_color","title":"<code>pointcloud_color(pointcloud, color_mode=PointCloudColorMode.DISTANCE)</code>","text":"<p>Return color map depending on the specified color mode.</p> <p>Parameters:</p> Name Type Description Default <code>pointcloud</code> <code>PointCloudLike</code> <p>Any inheritance of <code>PointCloud</code> class.</p> required <code>color_mode</code> <code>PointCloudColorMode</code> <p>Color mode for pointcloud.</p> <code>DISTANCE</code> Source code in <code>t4_devkit/viewer/color.py</code> <pre><code>def pointcloud_color(\n    pointcloud: PointCloudLike,\n    color_mode: PointCloudColorMode = PointCloudColorMode.DISTANCE,\n) -&gt; NDArrayF64:\n    \"\"\"Return color map depending on the specified color mode.\n\n    Args:\n        pointcloud (PointCloudLike): Any inheritance of `PointCloud` class.\n        color_mode (PointCloudColorMode, optional): Color mode for pointcloud.\n    \"\"\"\n    match color_mode:\n        case PointCloudColorMode.DISTANCE:\n            values = np.linalg.norm(pointcloud.points[:3].T, axis=1)\n        case PointCloudColorMode.INTENSITY:\n            values = pointcloud.points[3]\n        case _:\n            raise ValueError(f\"Unsupported color mode: {color_mode}\")\n\n    return _normalize_color(values)\n</code></pre>"},{"location":"apis/schema/","title":"<code>schema</code>","text":"<ul> <li>Schema Names</li> <li>Schema Tables</li> <li>Other Items for Schema Tables</li> <li>Schema Registry</li> <li>Serialize Schema</li> </ul>"},{"location":"apis/schema/name/","title":"Schema Names","text":"<p>Under the hood, <code>t4-devkit</code> declares an enum called <code>SchemaName</code>. This enum includes names of each schema table that should be contained in the T4 dataset as <code>.json</code> file.</p> <p>Note that some schema tables are not mandatory, such as <code>object_ann.json</code> and <code>surface_ann.json</code>. For these tables, the method called <code>is_optional()</code> returns <code>True</code> and it is OK that these corresponding <code>.json</code> files are not contained in T4 dataset:</p> <pre><code>from t4_devkit.schema import SchemaName\n\n&gt;&gt;&gt; SchemaName.OBJECT_ANN.is_optional()\nTrue\n</code></pre>"},{"location":"apis/schema/name/#t4_devkit.schema.name.SchemaName","title":"<code>SchemaName</code>","text":"<p>An enum to represent schema filenames.</p> <p>Attributes:</p> Name Type Description <code>ATTRIBUTE</code> <p>Property of an instance that can change while the category remains the same.</p> <code>CALIBRATED_SENSOR</code> <p>Definition of a particular sensor as calibrated on a vehicle.</p> <code>CATEGORY</code> <p>Object categories.</p> <code>EGO_POSE</code> <p>Ego vehicle pose at at particular timestamp.</p> <code>INSTANCE</code> <p>An object instance.</p> <code>LOG</code> <p>Information about the log from which the data aws extracted.</p> <code>MAP</code> <p>Map data that is stored as binary semantic masks from a top-down view.</p> <code>SAMPLE</code> <p>A sample is an annotated keyframe at specific Hz.</p> <code>SAMPLE_ANNOTATION</code> <p>A bounding box defining the position of an object seen in a sample.</p> <code>SAMPLE_DATA</code> <p>A sensor data e.g. image, pointcloud or radar return.</p> <code>SCENE</code> <p>A scene is a specific long sequence of consecutive frames extracted from a log.</p> <code>SENSOR</code> <p>A specific sensor type.</p> <code>VISIBILITY</code> <p>The visibility of instance is the fraction of annotation visible in all images.</p> <code>LIDARSEG</code> <code>optional</code> <p>The annotation of 3D point cloud segmentation.</p> <code>OBJECT_ANN</code> <code>optional</code> <p>The annotation of a foreground object in an image.</p> <code>SURFACE_ANN</code> <code>optional</code> <p>The annotation of a background object in an image.</p> <code>KEYPOINT</code> <code>optional</code> <p>The annotation of pose keypoints of an object in an image.</p> <code>VEHICLE_STATE</code> <code>optional</code> <p>The annotation of ego vehicle states.</p> Source code in <code>t4_devkit/schema/name.py</code> <pre><code>@unique\nclass SchemaName(str, Enum):\n    \"\"\"An enum to represent schema filenames.\n\n    Attributes:\n        ATTRIBUTE: Property of an instance that can change while the category remains the same.\n        CALIBRATED_SENSOR: Definition of a particular sensor as calibrated on a vehicle.\n        CATEGORY: Object categories.\n        EGO_POSE: Ego vehicle pose at at particular timestamp.\n        INSTANCE: An object instance.\n        LOG: Information about the log from which the data aws extracted.\n        MAP: Map data that is stored as binary semantic masks from a top-down view.\n        SAMPLE: A sample is an annotated keyframe at specific Hz.\n        SAMPLE_ANNOTATION: A bounding box defining the position of an object seen in a sample.\n        SAMPLE_DATA: A sensor data e.g. image, pointcloud or radar return.\n        SCENE: A scene is a specific long sequence of consecutive frames extracted from a log.\n        SENSOR: A specific sensor type.\n        VISIBILITY: The visibility of instance is the fraction of annotation visible in all images.\n        LIDARSEG (optional): The annotation of 3D point cloud segmentation.\n        OBJECT_ANN (optional): The annotation of a foreground object in an image.\n        SURFACE_ANN (optional): The annotation of a background object in an image.\n        KEYPOINT (optional): The annotation of pose keypoints of an object in an image.\n        VEHICLE_STATE (optional): The annotation of ego vehicle states.\n    \"\"\"\n\n    ATTRIBUTE = \"attribute\"\n    CALIBRATED_SENSOR = \"calibrated_sensor\"\n    CATEGORY = \"category\"\n    EGO_POSE = \"ego_pose\"\n    INSTANCE = \"instance\"\n    LOG = \"log\"\n    MAP = \"map\"\n    SAMPLE = \"sample\"\n    SAMPLE_ANNOTATION = \"sample_annotation\"\n    SAMPLE_DATA = \"sample_data\"\n    VISIBILITY = \"visibility\"\n    SENSOR = \"sensor\"\n    SCENE = \"scene\"\n    LIDARSEG = \"lidarseg\"  # optional\n    OBJECT_ANN = \"object_ann\"  # optional\n    SURFACE_ANN = \"surface_ann\"  # optional\n    KEYPOINT = \"keypoint\"  # optional\n    VEHICLE_STATE = \"vehicle_state\"  # optional\n\n    @property\n    def filename(self) -&gt; str:\n        \"\"\"Return the annotation json filename.\n\n        Returns:\n            Annotation json filename.\n        \"\"\"\n        return f\"{self.value}.json\"\n\n    def is_optional(self) -&gt; bool:\n        \"\"\"Indicates if this schema name is optional.\n\n        Returns:\n            Return True if this schema is optional.\n        \"\"\"\n        return self in (\n            SchemaName.LIDARSEG,\n            SchemaName.OBJECT_ANN,\n            SchemaName.SURFACE_ANN,\n            SchemaName.KEYPOINT,\n            SchemaName.VEHICLE_STATE,\n        )\n</code></pre>"},{"location":"apis/schema/name/#t4_devkit.schema.name.SchemaName.filename","title":"<code>filename</code>  <code>property</code>","text":"<p>Return the annotation json filename.</p> <p>Returns:</p> Type Description <code>str</code> <p>Annotation json filename.</p>"},{"location":"apis/schema/name/#t4_devkit.schema.name.SchemaName.is_optional","title":"<code>is_optional()</code>","text":"<p>Indicates if this schema name is optional.</p> <p>Returns:</p> Type Description <code>bool</code> <p>Return True if this schema is optional.</p> Source code in <code>t4_devkit/schema/name.py</code> <pre><code>def is_optional(self) -&gt; bool:\n    \"\"\"Indicates if this schema name is optional.\n\n    Returns:\n        Return True if this schema is optional.\n    \"\"\"\n    return self in (\n        SchemaName.LIDARSEG,\n        SchemaName.OBJECT_ANN,\n        SchemaName.SURFACE_ANN,\n        SchemaName.KEYPOINT,\n        SchemaName.VEHICLE_STATE,\n    )\n</code></pre>"},{"location":"apis/schema/other/","title":"Other Items for Tables","text":"<p>Following classes are sub items composed of each schema tables.</p>"},{"location":"apis/schema/other/#sampledata","title":"<code>SampleData</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat","title":"<code>FileFormat</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent file formats.</p> <p>Attributes:</p> Name Type Description <code>JPG</code> <p>JPG format for image data.</p> <code>PNG</code> <p>PNG format for image data.</p> <code>PCD</code> <p>PCD format for pointcloud data.</p> <code>BIN</code> <p>BIN format.</p> <code>PCDBIN</code> <p>PCD.BIN format for pointcloud data.</p> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@unique\nclass FileFormat(str, Enum):\n    \"\"\"An enum to represent file formats.\n\n    Attributes:\n        JPG: JPG format for image data.\n        PNG: PNG format for image data.\n        PCD: PCD format for pointcloud data.\n        BIN: BIN format.\n        PCDBIN: PCD.BIN format for pointcloud data.\n    \"\"\"\n\n    JPG = \"jpg\"\n    PNG = \"png\"\n    PCD = \"pcd\"\n    BIN = \"bin\"\n    PCDBIN = \"pcd.bin\"\n\n    @staticmethod\n    def is_member(item: str) -&gt; bool:\n        \"\"\"Indicate whether the input item is the one of members of FileFormat.\n\n        Args:\n            item (str): Any file format name.\n\n        Returns:\n            Return True if the item is included.\n        \"\"\"\n        return item in FileFormat.values()\n\n    @staticmethod\n    def values() -&gt; list[str]:\n        \"\"\"Return a list of values of members.\n\n        Returns:\n            List of values.\n        \"\"\"\n        return [v.value for v in FileFormat]\n\n    def as_ext(self) -&gt; str:\n        \"\"\"Return the value as file extension.\n\n        Returns:\n            File extension.\n        \"\"\"\n        return f\".{self.value}\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat.as_ext","title":"<code>as_ext()</code>","text":"<p>Return the value as file extension.</p> <p>Returns:</p> Type Description <code>str</code> <p>File extension.</p> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>def as_ext(self) -&gt; str:\n    \"\"\"Return the value as file extension.\n\n    Returns:\n        File extension.\n    \"\"\"\n    return f\".{self.value}\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat.is_member","title":"<code>is_member(item)</code>  <code>staticmethod</code>","text":"<p>Indicate whether the input item is the one of members of FileFormat.</p> <p>Parameters:</p> Name Type Description Default <code>item</code> <code>str</code> <p>Any file format name.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>Return True if the item is included.</p> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@staticmethod\ndef is_member(item: str) -&gt; bool:\n    \"\"\"Indicate whether the input item is the one of members of FileFormat.\n\n    Args:\n        item (str): Any file format name.\n\n    Returns:\n        Return True if the item is included.\n    \"\"\"\n    return item in FileFormat.values()\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.FileFormat.values","title":"<code>values()</code>  <code>staticmethod</code>","text":"<p>Return a list of values of members.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of values.</p> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@staticmethod\ndef values() -&gt; list[str]:\n    \"\"\"Return a list of values of members.\n\n    Returns:\n        List of values.\n    \"\"\"\n    return [v.value for v in FileFormat]\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.SensorModality","title":"<code>SensorModality</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent sensor modalities.</p> <p>Attributes:</p> Name Type Description <code>LIDAR</code> <p>Lidar sensor.</p> <code>CAMERA</code> <p>Camera sensor.</p> <code>RADAR</code> <p>Radar sensor.</p> Source code in <code>t4_devkit/schema/tables/sensor.py</code> <pre><code>@unique\nclass SensorModality(str, Enum):\n    \"\"\"An enum to represent sensor modalities.\n\n    Attributes:\n        LIDAR: Lidar sensor.\n        CAMERA: Camera sensor.\n        RADAR: Radar sensor.\n    \"\"\"\n\n    LIDAR = \"lidar\"\n    CAMERA = \"camera\"\n    RADAR = \"radar\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel","title":"<code>VisibilityLevel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent visibility levels.</p> <p>Attributes:</p> Name Type Description <code>FULL</code> <p>No occlusion for the object.</p> <code>MOST</code> <p>Object is occluded, but by less than 50%.</p> <code>PARTIAL</code> <p>Object is occluded, but by more than 50%.</p> <code>NONE</code> <p>Object is 90-100% occluded and no points/pixels are visible in the label.</p> <code>UNAVAILABLE</code> <p>Visibility level is not specified.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@unique\nclass VisibilityLevel(str, Enum):\n    \"\"\"An enum to represent visibility levels.\n\n    Attributes:\n        FULL: No occlusion for the object.\n        MOST: Object is occluded, but by less than 50%.\n        PARTIAL: Object is occluded, but by more than 50%.\n        NONE: Object is 90-100% occluded and no points/pixels are visible in the label.\n        UNAVAILABLE: Visibility level is not specified.\n    \"\"\"\n\n    FULL = \"full\"\n    MOST = \"most\"\n    PARTIAL = \"partial\"\n    NONE = \"none\"\n    UNAVAILABLE = \"unavailable\"\n\n    @classmethod\n    def from_value(cls, level: str) -&gt; Self:\n        \"\"\"Load member from its value.\"\"\"\n        if level not in cls.__members__.values():\n            return cls._from_alias(level)\n        return cls(level)\n\n    @staticmethod\n    def _from_alias(level: str) -&gt; Self:\n        \"\"\"Load member from alias format of level.\n\n        Args:\n            level (str): Level of visibility.\n        \"\"\"\n        if level == \"v0-40\":\n            return VisibilityLevel.NONE\n        elif level == \"v40-60\":\n            return VisibilityLevel.PARTIAL\n        elif level == \"v60-80\":\n            return VisibilityLevel.MOST\n        elif level == \"v80-100\":\n            return VisibilityLevel.FULL\n        else:\n            warnings.warn(\n                f\"level: {level} is not supported, Visibility.UNAVAILABLE will be assigned.\"\n            )\n            return VisibilityLevel.UNAVAILABLE\n\n    def rank(self) -&gt; int:\n        \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n        ranking = {\n            \"full\": 4,\n            \"most\": 3,\n            \"partial\": 2,\n            \"none\": 1,\n            \"unavailable\": None,\n        }\n        return ranking[self.value]\n\n    def is_comparable(self) -&gt; bool:\n        \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n        return self.rank() is not None\n\n    def _check_comparability(self, other: VisibilityLevel) -&gt; None:\n        if not (self.is_comparable() and other.is_comparable()):\n            raise ValueError(f\"Cannot compare unknown visibility levels: {self}, {other}\")\n\n    def __lt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt; other.rank()\n\n    def __le__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt;= other.rank()\n\n    def __gt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt; other.rank()\n\n    def __ge__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt;= other.rank()\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.from_value","title":"<code>from_value(level)</code>  <code>classmethod</code>","text":"<p>Load member from its value.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@classmethod\ndef from_value(cls, level: str) -&gt; Self:\n    \"\"\"Load member from its value.\"\"\"\n    if level not in cls.__members__.values():\n        return cls._from_alias(level)\n    return cls(level)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.is_comparable","title":"<code>is_comparable()</code>","text":"<p>Return True if the visibility level has a defined rank.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def is_comparable(self) -&gt; bool:\n    \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n    return self.rank() is not None\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.rank","title":"<code>rank()</code>","text":"<p>Return an integer rank for comparison (higher is more visible).</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def rank(self) -&gt; int:\n    \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n    ranking = {\n        \"full\": 4,\n        \"most\": 3,\n        \"partial\": 2,\n        \"none\": 1,\n        \"unavailable\": None,\n    }\n    return ranking[self.value]\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask","title":"<code>RLEMask</code>","text":"<p>A dataclass to represent segmentation mask compressed by RLE.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>tuple[int, int]</code> <p>Size of image ordering (width, height).</p> <code>counts</code> <code>str</code> <p>RLE compressed mask data.</p> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>@define\nclass RLEMask:\n    \"\"\"A dataclass to represent segmentation mask compressed by RLE.\n\n    Attributes:\n        size (tuple[int, int]): Size of image ordering (width, height).\n        counts (str): RLE compressed mask data.\n    \"\"\"\n\n    size: tuple[int, int] = field(\n        converter=tuple, validator=validators.deep_iterable(validators.instance_of(int))\n    )\n    counts: str = field(validator=validators.instance_of(str))\n\n    @property\n    def width(self) -&gt; int:\n        return self.size[0]\n\n    @property\n    def height(self) -&gt; int:\n        return self.size[1]\n\n    def decode(self) -&gt; NDArrayU8:\n        \"\"\"Decode segmentation mask.\n\n        Returns:\n            Decoded mask in shape of (H, W).\n        \"\"\"\n        counts = base64.b64decode(self.counts)\n        data = {\"counts\": counts, \"size\": self.size}\n        return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask.decode","title":"<code>decode()</code>","text":"<p>Decode segmentation mask.</p> <p>Returns:</p> Type Description <code>NDArrayU8</code> <p>Decoded mask in shape of (H, W).</p> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>def decode(self) -&gt; NDArrayU8:\n    \"\"\"Decode segmentation mask.\n\n    Returns:\n        Decoded mask in shape of (H, W).\n    \"\"\"\n    counts = base64.b64decode(self.counts)\n    data = {\"counts\": counts, \"size\": self.size}\n    return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.ShiftState","title":"<code>ShiftState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent gear shift state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass ShiftState(str, Enum):\n    \"\"\"An enum to represent gear shift state.\"\"\"\n\n    PARK = \"PARK\"\n    REVERSE = \"REVERSE\"\n    NEUTRAL = \"NEUTRAL\"\n    HIGH = \"HIGH\"\n    FORWARD = \"FORWARD\"\n    LOW = \"LOW\"\n    NONE = \"NONE\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.IndicatorState","title":"<code>IndicatorState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent indicator state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass IndicatorState(str, Enum):\n    \"\"\"An enum to represent indicator state.\"\"\"\n\n    ON = \"on\"\n    OFF = \"off\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.Indicators","title":"<code>Indicators</code>","text":"<p>A dataclass to represent state of each indicator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>IndicatorState</code> <p>State of the left indicator.</p> <code>right</code> <code>IndicatorState</code> <p>State of the right indicator.</p> <code>hazard</code> <code>IndicatorState</code> <p>State of the hazard lights.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass Indicators:\n    \"\"\"A dataclass to represent state of each indicator.\n\n    Attributes:\n        left (IndicatorState): State of the left indicator.\n        right (IndicatorState): State of the right indicator.\n        hazard (IndicatorState): State of the hazard lights.\n    \"\"\"\n\n    left: IndicatorState = field(converter=IndicatorState)\n    right: IndicatorState = field(converter=IndicatorState)\n    hazard: IndicatorState = field(converter=IndicatorState)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AdditionalInfo","title":"<code>AdditionalInfo</code>","text":"<p>A dataclass to represent additional state information of the ego vehicle.</p> <p>Attributes:</p> Name Type Description <code>speed</code> <code>float | None</code> <p>Speed of the ego vehicle.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass AdditionalInfo:\n    \"\"\"A dataclass to represent additional state information of the ego vehicle.\n\n    Attributes:\n        speed (float | None): Speed of the ego vehicle.\n    \"\"\"\n\n    speed: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AutolabelModel","title":"<code>AutolabelModel</code>","text":"<p>A dataclass to represent a model used in autolabeling.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the model used for annotation. Can include version information.</p> <code>score</code> <code>float</code> <p>Label score for the annotation from this model (range: 0.0\u20131.0).</p> <code>uncertainty</code> <code>float | None</code> <p>Model-reported uncertainty for the annotation (range: 0.0\u20131.0). Lower values imply higher confidence.</p> Source code in <code>t4_devkit/schema/tables/autolabel_metadata.py</code> <pre><code>@define\nclass AutolabelModel:\n    \"\"\"A dataclass to represent a model used in autolabeling.\n\n    Attributes:\n        name (str): Name of the model used for annotation. Can include version information.\n        score (float): Label score for the annotation from this model (range: 0.0\u20131.0).\n        uncertainty (float | None, optional): Model-reported uncertainty for the annotation (range: 0.0\u20131.0).\n            Lower values imply higher confidence.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    score: float = field(\n        validator=(validators.instance_of(float), validators.ge(0.0), validators.le(1.0))\n    )\n    uncertainty: float | None = field(\n        default=None,\n        validator=validators.optional(\n            validators.and_(validators.instance_of(float), validators.ge(0.0), validators.le(1.0))\n        ),\n    )\n\n    @staticmethod\n    def to_autolabel_model(x: list[dict | AutolabelModel] | None) -&gt; list[AutolabelModel] | None:\n        \"\"\"Convert input to a list of AutolabelModel instances.\n\n        Args:\n            x (list[dict | AutolabelModel] | None): Input to convert. Can be None, a list of dicts, or a list of AutolabelModel instances.\n\n        Returns:\n            list[AutolabelModel] | None: Converted list of AutolabelModel instances or None.\n        \"\"\"\n        if x is None:\n            return None\n        if isinstance(x, list):\n            return [AutolabelModel(**model) if isinstance(model, dict) else model for model in x]\n        raise TypeError(\"Input must be None or a list of [dicts or AutolabelModel] instances.\")\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AutolabelModel.to_autolabel_model","title":"<code>to_autolabel_model(x)</code>  <code>staticmethod</code>","text":"<p>Convert input to a list of AutolabelModel instances.</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>list[dict | AutolabelModel] | None</code> <p>Input to convert. Can be None, a list of dicts, or a list of AutolabelModel instances.</p> required <p>Returns:</p> Type Description <code>list[AutolabelModel] | None</code> <p>list[AutolabelModel] | None: Converted list of AutolabelModel instances or None.</p> Source code in <code>t4_devkit/schema/tables/autolabel_metadata.py</code> <pre><code>@staticmethod\ndef to_autolabel_model(x: list[dict | AutolabelModel] | None) -&gt; list[AutolabelModel] | None:\n    \"\"\"Convert input to a list of AutolabelModel instances.\n\n    Args:\n        x (list[dict | AutolabelModel] | None): Input to convert. Can be None, a list of dicts, or a list of AutolabelModel instances.\n\n    Returns:\n        list[AutolabelModel] | None: Converted list of AutolabelModel instances or None.\n    \"\"\"\n    if x is None:\n        return None\n    if isinstance(x, list):\n        return [AutolabelModel(**model) if isinstance(model, dict) else model for model in x]\n    raise TypeError(\"Input must be None or a list of [dicts or AutolabelModel] instances.\")\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AutolabelMixin","title":"<code>AutolabelMixin</code>","text":"<p>Mixin class for schema tables that use autolabel metadata with automatic annotation.</p> Source code in <code>t4_devkit/schema/tables/autolabel_metadata.py</code> <pre><code>@define(slots=False)\nclass AutolabelMixin:\n    \"\"\"Mixin class for schema tables that use autolabel metadata with automatic annotation.\"\"\"\n\n    automatic_annotation: bool = field(\n        default=False, validator=validators.instance_of(bool), kw_only=True\n    )\n    autolabel_metadata: list[AutolabelModel] | None = field(\n        default=None,\n        converter=AutolabelModel.to_autolabel_model,\n        validator=validators.optional(\n            validators.deep_iterable(validators.instance_of(AutolabelModel))\n        ),\n        kw_only=True,\n    )\n\n    def __attrs_post_init__(self) -&gt; None:\n        \"\"\"Post-initialization validation for autolabel consistency.\"\"\"\n        # if automatic_annotation=True, autolabel_metadata must exist\n        if self.automatic_annotation and self.autolabel_metadata is None:\n            raise TypeError(\"autolabel_metadata must be provided when automatic_annotation is True\")\n        # if automatic_annotation=False, autolabel_metadata must not exist\n        if not self.automatic_annotation and self.autolabel_metadata is not None:\n            raise TypeError(\"autolabel_metadata must be None when automatic_annotation is False\")\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AutolabelMixin.__attrs_post_init__","title":"<code>__attrs_post_init__()</code>","text":"<p>Post-initialization validation for autolabel consistency.</p> Source code in <code>t4_devkit/schema/tables/autolabel_metadata.py</code> <pre><code>def __attrs_post_init__(self) -&gt; None:\n    \"\"\"Post-initialization validation for autolabel consistency.\"\"\"\n    # if automatic_annotation=True, autolabel_metadata must exist\n    if self.automatic_annotation and self.autolabel_metadata is None:\n        raise TypeError(\"autolabel_metadata must be provided when automatic_annotation is True\")\n    # if automatic_annotation=False, autolabel_metadata must not exist\n    if not self.automatic_annotation and self.autolabel_metadata is not None:\n        raise TypeError(\"autolabel_metadata must be None when automatic_annotation is False\")\n</code></pre>"},{"location":"apis/schema/other/#sensor","title":"<code>Sensor</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.SensorModality","title":"<code>SensorModality</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent sensor modalities.</p> <p>Attributes:</p> Name Type Description <code>LIDAR</code> <p>Lidar sensor.</p> <code>CAMERA</code> <p>Camera sensor.</p> <code>RADAR</code> <p>Radar sensor.</p> Source code in <code>t4_devkit/schema/tables/sensor.py</code> <pre><code>@unique\nclass SensorModality(str, Enum):\n    \"\"\"An enum to represent sensor modalities.\n\n    Attributes:\n        LIDAR: Lidar sensor.\n        CAMERA: Camera sensor.\n        RADAR: Radar sensor.\n    \"\"\"\n\n    LIDAR = \"lidar\"\n    CAMERA = \"camera\"\n    RADAR = \"radar\"\n</code></pre>"},{"location":"apis/schema/other/#objectannsurfaceann","title":"<code>ObjectAnn</code>/<code>SurfaceAnn</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask","title":"<code>RLEMask</code>","text":"<p>A dataclass to represent segmentation mask compressed by RLE.</p> <p>Attributes:</p> Name Type Description <code>size</code> <code>tuple[int, int]</code> <p>Size of image ordering (width, height).</p> <code>counts</code> <code>str</code> <p>RLE compressed mask data.</p> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>@define\nclass RLEMask:\n    \"\"\"A dataclass to represent segmentation mask compressed by RLE.\n\n    Attributes:\n        size (tuple[int, int]): Size of image ordering (width, height).\n        counts (str): RLE compressed mask data.\n    \"\"\"\n\n    size: tuple[int, int] = field(\n        converter=tuple, validator=validators.deep_iterable(validators.instance_of(int))\n    )\n    counts: str = field(validator=validators.instance_of(str))\n\n    @property\n    def width(self) -&gt; int:\n        return self.size[0]\n\n    @property\n    def height(self) -&gt; int:\n        return self.size[1]\n\n    def decode(self) -&gt; NDArrayU8:\n        \"\"\"Decode segmentation mask.\n\n        Returns:\n            Decoded mask in shape of (H, W).\n        \"\"\"\n        counts = base64.b64decode(self.counts)\n        data = {\"counts\": counts, \"size\": self.size}\n        return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.RLEMask.decode","title":"<code>decode()</code>","text":"<p>Decode segmentation mask.</p> <p>Returns:</p> Type Description <code>NDArrayU8</code> <p>Decoded mask in shape of (H, W).</p> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>def decode(self) -&gt; NDArrayU8:\n    \"\"\"Decode segmentation mask.\n\n    Returns:\n        Decoded mask in shape of (H, W).\n    \"\"\"\n    counts = base64.b64decode(self.counts)\n    data = {\"counts\": counts, \"size\": self.size}\n    return cocomask.decode(data)\n</code></pre>"},{"location":"apis/schema/other/#visibility","title":"<code>Visibility</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel","title":"<code>VisibilityLevel</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent visibility levels.</p> <p>Attributes:</p> Name Type Description <code>FULL</code> <p>No occlusion for the object.</p> <code>MOST</code> <p>Object is occluded, but by less than 50%.</p> <code>PARTIAL</code> <p>Object is occluded, but by more than 50%.</p> <code>NONE</code> <p>Object is 90-100% occluded and no points/pixels are visible in the label.</p> <code>UNAVAILABLE</code> <p>Visibility level is not specified.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@unique\nclass VisibilityLevel(str, Enum):\n    \"\"\"An enum to represent visibility levels.\n\n    Attributes:\n        FULL: No occlusion for the object.\n        MOST: Object is occluded, but by less than 50%.\n        PARTIAL: Object is occluded, but by more than 50%.\n        NONE: Object is 90-100% occluded and no points/pixels are visible in the label.\n        UNAVAILABLE: Visibility level is not specified.\n    \"\"\"\n\n    FULL = \"full\"\n    MOST = \"most\"\n    PARTIAL = \"partial\"\n    NONE = \"none\"\n    UNAVAILABLE = \"unavailable\"\n\n    @classmethod\n    def from_value(cls, level: str) -&gt; Self:\n        \"\"\"Load member from its value.\"\"\"\n        if level not in cls.__members__.values():\n            return cls._from_alias(level)\n        return cls(level)\n\n    @staticmethod\n    def _from_alias(level: str) -&gt; Self:\n        \"\"\"Load member from alias format of level.\n\n        Args:\n            level (str): Level of visibility.\n        \"\"\"\n        if level == \"v0-40\":\n            return VisibilityLevel.NONE\n        elif level == \"v40-60\":\n            return VisibilityLevel.PARTIAL\n        elif level == \"v60-80\":\n            return VisibilityLevel.MOST\n        elif level == \"v80-100\":\n            return VisibilityLevel.FULL\n        else:\n            warnings.warn(\n                f\"level: {level} is not supported, Visibility.UNAVAILABLE will be assigned.\"\n            )\n            return VisibilityLevel.UNAVAILABLE\n\n    def rank(self) -&gt; int:\n        \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n        ranking = {\n            \"full\": 4,\n            \"most\": 3,\n            \"partial\": 2,\n            \"none\": 1,\n            \"unavailable\": None,\n        }\n        return ranking[self.value]\n\n    def is_comparable(self) -&gt; bool:\n        \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n        return self.rank() is not None\n\n    def _check_comparability(self, other: VisibilityLevel) -&gt; None:\n        if not (self.is_comparable() and other.is_comparable()):\n            raise ValueError(f\"Cannot compare unknown visibility levels: {self}, {other}\")\n\n    def __lt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt; other.rank()\n\n    def __le__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &lt;= other.rank()\n\n    def __gt__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt; other.rank()\n\n    def __ge__(self, other: VisibilityLevel) -&gt; bool:\n        self._check_comparability(other)\n        return self.rank() &gt;= other.rank()\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.from_value","title":"<code>from_value(level)</code>  <code>classmethod</code>","text":"<p>Load member from its value.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@classmethod\ndef from_value(cls, level: str) -&gt; Self:\n    \"\"\"Load member from its value.\"\"\"\n    if level not in cls.__members__.values():\n        return cls._from_alias(level)\n    return cls(level)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.is_comparable","title":"<code>is_comparable()</code>","text":"<p>Return True if the visibility level has a defined rank.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def is_comparable(self) -&gt; bool:\n    \"\"\"Return True if the visibility level has a defined rank.\"\"\"\n    return self.rank() is not None\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.VisibilityLevel.rank","title":"<code>rank()</code>","text":"<p>Return an integer rank for comparison (higher is more visible).</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>def rank(self) -&gt; int:\n    \"\"\"Return an integer rank for comparison (higher is more visible).\"\"\"\n    ranking = {\n        \"full\": 4,\n        \"most\": 3,\n        \"partial\": 2,\n        \"none\": 1,\n        \"unavailable\": None,\n    }\n    return ranking[self.value]\n</code></pre>"},{"location":"apis/schema/other/#vehiclestate","title":"<code>VehicleState</code>","text":""},{"location":"apis/schema/other/#t4_devkit.schema.tables.ShiftState","title":"<code>ShiftState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent gear shift state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass ShiftState(str, Enum):\n    \"\"\"An enum to represent gear shift state.\"\"\"\n\n    PARK = \"PARK\"\n    REVERSE = \"REVERSE\"\n    NEUTRAL = \"NEUTRAL\"\n    HIGH = \"HIGH\"\n    FORWARD = \"FORWARD\"\n    LOW = \"LOW\"\n    NONE = \"NONE\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.IndicatorState","title":"<code>IndicatorState</code>","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enum to represent indicator state.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@unique\nclass IndicatorState(str, Enum):\n    \"\"\"An enum to represent indicator state.\"\"\"\n\n    ON = \"on\"\n    OFF = \"off\"\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.Indicators","title":"<code>Indicators</code>","text":"<p>A dataclass to represent state of each indicator.</p> <p>Attributes:</p> Name Type Description <code>left</code> <code>IndicatorState</code> <p>State of the left indicator.</p> <code>right</code> <code>IndicatorState</code> <p>State of the right indicator.</p> <code>hazard</code> <code>IndicatorState</code> <p>State of the hazard lights.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass Indicators:\n    \"\"\"A dataclass to represent state of each indicator.\n\n    Attributes:\n        left (IndicatorState): State of the left indicator.\n        right (IndicatorState): State of the right indicator.\n        hazard (IndicatorState): State of the hazard lights.\n    \"\"\"\n\n    left: IndicatorState = field(converter=IndicatorState)\n    right: IndicatorState = field(converter=IndicatorState)\n    hazard: IndicatorState = field(converter=IndicatorState)\n</code></pre>"},{"location":"apis/schema/other/#t4_devkit.schema.tables.AdditionalInfo","title":"<code>AdditionalInfo</code>","text":"<p>A dataclass to represent additional state information of the ego vehicle.</p> <p>Attributes:</p> Name Type Description <code>speed</code> <code>float | None</code> <p>Speed of the ego vehicle.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define\nclass AdditionalInfo:\n    \"\"\"A dataclass to represent additional state information of the ego vehicle.\n\n    Attributes:\n        speed (float | None): Speed of the ego vehicle.\n    \"\"\"\n\n    speed: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n</code></pre>"},{"location":"apis/schema/registry/","title":"Schema Registry","text":"<p>Each schema table is registered in <code>SchemaRegistry</code> dynamically at the runtime.</p>"},{"location":"apis/schema/registry/#t4_devkit.schema.builder.build_schema","title":"<code>build_schema(name, filepath)</code>","text":"<p>Build schema dataclass from json file path.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | SchemaName</code> <p>Name of schema table.</p> required <code>filepath</code> <code>str</code> <p>Path to json file.</p> required <p>Returns:</p> Type Description <code>list[SchemaTable]</code> <p>List of schema dataclasses.</p> Source code in <code>t4_devkit/schema/builder.py</code> <pre><code>def build_schema(name: str | SchemaName, filepath: str) -&gt; list[SchemaTable]:\n    \"\"\"Build schema dataclass from json file path.\n\n    Args:\n        name (str | SchemaName): Name of schema table.\n        filepath (str): Path to json file.\n\n    Returns:\n        List of schema dataclasses.\n    \"\"\"\n    return SCHEMAS.build_from_json(name, filepath)\n</code></pre>"},{"location":"apis/schema/registry/#t4_devkit.schema.tables.registry.SCHEMAS","title":"<code>SCHEMAS = SchemaRegistry()</code>  <code>module-attribute</code>","text":""},{"location":"apis/schema/registry/#t4_devkit.schema.tables.registry.SchemaRegistry","title":"<code>SchemaRegistry</code>","text":"<p>A manager class to register schema tables.</p> Source code in <code>t4_devkit/schema/tables/registry.py</code> <pre><code>class SchemaRegistry:\n    \"\"\"A manager class to register schema tables.\"\"\"\n\n    def __init__(self) -&gt; None:\n        self.__schemas: dict[str, SchemaTable] = {}\n\n    @property\n    def schemas(self) -&gt; dict[str, SchemaTable]:\n        return self.__schemas\n\n    def __len__(self) -&gt; int:\n        return len(self.__schemas)\n\n    def __contains__(self, key: str | SchemaName) -&gt; bool:\n        if isinstance(key, SchemaName):\n            key = key.value\n\n        return key in self.keys()\n\n    def get(self, key: str | SchemaName) -&gt; SchemaTable:\n        if isinstance(key, SchemaName):\n            key = key.value\n\n        if key not in self.__schemas:\n            raise KeyError(f\"{key} has not registered yet.\")\n        return self.__schemas[key]\n\n    def keys(self) -&gt; KeysView[str]:\n        return self.__schemas.keys()\n\n    def register(self, name: SchemaName, *, force: bool = False) -&gt; Callable:\n        if not isinstance(name, SchemaName):\n            raise TypeError(f\"name must be SchemaName, but got {type(name)}.\")\n\n        def _register_decorator(obj: object) -&gt; object:\n            self._add_module(obj, name=name, force=force)\n            return obj\n\n        return _register_decorator\n\n    def _add_module(self, module: object, name: SchemaName, *, force: bool = False) -&gt; None:\n        if not inspect.isclass(module):\n            raise TypeError(f\"module must be a class, but got {type(module)}.\")\n\n        if not force and name in self:\n            raise KeyError(f\"{name.value} has already been registered.\")\n\n        self.__schemas[name.value] = module\n\n    def build_from_json(self, key: str | SchemaName, filepath: str) -&gt; list[SchemaTable]:\n        \"\"\"Build schema dataclass from json.\n\n        Args:\n            key (str): Name of schema field.\n            filepath (str): Path to schema json file.\n\n        Returns:\n            Instantiated dataclass.\n        \"\"\"\n        if isinstance(key, SchemaName):\n            key = key.value\n\n        schema: SchemaTable = self.get(key)\n        return schema.from_json(filepath)\n</code></pre>"},{"location":"apis/schema/registry/#t4_devkit.schema.tables.registry.SchemaRegistry.build_from_json","title":"<code>build_from_json(key, filepath)</code>","text":"<p>Build schema dataclass from json.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>Name of schema field.</p> required <code>filepath</code> <code>str</code> <p>Path to schema json file.</p> required <p>Returns:</p> Type Description <code>list[SchemaTable]</code> <p>Instantiated dataclass.</p> Source code in <code>t4_devkit/schema/tables/registry.py</code> <pre><code>def build_from_json(self, key: str | SchemaName, filepath: str) -&gt; list[SchemaTable]:\n    \"\"\"Build schema dataclass from json.\n\n    Args:\n        key (str): Name of schema field.\n        filepath (str): Path to schema json file.\n\n    Returns:\n        Instantiated dataclass.\n    \"\"\"\n    if isinstance(key, SchemaName):\n        key = key.value\n\n    schema: SchemaTable = self.get(key)\n    return schema.from_json(filepath)\n</code></pre>"},{"location":"apis/schema/serialize/","title":"Serialize Schema","text":"<p>You can serialize each schema table into <code>dict</code> using following functions.</p>"},{"location":"apis/schema/serialize/#t4_devkit.schema.serialize.serialize_schema","title":"<code>serialize_schema(data)</code>","text":"<p>Serialize a schema dataclass into dict.</p> Deprecated <p>This function is deprecated. Please use <code>serialize_dataclass()</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>SchemaTable</code> <p>Schema dataclass.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>Serialized dict data.</p> Source code in <code>t4_devkit/schema/serialize.py</code> <pre><code>@deprecated(\"`serialize_schema()` is deprecated. Please use `serialize_dataclass()` instead.\")\ndef serialize_schema(data: SchemaTable) -&gt; dict:\n    \"\"\"Serialize a schema dataclass into dict.\n\n    Deprecated:\n        This function is deprecated. Please use `serialize_dataclass()` instead.\n\n    Args:\n        data (SchemaTable): Schema dataclass.\n\n    Returns:\n        Serialized dict data.\n    \"\"\"\n    return serialize_dataclass(data)\n</code></pre>"},{"location":"apis/schema/serialize/#t4_devkit.schema.serialize.serialize_schemas","title":"<code>serialize_schemas(data)</code>","text":"<p>Serialize a list of schema dataclasses into list of dict.</p> Deprecated <p>This function is deprecated. Please use <code>serialize_dataclasses()</code> instead.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>list[SchemaTable]</code> <p>List of schema dataclasses.</p> required <p>Returns:</p> Type Description <code>list[dict]</code> <p>Serialized list of dict data.</p> Source code in <code>t4_devkit/schema/serialize.py</code> <pre><code>@deprecated(\"`serialize_schemas()` is deprecated. Please use `serialize_dataclasses()` instead.\")\ndef serialize_schemas(data: list[SchemaTable]) -&gt; list[dict]:\n    \"\"\"Serialize a list of schema dataclasses into list of dict.\n\n    Deprecated:\n        This function is deprecated. Please use `serialize_dataclasses()` instead.\n\n    Args:\n        data (list[SchemaTable]): List of schema dataclasses.\n\n    Returns:\n        Serialized list of dict data.\n    \"\"\"\n    return serialize_dataclasses(data)\n</code></pre>"},{"location":"apis/schema/table/","title":"Schema Tables","text":""},{"location":"apis/schema/table/#t4_devkit.schema.tables.Attribute","title":"<code>Attribute</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>attribute.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>name</code> <code>str</code> <p>Attribute name.</p> <code>description</code> <code>str</code> <p>Attribute description.</p> Source code in <code>t4_devkit/schema/tables/attribute.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.ATTRIBUTE)\nclass Attribute(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `attribute.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        name (str): Attribute name.\n        description (str): Attribute description.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    description: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.CalibratedSensor","title":"<code>CalibratedSensor</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>calibrated_sensor.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>sensor_token</code> <code>str</code> <p>Foreign key pointing to the sensor type.</p> <code>translation</code> <code>Vector3</code> <p>Coordinates system origin given as [x, y, z] in [m].</p> <code>rotation</code> <code>Quaternion</code> <p>Coordinates system orientation given as quaternion [w, x, y, z].</p> <code>camera_intrinsic</code> <code>CameraIntrinsic</code> <p>3x3 camera intrinsic matrix. Empty for sensors that are not cameras.</p> <code>camera_distortion</code> <code>CameraDistortion</code> <p>Camera distortion array. Empty for sensors that are not cameras.</p> Source code in <code>t4_devkit/schema/tables/calibrated_sensor.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.CALIBRATED_SENSOR)\nclass CalibratedSensor(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `calibrated_sensor.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sensor_token (str): Foreign key pointing to the sensor type.\n        translation (Vector3): Coordinates system origin given as [x, y, z] in [m].\n        rotation (Quaternion): Coordinates system orientation given as quaternion [w, x, y, z].\n        camera_intrinsic (CameraIntrinsic): 3x3 camera intrinsic matrix. Empty for sensors that are not cameras.\n        camera_distortion (CameraDistortion): Camera distortion array. Empty for sensors that are not cameras.\n    \"\"\"\n\n    sensor_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    translation: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    camera_intrinsic: CameraIntrinsic = field(converter=CameraIntrinsic)\n    camera_distortion: CameraDistortion = field(converter=CameraDistortion)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Category","title":"<code>Category</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>category.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>name</code> <code>str</code> <p>Category name.</p> <code>description</code> <code>str</code> <p>Category description.</p> <code>index</code> <code>int | None</code> <p>Category index for lidar segmentation.</p> <code>has_orientation</code> <code>bool | None</code> <p>Indicates whether annotations for this category may include an <code>orientation</code> field (e.g., traffic light arrows). If omitted, it is treated as <code>false</code>.</p> <code>has_number</code> <code>bool | None</code> <p>Indicates whether annotations for this category may include a <code>number</code> field (e.g., numeric traffic lights). If omitted, it is treated as <code>false</code>.</p> Source code in <code>t4_devkit/schema/tables/category.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.CATEGORY)\nclass Category(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `category.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        name (str): Category name.\n        description (str): Category description.\n        index (int | None, optional): Category index for lidar segmentation.\n        has_orientation (bool | None, optional): Indicates whether annotations for this category may include an `orientation` field (e.g., traffic light arrows). If omitted, it is treated as `false`.\n        has_number (bool | None, optional): Indicates whether annotations for this category may include a `number` field (e.g., numeric traffic lights). If omitted, it is treated as `false`.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    description: str = field(validator=validators.instance_of(str))\n    index: int | None = field(\n        default=None, validator=validators.optional(validators.instance_of(int))\n    )\n    has_orientation: bool = field(default=False, validator=validators.instance_of(bool))\n    has_number: bool = field(default=False, validator=validators.instance_of(bool))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.EgoPose","title":"<code>EgoPose</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>ego_pose.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>translation</code> <code>Vector3</code> <p>Coordinate system origin given as [x, y, z] in [m].</p> <code>rotation</code> <code>Quaternion</code> <p>Coordinate system orientation given as quaternion [w, x, y, z].</p> <code>timestamp</code> <code>int</code> <p>Unix time stamp.</p> <code>twist</code> <code>Vector6 | None</code> <p>Linear and angular velocities in the local coordinate system of the ego vehicle (in m/s for linear and rad/s for angular), in the order of (vx, vy, vz, yaw_rate, pitch_rate, roll_rate).</p> <code>acceleration</code> <code>Vector3 | None</code> <p>Acceleration in the local coordinate system of the ego vehicle (in m/s2), in the order of (ax, ay, az).</p> <code>geocoordinate</code> <code>Vector3 | None</code> <p>Coordinates in the WGS 84 reference ellipsoid (latitude, longitude, altitude) in degrees and meters.</p> Source code in <code>t4_devkit/schema/tables/ego_pose.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.EGO_POSE)\nclass EgoPose(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `ego_pose.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        translation (Vector3): Coordinate system origin given as [x, y, z] in [m].\n        rotation (Quaternion): Coordinate system orientation given as quaternion [w, x, y, z].\n        timestamp (int): Unix time stamp.\n        twist (Vector6 | None): Linear and angular velocities in the local coordinate system of\n            the ego vehicle (in m/s for linear and rad/s for angular), in the order of\n            (vx, vy, vz, yaw_rate, pitch_rate, roll_rate).\n        acceleration (Vector3 | None): Acceleration in the local coordinate system of\n            the ego vehicle (in m/s2), in the order of (ax, ay, az).\n        geocoordinate (Vector3 | None): Coordinates in the WGS 84 reference ellipsoid\n            (latitude, longitude, altitude) in degrees and meters.\n    \"\"\"\n\n    translation: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    timestamp: int = field(validator=validators.instance_of(int))\n    twist: Vector6 | None = field(default=None, converter=converters.optional(Vector6))\n    acceleration: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n    geocoordinate: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Instance","title":"<code>Instance</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>instance.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>category_token</code> <code>str</code> <p>Foreign key pointing to the object category.</p> <code>instance_name</code> <code>str</code> <p>Dataset name and instance ID defined in annotation tool.</p> <code>nbr_annotations</code> <code>int</code> <p>Number of annotations of this instance.</p> <code>first_annotation_token</code> <code>str</code> <p>Foreign key pointing to the first annotation of this instance. Empty if the dataset only contains 2D annotations.</p> <code>last_annotation_token</code> <code>str</code> <p>Foreign key pointing to the last annotation of this instance. Empty if the dataset only contains 2D annotations.</p> Source code in <code>t4_devkit/schema/tables/instance.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.INSTANCE)\nclass Instance(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `instance.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        category_token (str): Foreign key pointing to the object category.\n        instance_name (str): Dataset name and instance ID defined in annotation tool.\n        nbr_annotations (int): Number of annotations of this instance.\n        first_annotation_token (str): Foreign key pointing to the first annotation of this instance.\n            Empty if the dataset only contains 2D annotations.\n        last_annotation_token (str): Foreign key pointing to the last annotation of this instance.\n            Empty if the dataset only contains 2D annotations.\n    \"\"\"\n\n    category_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    instance_name: str = field(validator=validators.instance_of(str))\n    nbr_annotations: int = field(validator=validators.instance_of(int))\n    first_annotation_token: str = field(validator=validators.instance_of(str))\n    last_annotation_token: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Keypoint","title":"<code>Keypoint</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>keypoint.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>sample_data_token</code> <code>str</code> <p>Foreign key pointing to the sample data, which must be a keyframe image.</p> <code>instance_token</code> <code>str</code> <p>Foreign key pointing to the instance.</p> <code>category_tokens</code> <code>list[str]</code> <p>Foreign key pointing to keypoints categories.</p> <code>keypoints</code> <code>KeypointLike</code> <p>Annotated keypoints. Given as a list of [x, y].</p> <code>num_keypoints</code> <code>int</code> <p>The number of keypoints to be annotated.</p> Source code in <code>t4_devkit/schema/tables/keypoint.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.KEYPOINT)\nclass Keypoint(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `keypoint.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_data_token (str): Foreign key pointing to the sample data, which must be a keyframe image.\n        instance_token (str): Foreign key pointing to the instance.\n        category_tokens (list[str]): Foreign key pointing to keypoints categories.\n        keypoints (KeypointLike): Annotated keypoints. Given as a list of [x, y].\n        num_keypoints (int): The number of keypoints to be annotated.\n    \"\"\"\n\n    sample_data_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    instance_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    category_tokens: list[str] = field(\n        validator=validators.deep_iterable((validators.instance_of(str), impossible_empty()))\n    )\n    keypoints: KeypointLike = field(converter=np.array)\n    num_keypoints: int = field(validator=validators.instance_of(int))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.LidarSeg","title":"<code>LidarSeg</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent lidar point cloud segmentation data.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>filename</code> <code>str</code> <p>The filename of the lidar point cloud segmentation data.</p> <code>sample_data_token</code> <code>str</code> <p>The token of the sample data.</p> Source code in <code>t4_devkit/schema/tables/lidarseg.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.LIDARSEG)\nclass LidarSeg(SchemaBase):\n    \"\"\"A dataclass to represent lidar point cloud segmentation data.\n\n    Attributes:\n        token (str): Unique record identifier.\n        filename (str): The filename of the lidar point cloud segmentation data.\n        sample_data_token (str): The token of the sample data.\n    \"\"\"\n\n    filename: str = field(validator=validators.instance_of(str))\n    sample_data_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Log","title":"<code>Log</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>log.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>logfile</code> <code>str</code> <p>Log file name.</p> <code>vehicle</code> <code>str</code> <p>Vehicle name.</p> <code>data_captured</code> <code>str</code> <p>Date of the data was captured (YYYY-MM-DD-HH-mm-ss).</p> <code>location</code> <code>str</code> <p>Area where log was captured.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Log--shortcuts","title":"Shortcuts:","text":"<pre><code>map_token (str): Foreign key pointing to the map record.\n    This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/log.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.LOG)\nclass Log(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `log.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        logfile (str): Log file name.\n        vehicle (str): Vehicle name.\n        data_captured (str): Date of the data was captured (YYYY-MM-DD-HH-mm-ss).\n        location (str): Area where log was captured.\n\n    Shortcuts:\n    ---------\n        map_token (str): Foreign key pointing to the map record.\n            This should be set after instantiated.\n    \"\"\"\n\n    logfile: str = field(validator=validators.instance_of(str))\n    vehicle: str = field(validator=validators.instance_of(str))\n    data_captured: str = field(validator=validators.instance_of(str))\n    location: str = field(validator=validators.instance_of(str))\n\n    # shortcuts\n    map_token: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Map","title":"<code>Map</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>map.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>log_tokens</code> <code>str</code> <p>Foreign keys pointing the log tokens.</p> <code>category</code> <code>str</code> <p>Map category.</p> <code>filename</code> <code>str</code> <p>Relative path to the file with the map mask.</p> Source code in <code>t4_devkit/schema/tables/map.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.MAP)\nclass Map(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `map.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        log_tokens (str): Foreign keys pointing the log tokens.\n        category (str): Map category.\n        filename (str): Relative path to the file with the map mask.\n    \"\"\"\n\n    log_tokens: list[str] = field(\n        validator=validators.deep_iterable((validators.instance_of(str), impossible_empty()))\n    )\n    category: str = field(validator=validators.instance_of(str))\n    filename: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.ObjectAnn","title":"<code>ObjectAnn</code>","text":"<p>               Bases: <code>SchemaBase</code>, <code>AutolabelMixin</code></p> <p>A dataclass to represent schema table of <code>object_ann.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>sample_data_token</code> <code>str</code> <p>Foreign key pointing to the sample data, which must be a keyframe image.</p> <code>instance_token</code> <code>str</code> <p>Foreign key pointing to the instance.</p> <code>category_token</code> <code>str</code> <p>Foreign key pointing to the object category.</p> <code>attribute_tokens</code> <code>list[str]</code> <p>Foreign keys. List of attributes for this annotation.</p> <code>bbox</code> <code>Roi</code> <p>Annotated bounding box. Given as [xmin, ymin, xmax, ymax].</p> <code>mask</code> <code>RLEMask</code> <p>Instance mask using the COCO format compressed by RLE.</p> <code>orientation</code> <code>float | None</code> <p>Orientation of the arrow shape within the bounding box, in radians. Present only for categories where <code>has_orientation</code> is true (e.g., traffic light arrows).</p> <code>number</code> <code>int | None</code> <p>The digit displayed within the bounding box. Present only for categories where <code>has_number</code> is true (e.g., numeric traffic lights).</p> Inherited from AutolabelMixin <p>automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.     If any part is manually modified or annotated by human this value is False. autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if <code>automatic_annotation</code> is <code>true</code>.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.ObjectAnn--shortcuts","title":"Shortcuts:","text":"<pre><code>category_name (str): Category name. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/object_ann.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.OBJECT_ANN)\nclass ObjectAnn(SchemaBase, AutolabelMixin):\n    \"\"\"A dataclass to represent schema table of `object_ann.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_data_token (str): Foreign key pointing to the sample data, which must be a keyframe image.\n        instance_token (str): Foreign key pointing to the instance.\n        category_token (str): Foreign key pointing to the object category.\n        attribute_tokens (list[str]): Foreign keys. List of attributes for this annotation.\n        bbox (Roi): Annotated bounding box. Given as [xmin, ymin, xmax, ymax].\n        mask (RLEMask): Instance mask using the COCO format compressed by RLE.\n        orientation (float | None, optional): Orientation of the arrow shape within the bounding box, in radians. Present only for categories where `has_orientation` is true (e.g., traffic light arrows).\n        number (int | None, optional): The digit displayed within the bounding box. Present only for categories where `has_number` is true (e.g., numeric traffic lights).\n\n    Inherited from AutolabelMixin:\n        automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.\n            If any part is manually modified or annotated by human this value is False.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n\n    Shortcuts:\n    ---------\n        category_name (str): Category name. This should be set after instantiated.\n    \"\"\"\n\n    sample_data_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    instance_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    category_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    attribute_tokens: list[str] = field(\n        validator=validators.deep_iterable((validators.instance_of(str), impossible_empty()))\n    )\n    bbox: Roi = field(converter=Roi)\n    mask: RLEMask | None = field(\n        default=None,\n        converter=lambda x: RLEMask(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(RLEMask)),\n    )\n    orientation: float | None = field(\n        default=None, validator=validators.optional(validators.instance_of(float))\n    )\n    number: int | None = field(\n        default=None, validator=validators.optional(validators.instance_of(int))\n    )\n\n    # shortcuts\n    category_name: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sample","title":"<code>Sample</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>sample.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>timestamp</code> <code>int</code> <p>Unix time stamp.</p> <code>scene_token</code> <code>str</code> <p>Foreign key pointing to the scene.</p> <code>next</code> <code>str</code> <p>Foreign key pointing the sample that follows this in time. Empty if end of scene.</p> <code>prev</code> <code>str</code> <p>Foreign key pointing the sample that precedes this in time. Empty if start of scene.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sample--shortcuts","title":"Shortcuts:","text":"<pre><code>data (dict[str, str]): Sensor channel and its token.\n    This should be set after instantiated.\nann_3ds (list[str]): List of foreign keys pointing the sample annotations.\n    This should be set after instantiated.\nann_2ds (list[str]): List of foreign keys pointing the object annotations.\n    This should be set after instantiated.\nsurface_anns (list[str]): List of foreign keys pointing the surface annotations.\n    This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sample.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SAMPLE)\nclass Sample(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `sample.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        timestamp (int): Unix time stamp.\n        scene_token (str): Foreign key pointing to the scene.\n        next (str): Foreign key pointing the sample that follows this in time. Empty if end of scene.\n        prev (str): Foreign key pointing the sample that precedes this in time. Empty if start of scene.\n\n    Shortcuts:\n    ---------\n        data (dict[str, str]): Sensor channel and its token.\n            This should be set after instantiated.\n        ann_3ds (list[str]): List of foreign keys pointing the sample annotations.\n            This should be set after instantiated.\n        ann_2ds (list[str]): List of foreign keys pointing the object annotations.\n            This should be set after instantiated.\n        surface_anns (list[str]): List of foreign keys pointing the surface annotations.\n            This should be set after instantiated.\n    \"\"\"\n\n    timestamp: int = field(validator=validators.instance_of(int))\n    scene_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    next: str = field(validator=validators.instance_of(str))\n    prev: str = field(validator=validators.instance_of(str))\n\n    # shortcuts\n    data: dict[str, str] = field(factory=dict, init=False)\n    ann_3ds: list[str] = field(factory=list, init=False)\n    ann_2ds: list[str] = field(factory=list, init=False)\n    surface_anns: list[str] = field(factory=list, init=False)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleAnnotation","title":"<code>SampleAnnotation</code>","text":"<p>               Bases: <code>SchemaBase</code>, <code>AutolabelMixin</code></p> <p>A dataclass to represent schema table of <code>sample_annotation.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>sample_token</code> <code>str</code> <p>Foreign key pointing the sample.</p> <code>instance_token</code> <code>str</code> <p>Foreign key pointing the object instance.</p> <code>attribute_tokens</code> <code>list[str]</code> <p>Foreign keys. List of attributes for this annotation.</p> <code>visibility_token</code> <code>str</code> <p>Foreign key pointing the object visibility.</p> <code>translation</code> <code>Vector3</code> <p>Bounding box location given as [x, y, z] in [m].</p> <code>size</code> <code>Vector3</code> <p>Bounding box size given as [width, length, height] in [m].</p> <code>rotation</code> <code>Quaternion</code> <p>Bounding box orientation given as quaternion [w, x, y, z].</p> <code>num_lidar_pts</code> <code>int</code> <p>Number of lidar points in this box.</p> <code>num_radar_pts</code> <code>int</code> <p>Number of radar points in this box.</p> <code>next</code> <code>str</code> <p>Foreign key pointing the annotation that follows this in time. Empty if this is the last annotation for this object.</p> <code>prev</code> <code>str</code> <p>Foreign key pointing the annotation that precedes this in time. Empty if this the first annotation for this object.</p> <code>velocity</code> <code>Vector3 | None</code> <p>Bounding box velocity given as [vx, vy, vz] in [m/s].</p> <code>acceleration</code> <code>Vector3 | None</code> <p>Bonding box acceleration given as [ax, ay, av] in [m/s^2].</p> Inherited from AutolabelMixin <p>automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.     If any part is manually modified or annotated by human this value is False. autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if <code>automatic_annotation</code> is <code>true</code>.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleAnnotation--shortcuts","title":"Shortcuts:","text":"<pre><code>category_name (str): Category name. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sample_annotation.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SAMPLE_ANNOTATION)\nclass SampleAnnotation(SchemaBase, AutolabelMixin):\n    \"\"\"A dataclass to represent schema table of `sample_annotation.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_token (str): Foreign key pointing the sample.\n        instance_token (str): Foreign key pointing the object instance.\n        attribute_tokens (list[str]): Foreign keys. List of attributes for this annotation.\n        visibility_token (str): Foreign key pointing the object visibility.\n        translation (Vector3): Bounding box location given as [x, y, z] in [m].\n        size (Vector3): Bounding box size given as [width, length, height] in [m].\n        rotation (Quaternion): Bounding box orientation given as quaternion [w, x, y, z].\n        num_lidar_pts (int): Number of lidar points in this box.\n        num_radar_pts (int): Number of radar points in this box.\n        next (str): Foreign key pointing the annotation that follows this in time.\n            Empty if this is the last annotation for this object.\n        prev (str): Foreign key pointing the annotation that precedes this in time.\n            Empty if this the first annotation for this object.\n        velocity (Vector3 | None, optional): Bounding box velocity given as\n            [vx, vy, vz] in [m/s].\n        acceleration (Vector3 | None, optional): Bonding box acceleration\n            given as [ax, ay, av] in [m/s^2].\n\n    Inherited from AutolabelMixin:\n        automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.\n            If any part is manually modified or annotated by human this value is False.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n\n    Shortcuts:\n    ---------\n        category_name (str): Category name. This should be set after instantiated.\n    \"\"\"\n\n    sample_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    instance_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    attribute_tokens: list[str] = field(\n        validator=validators.deep_iterable((validators.instance_of(str), impossible_empty()))\n    )\n    visibility_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    translation: Vector3 = field(converter=Vector3)\n    size: Vector3 = field(converter=Vector3)\n    rotation: Quaternion = field(converter=to_quaternion)\n    num_lidar_pts: int = field(validator=validators.instance_of(int))\n    num_radar_pts: int = field(validator=validators.instance_of(int))\n    next: str = field(validator=validators.instance_of(str))\n    prev: str = field(validator=validators.instance_of(str))\n    velocity: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n    acceleration: Vector3 | None = field(default=None, converter=converters.optional(Vector3))\n\n    # shortcuts\n    category_name: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleData","title":"<code>SampleData</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A class to represent schema table of <code>sample_data.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>sample_token</code> <code>str</code> <p>Foreign key pointing the sample. Empty if this is not a key frame.</p> <code>ego_pose_token</code> <code>str</code> <p>Foreign key pointing the ego_pose.</p> <code>calibrated_sensor_token</code> <code>str</code> <p>Foreign key pointing the calibrated_sensor.</p> <code>filename</code> <code>str</code> <p>Relative path to data-blob on disk.</p> <code>fileformat</code> <code>FileFormat</code> <p>Data file format.</p> <code>width</code> <code>int</code> <p>If the sample data is an image, this is the image width in [px].</p> <code>height</code> <code>int</code> <p>If the sample data is an image, this is the image height in [px].</p> <code>timestamp</code> <code>int</code> <p>Unix time stamp.</p> <code>is_key_frame</code> <code>bool</code> <p>True if sample_data is part of key frame else, False.</p> <code>next</code> <code>str</code> <p>Foreign key pointing the sample_data that follows this in time. Empty if end of scene.</p> <code>prev</code> <code>str</code> <p>Foreign key pointing the sample_data that precedes this in time. Empty if start of scene.</p> <code>is_valid</code> <code>bool</code> <p>True if this data is valid, else False. Invalid data should be ignored.</p> <code>info_filename</code> <code>str</code> <p>Relative path to metainfo data-blob on disk.</p> <code>autolabel_metadata</code> <code>list[AutolabelModel] | None</code> <p>List of models used for autolabeling applied to this entire sample_data item (e.g., image or scan).</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SampleData--shortcuts","title":"Shortcuts:","text":"<pre><code>modality (SensorModality): Sensor modality. This should be set after instantiated.\nchannel (str): Sensor channel. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sample_data.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SAMPLE_DATA)\nclass SampleData(SchemaBase):\n    \"\"\"A class to represent schema table of `sample_data.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_token (str): Foreign key pointing the sample. Empty if this is not a key frame.\n        ego_pose_token (str): Foreign key pointing the ego_pose.\n        calibrated_sensor_token (str): Foreign key pointing the calibrated_sensor.\n        filename (str): Relative path to data-blob on disk.\n        fileformat (FileFormat): Data file format.\n        width (int): If the sample data is an image, this is the image width in [px].\n        height (int): If the sample data is an image, this is the image height in [px].\n        timestamp (int): Unix time stamp.\n        is_key_frame (bool): True if sample_data is part of key frame else, False.\n        next (str): Foreign key pointing the sample_data that follows this in time.\n            Empty if end of scene.\n        prev (str): Foreign key pointing the sample_data that precedes this in time.\n            Empty if start of scene.\n        is_valid (bool): True if this data is valid, else False. Invalid data should be ignored.\n        info_filename (str): Relative path to metainfo data-blob on disk.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling applied to this entire sample_data item (e.g., image or scan).\n\n    Shortcuts:\n    ---------\n        modality (SensorModality): Sensor modality. This should be set after instantiated.\n        channel (str): Sensor channel. This should be set after instantiated.\n    \"\"\"\n\n    sample_token: str = field(validator=validators.instance_of(str))\n    ego_pose_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    calibrated_sensor_token: str = field(\n        validator=(validators.instance_of(str), impossible_empty())\n    )\n    filename: str = field(validator=validators.instance_of(str))\n    fileformat: FileFormat = field(converter=FileFormat)\n    width: int = field(validator=validators.instance_of(int))\n    height: int = field(validator=validators.instance_of(int))\n    timestamp: int = field(validator=validators.instance_of(int))\n    is_key_frame: bool = field(validator=validators.instance_of(bool))\n    next: str = field(validator=validators.instance_of(str))  # noqa: A003\n    prev: str = field(validator=validators.instance_of(str))\n    is_valid: bool = field(default=True, validator=validators.instance_of(bool))\n    info_filename: str | None = field(\n        default=None, validator=validators.optional(validators.instance_of(str))\n    )\n    autolabel_metadata: list[AutolabelModel] | None = field(\n        default=None,\n        converter=AutolabelModel.to_autolabel_model,\n        validator=validators.optional(\n            validators.deep_iterable(validators.instance_of(AutolabelModel))\n        ),\n    )\n\n    # shortcuts\n    modality: SensorModality | None = field(init=False, default=None)\n    channel: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Scene","title":"<code>Scene</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>scene.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>name</code> <code>str</code> <p>Short string identifier.</p> <code>description</code> <code>str</code> <p>Longer description for the scene.</p> <code>log_token</code> <code>str</code> <p>Foreign key pointing to log from where the data was extracted.</p> <code>nbr_samples</code> <code>int</code> <p>Number of samples in the scene.</p> <code>first_sample_token</code> <code>str</code> <p>Foreign key pointing to the first sample in scene.</p> <code>last_sample_token</code> <code>str</code> <p>Foreign key pointing to the last sample in scene.</p> Source code in <code>t4_devkit/schema/tables/scene.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SCENE)\nclass Scene(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `scene.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        name (str): Short string identifier.\n        description (str): Longer description for the scene.\n        log_token (str): Foreign key pointing to log from where the data was extracted.\n        nbr_samples (int): Number of samples in the scene.\n        first_sample_token (str): Foreign key pointing to the first sample in scene.\n        last_sample_token (str): Foreign key pointing to the last sample in scene.\n    \"\"\"\n\n    name: str = field(validator=validators.instance_of(str))\n    description: str = field(validator=validators.instance_of(str))\n    log_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    nbr_samples: int = field(validator=validators.instance_of(int))\n    first_sample_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    last_sample_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sensor","title":"<code>Sensor</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>sensor.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>channel</code> <code>str</code> <p>Sensor channel name.</p> <code>modality</code> <code>SensorModality</code> <p>Sensor modality.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Sensor--shortcuts","title":"Shortcuts:","text":"<pre><code>first_sd_token (str): The first sample data token corresponding to its sensor channel.\n</code></pre> Source code in <code>t4_devkit/schema/tables/sensor.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SENSOR)\nclass Sensor(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `sensor.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        channel (str): Sensor channel name.\n        modality (SensorModality): Sensor modality.\n\n    Shortcuts:\n    ---------\n        first_sd_token (str): The first sample data token corresponding to its sensor channel.\n    \"\"\"\n\n    channel: str = field(validator=validators.instance_of(str))\n    modality: SensorModality = field(converter=SensorModality)\n\n    # shortcuts\n    first_sd_token: str = field(init=False, factory=str)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SurfaceAnn","title":"<code>SurfaceAnn</code>","text":"<p>               Bases: <code>SchemaBase</code>, <code>AutolabelMixin</code></p> <p>A dataclass to represent schema table of <code>surface_ann.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>sample_data_token</code> <code>str</code> <p>Foreign key pointing to the sample data, which must be a keyframe image.</p> <code>category_token</code> <code>str</code> <p>Foreign key pointing to the surface category.</p> <code>mask</code> <code>RLEMask</code> <p>Segmentation mask using the COCO format compressed by RLE.</p> Inherited from AutolabelMixin <p>automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.     If any part is manually modified or annotated by human this value is False. autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if <code>automatic_annotation</code> is <code>true</code>.</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SurfaceAnn--shortcuts","title":"Shortcuts:","text":"<pre><code>category_name (str): Category name. This should be set after instantiated.\n</code></pre> Source code in <code>t4_devkit/schema/tables/surface_ann.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.SURFACE_ANN)\nclass SurfaceAnn(SchemaBase, AutolabelMixin):\n    \"\"\"A dataclass to represent schema table of `surface_ann.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        sample_data_token (str): Foreign key pointing to the sample data, which must be a keyframe image.\n        category_token (str): Foreign key pointing to the surface category.\n        mask (RLEMask): Segmentation mask using the COCO format compressed by RLE.\n\n    Inherited from AutolabelMixin:\n        automatic_annotation (bool, optional): Indicates if the annotation is fully generated by an ML model.\n            If any part is manually modified or annotated by human this value is False.\n        autolabel_metadata (list[AutolabelModel] | None, optional): List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n\n    Shortcuts:\n    ---------\n        category_name (str): Category name. This should be set after instantiated.\n    \"\"\"\n\n    sample_data_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    category_token: str = field(validator=(validators.instance_of(str), impossible_empty()))\n    mask: RLEMask | None = field(\n        default=None,\n        converter=lambda x: RLEMask(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(RLEMask)),\n    )\n\n    # shortcuts\n    category_name: str = field(init=False, factory=str)\n\n    @property\n    def bbox(self) -&gt; Roi | None:\n        \"\"\"Return a bounding box corners calculated from polygon vertices.\n\n        Returns:\n            Roi instance given as [xmin, ymin, xmax, ymax].\n        \"\"\"\n        if self.mask is None:\n            return None\n\n        mask = self.mask.decode()\n        indices = np.where(mask == 1)\n        xmin, ymin = np.min(indices, axis=1)\n        xmax, ymax = np.max(indices, axis=1)\n        return Roi(xmin, ymin, xmax, ymax)\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.SurfaceAnn.bbox","title":"<code>bbox</code>  <code>property</code>","text":"<p>Return a bounding box corners calculated from polygon vertices.</p> <p>Returns:</p> Type Description <code>Roi | None</code> <p>Roi instance given as [xmin, ymin, xmax, ymax].</p>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.VehicleState","title":"<code>VehicleState</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>vehicle_state.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>timestamp</code> <code>int</code> <p>Unix time stamp.</p> <code>accel_pedal</code> <code>float | None</code> <p>Accel pedal position [%].</p> <code>brake_pedal</code> <code>float | None</code> <p>Brake pedal position [%].</p> <code>steer_pedal</code> <code>float | None</code> <p>Steering wheel position [%].</p> <code>steering_tire_angle</code> <code>float | None</code> <p>Steering tire angle [rad].</p> <code>steering_wheel_angle</code> <code>float | None</code> <p>Steering wheel angle [rad].</p> <code>shift_state</code> <code>ShiftState | None</code> <p>Gear shift state.</p> <code>indicators</code> <code>Indicators | None</code> <p>State of each indicator.</p> <code>additional_info</code> <code>AdditionalInfo | None</code> <p>Additional state information.</p> Source code in <code>t4_devkit/schema/tables/vehicle_state.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.VEHICLE_STATE)\nclass VehicleState(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `vehicle_state.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        timestamp (int): Unix time stamp.\n        accel_pedal (float | None): Accel pedal position [%].\n        brake_pedal (float | None): Brake pedal position [%].\n        steer_pedal (float | None): Steering wheel position [%].\n        steering_tire_angle (float | None): Steering tire angle [rad].\n        steering_wheel_angle (float | None): Steering wheel angle [rad].\n        shift_state (ShiftState | None): Gear shift state.\n        indicators (Indicators | None): State of each indicator.\n        additional_info (AdditionalInfo | None): Additional state information.\n    \"\"\"\n\n    timestamp: int = field(validator=validators.instance_of(int))\n    accel_pedal: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    brake_pedal: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    steer_pedal: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    steering_tire_angle: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    steering_wheel_angle: float | None = field(\n        default=None,\n        validator=validators.optional(validators.instance_of(float)),\n    )\n    shift_state: ShiftState | None = field(\n        default=None,\n        converter=converters.optional(ShiftState),\n        validator=validators.optional(validators.instance_of(ShiftState)),\n    )\n    indicators: Indicators | None = field(\n        default=None,\n        converter=lambda x: Indicators(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(Indicators)),\n    )\n    additional_info: AdditionalInfo | None = field(\n        default=None,\n        converter=lambda x: AdditionalInfo(**x) if isinstance(x, dict) else x,\n        validator=validators.optional(validators.instance_of(AdditionalInfo)),\n    )\n</code></pre>"},{"location":"apis/schema/table/#t4_devkit.schema.tables.Visibility","title":"<code>Visibility</code>","text":"<p>               Bases: <code>SchemaBase</code></p> <p>A dataclass to represent schema table of <code>visibility.json</code>.</p> <p>Attributes:</p> Name Type Description <code>token</code> <code>str</code> <p>Unique record identifier.</p> <code>level</code> <code>VisibilityLevel</code> <p>Visibility level.</p> <code>description</code> <code>str</code> <p>Description of visibility level.</p> Source code in <code>t4_devkit/schema/tables/visibility.py</code> <pre><code>@define(slots=False)\n@SCHEMAS.register(SchemaName.VISIBILITY)\nclass Visibility(SchemaBase):\n    \"\"\"A dataclass to represent schema table of `visibility.json`.\n\n    Attributes:\n        token (str): Unique record identifier.\n        level (VisibilityLevel): Visibility level.\n        description (str): Description of visibility level.\n    \"\"\"\n\n    level: VisibilityLevel = field(\n        converter=lambda x: VisibilityLevel.from_value(x)\n        if not isinstance(x, VisibilityLevel)\n        else VisibilityLevel(x)\n    )\n    description: str = field(validator=validators.instance_of(str))\n</code></pre>"},{"location":"cli/","title":"CLI Support","text":"<p>Following command line tools are supported:</p> <ul> <li><code>t4viz</code>: Visualize T4 dataset features</li> <li><code>t4sanity</code>: Sanity checker of T4 dataset</li> </ul>"},{"location":"cli/t4sanity/","title":"t4sanity","text":"<p><code>t4sanity</code> performs sanity checks on T4 datasets, reporting any issues regarding the dataset requirements.</p> <pre><code>$ t4sanity -h\n\n Usage: t4sanity [OPTIONS] DB_PARENT\n\n\u256d\u2500 Arguments \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 *    data_root      TEXT  Path to root directory of a dataset. [default: None] [required]                             \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --version             -v             Show the application version and exit.                                           \u2502\n\u2502 --output              -o       TEXT  Path to output JSON file. [default: None]                                        \u2502\n\u2502 --revision            -rv      TEXT  Specify if you want to check the specific version. [default: None]               \u2502\n\u2502 --exclude             -e       TEXT  Exclude specific rules or rule groups. [default: None]                           \u2502\n\u2502 --strict              -s             Indicates whether warnings are treated as failures.                              \u2502\n\u2502 --fix                 -f             Attempt to fix the issues reported by the sanity check.                          \u2502\n\u2502 --install-completion                 Install completion for the current shell.                                        \u2502\n\u2502 --show-completion                    Show completion for the current shell, to copy it or customize the installation. \u2502\n\u2502 --help                -h             Show this message and exit.                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/t4sanity/#shell-completion","title":"Shell Completion","text":"<p>Run the following command to install completion, and reload shell.</p> <pre><code>t4sanity --install-completion\n</code></pre>"},{"location":"cli/t4sanity/#usages","title":"Usages","text":"<p>As an example, we have the following the dataset structure:</p> <pre><code>&lt;DATA_ROOT; (DATASET ID)&gt;\n\u251c\u2500\u2500 &lt;VERSION&gt;\n\u2502    \u251c\u2500\u2500 annotation\n\u2502    \u251c\u2500\u2500 data\n|    ...\n</code></pre> <p>Then, you can run sanity checks with <code>t4sanity &lt;DATA_ROOT&gt;</code>:</p> <pre><code>$ t4sanity &lt;DATA_ROOT&gt;\n\n&gt;&gt;&gt;Sanity checking...: 1it [00:00,  9.70it/s]\n\n=== DatasetID: dataset1 ===\n  STR001: \u2705\n  STR002: \u2705\n  STR003: \u2705\n  STR004: \u2705\n  STR005: \u2705\n  STR006: \u2705\n  STR007: \u2705\n  STR008: \u2705\n  ...\n\n+-----------+---------+--------+--------+---------+----------+-------+\n| DatasetID | Version | Passed | Failed | Skipped | Warnings | Fixed |\n+-----------+---------+--------+--------+---------+----------+-------+\n| dataset1  |    0    |   49   |   0    |    2    |    3     |   0   |\n+-----------+---------+--------+--------+---------+----------+-------+\n</code></pre>"},{"location":"cli/t4sanity/#exclude-checks","title":"Exclude Checks","text":"<p>With <code>-e; --exclude</code> option enables us to exclude specific checks by specifying the rule IDs or groups:</p> <pre><code># Exclude STR001 and all FMT-relevant rules\nt4sanity &lt;DATA_ROOT&gt; -e STR001 -e FMT\n</code></pre>"},{"location":"cli/t4sanity/#strict-mode","title":"Strict Mode","text":"<p>Basically, rules whose severity is WARNING will be treated as success.</p> <p>With <code>-s; --strict</code> option enables us to treat warnings as failures:</p> <pre><code># Run strict mode\nt4sanity &lt;DATA_ROOT&gt; --strict\n</code></pre>"},{"location":"cli/t4sanity/#fix-issues","title":"Fix Issues","text":"<p>With <code>-f; --fix</code> option enables to fix issues automatically:</p> <pre><code># Fix issues automatically\nt4sanity &lt;DATA_ROOT&gt; --fix\n\n&gt;&gt;&gt;Sanity checking...: 1it [00:00,  9.70it/s]\n\n=== DatasetID: dataset1 ===\n  ...\n  REC007: --&gt; FIXED \u2705\n     - All categories either must have an 'index' set or all have a 'null' index.\n  ...\n\n+-----------+---------+--------+--------+---------+----------+-------+\n| DatasetID | Version | Passed | Failed | Skipped | Warnings | Fixed |\n+-----------+---------+--------+--------+---------+----------+-------+\n| dataset1  |    0    |   49   |   0    |    2    |    3     |   1   |\n+-----------+---------+--------+--------+---------+----------+-------+\n</code></pre> <p>The generated report contains failure or warning reasons, but it's considered as passed if the fix was successful.</p>"},{"location":"cli/t4sanity/#exit-status-logic","title":"Exit Status Logic","text":"<p><code>t4sanity</code> CLI returns the exit code based on the following conditions:</p> Condition <code>--strict</code> <code>--fix</code> Exit Code Notes At least one <code>Severity.ERROR</code> rule failed N/A <code>False</code> 1 Always fails the run At least one <code>Severity.ERROR</code> rule failed, but fixed N/A <code>True</code> 0 Run is considered successful, error reasons are reported and <code>Fixed=true</code> At least one <code>Severity.WARNING</code> rule failed, no <code>Severity.ERROR</code> failed <code>False</code> (default) N/A 0 Run is considered successful, warnings are reported At least one <code>Severity.WARNING</code> rule failed, no <code>Severity.ERROR</code> failed <code>True</code> <code>False</code> 1 Treat warnings as failures; exit with failure At least one <code>Severity.WARNING</code> rule failed, no <code>Severity.ERROR</code> failed, but fixed <code>True</code> <code>True</code> 0 Run is considered successful, warnings are reported and <code>Fixed=true</code> All rules passed or skipped N/A N/A 0 Run is considered successful"},{"location":"cli/t4sanity/#dump-results-as-json","title":"Dump Results as JSON","text":"<p>To dump results into JSON, use the <code>-o; --output</code> option:</p> <pre><code>t4sanity &lt;DATA_ROOT&gt; -o result.json\n</code></pre> <p>Then a JSON file named <code>result.json</code> will be generated as follows:</p> <pre><code>{\n  \"dataset_id\": \"&lt;DatasetID: str&gt;\",\n  \"version\": &lt;Version: int&gt;,\n  \"reports\": [\n    {\n        \"id\": \"&lt;RuleID: str&gt;\",\n        \"name\": \"&lt;RuleName: str&gt;\",\n        \"severity\": \"&lt;WARNING/ERROR: str&gt;\",\n        \"description\": \"&lt;Description: str&gt;\",\n        \"status\": \"&lt;PASSED/FAILED/SKIPPED: str&gt;\",\n        \"reasons\": \"&lt;[&lt;Reason1&gt;, &lt;Reason2&gt;, ...]: [str; N] | null&gt;\",\n        \"fixed\": \"&lt;Fixed: bool&gt;\"\n    },\n  ]\n}\n</code></pre> <p>Here is the description of the JSON format:</p> <ul> <li><code>dataset_id</code>: The ID of the dataset.</li> <li><code>version</code>: The version of the dataset.</li> <li><code>reports</code>: An array of rule reports.</li> <li><code>id</code>: The ID of the rule.</li> <li><code>name</code>: The name of the rule.</li> <li><code>severity</code>: How important a rule is.</li> <li><code>description</code>: A description of the rule.</li> <li><code>status</code>: What happened when it ran.</li> <li><code>reasons</code>: An array of reasons for failure or skipped rules, null if passed.</li> <li><code>fixed</code>: Whether the rule was fixed.</li> </ul>"},{"location":"cli/t4viz/","title":"t4viz","text":"<p><code>t4viz</code> performs visualizing particular dataset attributes from command line.</p> <pre><code>$ t4viz -h\n\n Usage: t4viz [OPTIONS] COMMAND [ARGS]...\n\n\u256d\u2500 Options \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 --version             -v        Show the application version and exit.                                           \u2502\n\u2502 --install-completion            Install completion for the current shell.                                        \u2502\n\u2502 --show-completion               Show completion for the current shell, to copy it or customize the installation. \u2502\n\u2502 --help                -h        Show this message and exit.                                                      \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n\u256d\u2500 Commands \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256e\n\u2502 scene        Visualize a specific scene.                                                                         \u2502\n\u2502 instance     Visualize a particular instance in the corresponding scene.                                         \u2502\n\u2502 pointcloud   Visualize pointcloud in the corresponding scene.                                                    \u2502\n\u2570\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u256f\n</code></pre>"},{"location":"cli/t4viz/#shell-completion","title":"Shell Completion","text":"<p>Run the following command to install completion, and reload shell.</p> <pre><code>t4viz --install-completion\n</code></pre>"},{"location":"cli/t4viz/#usages","title":"Usages","text":""},{"location":"cli/t4viz/#scene","title":"Scene","text":"<p>This command performs the same behavior with <code>Tier4.render_scene(...)</code>.</p> <p>For options, run <code>t4viz scene -h</code>.</p> <pre><code>t4viz scene &lt;DATA_ROOT&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/t4viz/#specific-instances","title":"Specific Instance(s)","text":"<p>This command performs the same behavior with <code>Tier4.render_instance(...)</code>.</p> <p>For options, run <code>t4viz instance -h</code>.</p> <pre><code>t4viz instance &lt;DATA_ROOT&gt; &lt;INSTANCE_TOKEN&gt; [OPTIONS]\n</code></pre> <p>You can also specify multiple instance tokens:</p> <pre><code>t4viz instance &lt;DATA_ROOT&gt; &lt;INSTANCE_TOKEN1&gt; &lt;INSTANCE_TOKEN2&gt; ... [OPTIONS]\n</code></pre>"},{"location":"cli/t4viz/#pointcloud","title":"PointCloud","text":"<p>This command performs the same behavior with <code>Tier4.render_pointcloud(...)</code>.</p> <p>For options, run <code>t4viz pointcloud -h</code>.</p> <pre><code>t4viz pointcloud &lt;DATA_ROOT&gt; [OPTIONS]\n</code></pre>"},{"location":"cli/t4viz/#future-trajectories","title":"Future Trajectories","text":"<p><code>scene</code> and <code>instance</code> commands support visualizing future trajectories for each object.</p> <p>By specifying <code>-f [--future]</code> option, you can render them in the particular time length:</p> <pre><code>t4viz &lt;COMMAND&gt; ... -f &lt;FUTURE_LENGTH[s]&gt;\n</code></pre>"},{"location":"cli/t4viz/#save-recording-as-rrd","title":"Save Recording as <code>.rrd</code>","text":"<p>You can save visualized recording with <code>-o [--output]</code> option as follows:</p> <pre><code>t4viz &lt;COMMAND&gt; ... -o &lt;OUTPUT_DIR&gt;\n</code></pre> <p>Note that if you specify <code>--output</code> option, viewer will not be spawned.</p>"},{"location":"schema/","title":"Dataset Schema","text":""},{"location":"schema/#directory-structure","title":"Directory Structure","text":"<pre><code>&lt;DATASET_ID&gt;/\n\u2514\u2500\u2500 &lt;DATASET_VERSION&gt;/\n    \u251c\u2500\u2500 annotation/    ...schema tables in JSON format\n    \u251c\u2500\u2500 data/          ...sensor raw data\n    \u251c\u2500\u2500 input_bag/     ...original ROS bag file\n    \u251c\u2500\u2500 map/           ...map files\n    \u251c\u2500\u2500 lidarseg/      ...[OPTIONAL] LiDAR segmentation annotation\n    \u2514\u2500\u2500 status.json    ...dataset status information\n</code></pre>"},{"location":"schema/#schema-tables","title":"Schema Tables","text":"<p>Annotation information is stored in the <code>annotation</code> directory.</p> <p>See the document of dataset schema for details.</p>"},{"location":"schema/#sensor-data","title":"Sensor Data","text":"<p>Raw sensor data is stored in the <code>data</code> directory.</p> <p>See the document of sensor data for details.</p>"},{"location":"schema/#map-data","title":"Map Data","text":"<p>Map data is stored in the <code>map</code> directory.</p> <p>It is structured as follows:</p> <pre><code>map/\n\u251c\u2500\u2500 lanelet2_map.osm    ...lanelet2 map file\n\u2514\u2500\u2500 pointcloud_map.pcd/ ...pointcloud map directory\n</code></pre>"},{"location":"schema/#lidar-segmentation-annotation","title":"LiDAR Segmentation Annotation","text":"<p>T4 dataset can include 3D LiDAR segmentation annotation optionally. The format is exactly the same as the nuScenes format with one additional <code>lidarseg.json</code> file.</p> <p>Note that every <code>&lt;lidarseg_token&gt;.bin</code> consists of category labels for every LiDAR pointcloud at a keyframe.</p> <pre><code>lidarseg/\n\u2514\u2500\u2500 annotation/\n    \u251c\u2500\u2500 &lt;lidarseg_token&gt;.bin    ...category labels for every LiDAR pointcloud at a keyframe\n    ...\n</code></pre>"},{"location":"schema/#statusjson","title":"status.json","text":"<p><code>status.json</code> contains the information about the configuration used to generate the dataset.</p>"},{"location":"schema/data/","title":"Sensor Data","text":""},{"location":"schema/data/#lidar-point-cloud","title":"LiDAR Point Cloud","text":"<p>LiDAR directory contains point cloud data as the name of <code>&lt;LIDAR_CONCAT&gt;</code> or <code>&lt;LIDAR_TOP&gt;</code>:</p> <pre><code>data/\n\u2514\u2500\u2500 LIDAR_CONCAT\n    \u251c\u2500\u2500 &lt;FRAME_ID&gt;.pcd.bin\n    ...\n</code></pre> <p>Each file contains <code>(x, y, z, intensity, ring_idx(=-1))</code>, and location coordinates are given with respect to the ego vehicle coordinate system.</p> <p>Each file can be loaded using as follows:</p> <pre><code># Using NumPy\nimport numpy as np\n\ndef load_lidar_point_cloud(file_path) -&gt; np.ndarray:\n    data = np.fromfile(file_path, dtype=np.float32) # (N*5,)\n    return data.reshape((-1, 5)) # (N, 5)\n\n# Using t4-devkit\nfrom t4_devkit.dataclass import LidarPointCloud\n\ndef load_lidar_point_cloud_t4(file_path) -&gt; LidarPointCloud:\n    return LidarPointCloud.from_file(file_path)\n</code></pre>"},{"location":"schema/data/#camera-image","title":"Camera Image","text":"<p>Camera directory contains raw images as the name of <code>&lt;CAM_XXX&gt;</code>:</p> <pre><code>data/\n\u251c\u2500\u2500 CAM_BACK\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 &lt;FRAME_ID&gt;.jpg\n\u2502\u00a0\u00a0 ...\n\u251c\u2500\u2500 CAM_BACK_LEFT\n\u251c\u2500\u2500 CAM_BACK_RIGHT\n\u251c\u2500\u2500 CAM_FRONT\n...\n</code></pre>"},{"location":"schema/data/#radar-object","title":"Radar Object","text":"<p>Radar directory contains radar object tracks</p> <pre><code>data/\n\u251c\u2500\u2500 RADAR_BACK\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 &lt;FRAME_ID&gt;.pcd\n\u2502\u00a0\u00a0 ...\n\u251c\u2500\u2500 RADAR_BACK_LEFT\n\u251c\u2500\u2500 RADAR_BACK_RIGHT\n\u251c\u2500\u2500 RADAR_FRONT\n...\n</code></pre> <p>Each file is based on NuScenes radar data format as follows:</p> <pre><code># .PCD v0.7 - Point Cloud Data file format\nVERSION 0.7\nFIELDS x y z dyn_prop id rcs vx vy vx_comp vy_comp is_quality_valid ambig_state x_rms y_rms invalid_state pdh0 vx_rms vy_rms\nSIZE 4 4 4 1 2 4 4 4 4 4 1 1 1 1 1 1 1 1\nTYPE F F F I I F F F F F I I I I I I I I\nCOUNT 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1 1\nWIDTH 112\nHEIGHT 1\nVIEWPOINT 0 0 0 1 0 0 0\nPOINTS 112\nDATA binary\n</code></pre> <pre><code>from t4_devkit.dataclass import RadarPointCloud\n\ndef load_radar_point_cloud(file_path) -&gt; RadarPointCloud:\n    return RadarPointCloud.from_file(file_path)\n</code></pre>"},{"location":"schema/requirement/","title":"Dataset Requirements","text":""},{"location":"schema/requirement/#structure-str","title":"Structure (<code>STR</code>)","text":"ID Name Severity Fixable Description <code>STR001</code> <code>version-dir-presence</code> <code>WARNING</code> <code>N/A</code> <code>version/</code> directory exists under the dataset root directory. <code>STR002</code> <code>annotation-dir-presence</code> <code>ERROR</code> <code>N/A</code> <code>annotation/</code> directory exists under the dataset root directory. <code>STR003</code> <code>data-dir-presence</code> <code>ERROR</code> <code>N/A</code> <code>data/</code> directory exists under the dataset root directory. <code>STR004</code> <code>map-dir-presence</code> <code>WARNING</code> <code>N/A</code> <code>map/</code> directory exists under the dataset root directory. <code>STR005</code> <code>bag-dir-presence</code> <code>WARNING</code> <code>N/A</code> <code>input_bag/</code> directory exists under the dataset root directory. <code>STR006</code> <code>status-file-presence</code> <code>WARNING</code> <code>N/A</code> <code>status.json</code> file exists under the dataset root directory. <code>STR007</code> <code>schema-files-presence</code> <code>ERROR</code> <code>N/A</code> Mandatory schema JSON files exist under the <code>annotation/</code> directory. <code>STR008</code> <code>lanelet-file-presence</code> <code>WARNING</code> <code>N/A</code> <code>lanelet2_map.osm</code> file exists under the <code>map/</code> directory. <code>STR009</code> <code>pointcloud-map-dir-presence</code> <code>WARNING</code> <code>N/A</code> <code>pointcloud_map.pcd</code> directory exists under the <code>map/</code> directory."},{"location":"schema/requirement/#schema-record-rec","title":"Schema Record (<code>REC</code>)","text":"ID Name Severity Fixable Description <code>REC001</code> <code>scene-single</code> <code>ERROR</code> <code>N/A</code> <code>Scene</code> record is a single. <code>REC002</code> <code>sample-not-empty</code> <code>ERROR</code> <code>N/A</code> <code>Sample</code> record is not empty. <code>REC003</code> <code>sample-data-not-empty</code> <code>ERROR</code> <code>N/A</code> <code>SampleData</code> record is not empty. <code>REC004</code> <code>ego-pose-not-empty</code> <code>ERROR</code> <code>N/A</code> <code>EgoPose</code> record is not empty. <code>REC005</code> <code>calibrated-sensor-non-empty</code> <code>ERROR</code> <code>N/A</code> <code>CalibratedSensor</code> record is not empty. <code>REC006</code> <code>instance-not-empty</code> <code>ERROR</code> <code>N/A</code> <code>Instance</code> record is not empty if either <code>SampleAnnotation</code> or <code>ObjectAnnotation</code> is not empty. <code>REC007</code> <code>category-indices-consistent</code> <code>ERROR</code> <code>YES</code> <code>Category</code> records must either all have a unique <code>index</code> or all have a <code>null</code> index."},{"location":"schema/requirement/#reference-ref","title":"Reference (<code>REF</code>)","text":""},{"location":"schema/requirement/#record-reference-a-to-b","title":"Record Reference (A to B)","text":"ID Name Severity Fixable Description <code>REF001</code> <code>scene-to-log</code> <code>ERROR</code> <code>N/A</code> <code>Scene.log_token</code> refers to <code>Log</code> record. <code>REF002</code> <code>scene-to-first-sample</code> <code>ERROR</code> <code>N/A</code> <code>Scene.first_sample_token</code> refers to <code>Sample</code> record. <code>REF003</code> <code>scene-to-last-sample</code> <code>ERROR</code> <code>N/A</code> <code>Scene.last_sample_token</code> refers to <code>Sample</code> record. <code>REF004</code> <code>sample-to-scene</code> <code>ERROR</code> <code>N/A</code> <code>Sample.scene_token</code> refers to <code>Scene</code> record. <code>REF005</code> <code>sample-data-to-sample</code> <code>ERROR</code> <code>N/A</code> <code>SampleData.sample_token</code> refers to <code>Sample</code> record. <code>REF006</code> <code>sample-data-to-ego-pose</code> <code>ERROR</code> <code>N/A</code> <code>SampleData.ego_pose_token</code> refers to <code>EgoPose</code> record. <code>REF007</code> <code>sample-data-to-calibrated-sensor</code> <code>ERROR</code> <code>N/A</code> <code>SampleData.calibrated_sensor_token</code> refers to <code>CalibratedSensor</code> record. <code>REF008</code> <code>calibrated-sensor-to-sensor</code> <code>ERROR</code> <code>N/A</code> <code>CalibratedSensor.sensor_token</code> refers to <code>Sensor</code> record. <code>REF009</code> <code>instance-to-category</code> <code>ERROR</code> <code>N/A</code> <code>Instance.category_token</code> refers to <code>Category</code> record. <code>REF010</code> <code>instance-to-first-sample-annotation</code> <code>ERROR</code> <code>N/A</code> <code>Instance.first_annotation_token</code> refers to <code>SampleAnnotation</code> record. <code>REF011</code> <code>instance-to-last-sample-annotation</code> <code>ERROR</code> <code>N/A</code> <code>Instance.last_annotation_token</code> refers to <code>SampleAnnotation</code> record. <code>REF012</code> <code>lidarseg-to-sample-data</code> <code>ERROR</code> <code>N/A</code> <code>LidarSeg.sample_data_token</code> refers to <code>SampleData</code> record."},{"location":"schema/requirement/#record-reference-a-to-a","title":"Record Reference (A to A')","text":"ID Name Severity Fixable Description <code>REF101</code> <code>sample-next-to-another</code> <code>ERROR</code> <code>N/A</code> <code>Sample.next</code> refers to another one unless it is empty. <code>REF102</code> <code>sample-prev-to-another</code> <code>ERROR</code> <code>N/A</code> <code>Sample.prev</code> refers to another one unless it is empty. <code>REF103</code> <code>sample-annotation-next-to-another</code> <code>ERROR</code> <code>N/A</code> <code>SampleAnnotation.next</code> refers to another one unless it is empty. <code>REF104</code> <code>sample-annotation-prev-to-another</code> <code>ERROR</code> <code>N/A</code> <code>SampleAnnotation.prev</code> refers to another one unless it is empty. <code>REF105</code> <code>sample-data-next-to-another</code> <code>ERROR</code> <code>N/A</code> <code>SampleData.next</code> refers to another one unless it is empty. <code>REF106</code> <code>sample-data-prev-to-another</code> <code>ERROR</code> <code>N/A</code> <code>SampleData.prev</code> refers to another one unless it is empty."},{"location":"schema/requirement/#file-reference","title":"File Reference","text":"ID Name Severity Fixable Description <code>REF201</code> <code>sample-data-filename-presence</code> <code>ERROR</code> <code>N/A</code> <code>SampleData.filename</code> exists. <code>REF202</code> <code>sample-data-info-filename-presence</code> <code>ERROR</code> <code>N/A</code> <code>SampleData.info_filename</code> exists if it is not <code>None</code>. <code>REF203</code> <code>lidarseg-filename-presence</code> <code>ERROR</code> <code>N/A</code> <code>LidarSeg.filename</code> exists if <code>lidarseg.json</code> exists."},{"location":"schema/requirement/#external-table-reference","title":"External Table Reference","text":"ID Name Severity Fixable Description <code>REF301</code> <code>pointcloud-metainfo-token-check</code> <code>ERROR</code> <code>N/A</code> <code>PointCloudMetainfo sensor tokens</code> exists."},{"location":"schema/requirement/#format-fmt","title":"Format (<code>FMT</code>)","text":"ID Name Severity Fixable Description <code>FMT001</code> <code>attribute-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Attribute</code> fields are valid. <code>FMT002</code> <code>calibrated-sensor-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>CalibratedSensor</code> fields are valid. <code>FMT003</code> <code>category-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Category</code> fields are valid. <code>FMT004</code> <code>ego-pose-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>EgoPose</code> fields are valid. <code>FMT005</code> <code>instance-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Instance</code> fields are valid. <code>FMT006</code> <code>log-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Log</code> fields are valid. <code>FMT007</code> <code>map-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Map</code> fields are valid. <code>FMT008</code> <code>sample-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Sample</code> fields are valid. <code>FMT009</code> <code>sample-annotation-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>SampleAnnotation</code> fields are valid. <code>FMT010</code> <code>sample-data-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>SampleData</code> fields are valid. <code>FMT011</code> <code>scene-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Scene</code> fields are valid. <code>FMT012</code> <code>sensor-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Sensor</code> fields are valid. <code>FMT013</code> <code>visibility-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Visibility</code> fields are valid. <code>FMT014</code> <code>lidarseg-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Lidarseg</code> fields are valid. <code>FMT015</code> <code>object-ann-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>ObjectAnn</code> fields are valid. <code>FMT016</code> <code>surface-ann-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>SurfaceAnn</code> fields are valid. <code>FMT017</code> <code>keypoint-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>Keypoint</code> fields are valid. <code>FMT018</code> <code>vehicle-state-field</code> <code>ERROR</code> <code>N/A</code> All types of <code>VehicleState</code> fields are valid."},{"location":"schema/requirement/#tier4-instance-tiv","title":"Tier4 Instance (<code>TIV</code>)","text":"ID Name Severity Fixable Description <code>TIV001</code> <code>load-tier4</code> <code>ERROR</code> <code>N/A</code> Ensure <code>Tier4</code> instance is loaded successfully."},{"location":"schema/table/","title":"Schema Tables","text":""},{"location":"schema/table/#type-definition","title":"Type Definition","text":""},{"location":"schema/table/#primitive-types","title":"Primitive Types","text":"Expression Description <code>str</code> String <code>int</code> Integer <code>float</code> Floating point number <code>bool</code> Boolean <code>enum[X,Y,...]</code> Enumerated type with possible values X, Y, ... <code>[T;N]</code> Array of N elements of type T <code>[T;N,M,...]</code> Array of type T with N, M, or other specified number of elements <code>option[T]</code> Optional value of type T"},{"location":"schema/table/#special-types","title":"Special Types","text":"<p>Some schema contains special types as follows, which are written in key-value pairs in JSON format.</p>"},{"location":"schema/table/#rle","title":"<code>RLE</code>","text":"<p>The <code>RLE</code> type is used to represent run-length encoding of a 2D semantic mask:</p> <pre><code>RLE {\n  \"size\":                   &lt;[int;2]&gt; -- Mask size [width, height].\n  \"counts\":                 &lt;str&gt; -- Encoded counts, where each count is represented as a pair of integers separated by a comma.\n}\n</code></pre>"},{"location":"schema/table/#autolabelmodel","title":"<code>AutolabelModel</code>","text":"<p>The <code>AutolabelModel</code> type used in <code>autolabel_metadata</code> fields has the following structure:</p> <pre><code>AutolabelModel {\n  \"name\":                     &lt;str&gt; -- Name of the model used for annotation. Can include version information.\n  \"score\":                    &lt;float&gt; -- Label score for the annotation from this model (range: 0.0\u20131.0).\n  \"uncertainty\":              &lt;option[float]&gt; -- Model-reported uncertainty for the annotation (range: 0.0\u20131.0). Lower values imply higher confidence.\n}\n</code></pre>"},{"location":"schema/table/#indicators","title":"<code>Indicators</code>","text":"<p>The <code>Indicators</code> represents the status of vehicle indicators:</p> <pre><code>Indicators {\n  \"left\":                   &lt;enum[\"on\", \"off\"]&gt; -- Left indicator status.\n  \"right\":                  &lt;enum[\"on\", \"off\"]&gt; -- Right indicator status.\n  \"hazard\":                 &lt;enum[\"on\", \"off\"]&gt; -- Hazard indicator status.\n}\n</code></pre>"},{"location":"schema/table/#additionalinfo","title":"<code>AdditionalInfo</code>","text":"<p>The <code>AdditionalInfo</code> represents additional information about the vehicle:</p> <pre><code>AdditionalInfo {\n  \"speed\":                  &lt;option[float]&gt; -- Vehicle speed in meters per second.\n}\n</code></pre>"},{"location":"schema/table/#mandatory-tables","title":"Mandatory Tables","text":"<p>The following mandatory tables are required for the dataset, so <code>Tier</code> class raises runtime error if not found.</p>"},{"location":"schema/table/#attribute","title":"Attribute","text":"<ul> <li>Filename: <code>attribute.json</code></li> </ul> <p>An attribute is a property of an instance that can change while the category remains the same.</p> <p>For example, a <code>pedestrian</code> category can have the following attributes:</p> <ul> <li><code>sitting</code>: Indicates whether the pedestrian is sitting.</li> <li><code>standing</code>: Indicates whether the pedestrian is standing.</li> <li><code>lying_down</code>: Indicates whether the pedestrian is lying down.</li> </ul> <pre><code>attribute {\n  \"token\":             &lt;str&gt; -- Unique record identifier.\n  \"name\":              &lt;str&gt; -- Name of the attribute.\n  \"description\":       &lt;str&gt; -- Description of the attribute.\n}\n</code></pre>"},{"location":"schema/table/#calibratedsensor","title":"CalibratedSensor","text":"<ul> <li>Filename: <code>calibrated_sensor.json</code></li> </ul> <p>Definition of a particular sensor (e.g. LiDAR, camera, radar) as calibrated on a particular vehicle.</p> <p>All extrinsic parameters are given with respect to the world coordinate frame.</p> <pre><code>calibrated_sensor {\n  \"token\":              &lt;str&gt; -- Unique record identifier.\n  \"sensor_token\":       &lt;str&gt; -- Foreign key to the `Sensor` table.\n  \"translation\":        &lt;[float;3]&gt; -- Extrinsic translation of the sensor. Coordinate system origin in meters: (x, y, z).\n  \"rotation\":           &lt;[float;4]&gt; -- Extrinsic rotation of the sensor. Coordinate system orientation as quaternion: (w, x, y, z).\n  \"camera_intrinsic\":   &lt;[[float;3];3]&gt; -- Intrinsic camera calibration matrix. Empty list `[]` for sensors other than cameras.\n  \"camera_distortion\":  &lt;[float;4,5,8,12,14]&gt; -- Distortion coefficients of the camera following OpenCV convention. Supports 4, 5, 8, 12, or 14 elements for different distortion models. Empty list `[]` for sensors other than cameras.\n}\n</code></pre>"},{"location":"schema/table/#category","title":"Category","text":"<ul> <li>Filename: <code>category.json</code></li> </ul> <p>Taxonomy of object categories, such as <code>vehicle.truck</code>, <code>vehicle.car</code>, etc.</p> <pre><code>category {\n  \"token\":              &lt;str&gt; -- Unique record identifier.\n  \"name\":               &lt;str&gt; -- Name of the category.\n  \"description\":        &lt;str&gt; -- Description of the category.\n  \"index\":              &lt;option[int]&gt; -- Category index, this is added to support `lidarseg`, or `None` when it doesn't support `lidarseg`.\n  \"has_orientation\":    &lt;bool&gt; -- Indicates whether annotations for this category may include an `orientation` field (e.g., traffic light arrows). If omitted, it is treated as `false`.\n  \"has_number\":         &lt;bool&gt; -- Indicates whether annotations for this category may include a `number` field (e.g., numeric traffic lights). If omitted, it is treated as `false`.\n}\n</code></pre>"},{"location":"schema/table/#egopose","title":"EgoPose","text":"<ul> <li>Filename: <code>ego_pose.json</code></li> </ul> <p>Definition of the ego vehicle's pose at a particular timestamp.</p> <p>This includes both the vehicle's position and orientation in space, typically referred in a global coordinate system such as the map or odometry frame.</p> <pre><code>ego_pose {\n  \"token\":              &lt;str&gt; -- Unique record identifier.\n  \"translation\":        &lt;[float;3]&gt; -- Location of the ego vehicle. Coordinate system origin in meters: (x, y, z).\n  \"rotation\":           &lt;[float;4]&gt; -- Rotation of the ego vehicle. Coordinate system orientation as quaternion: (w, x, y, z).\n  \"twist\":              &lt;option[[float;6]]&gt; -- Linear and angular velocity in the local coordinate system of the ego vehicle. Coordinate system velocity as vector: (vx, vy, vz, yaw_rate, pitch_rate, roll_rate).\n  \"acceleration\":       &lt;option[[float;3]]&gt; -- Linear acceleration in the **local** coordinate system of the ego vehicle, (ax, ay, az).\n  \"geocoordinate\":      &lt;option[[float;3]]&gt; -- Geographical coordinates of the ego vehicle. Coordinate system origin in meters: (latitude, longitude, altitude).\n}\n</code></pre>"},{"location":"schema/table/#instance","title":"Instance","text":"<ul> <li>Filename: <code>instance.json</code></li> </ul> <p>A particular object instance. This table is an enumeration of all object instances we observed.</p> <p>Note that instances are not tracked across scenes. For example, even if an object has the same instance in scene A and B, it should be considered as two different instances.</p> <pre><code>instance {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"category_token\":         &lt;str&gt; -- Foreign key to the `Category` table.\n  \"instance_name\":          &lt;str&gt; -- Consists of the dataset name and the instance ID separated by colons `::`, such as `&lt;DATASET_ID&gt;::&lt;INSTANCE_ID&gt;`.\n  \"nbr_annotations\":        &lt;int&gt; -- Number of annotations associated with this instance.\n  \"first_annotation_token\": &lt;str&gt; -- Foreign key to the first `SampleAnnotation` table associated with this instance. Empty string `\"\"` if the dataset only contains 2D annotations.\n  \"last_annotation_token\":  &lt;str&gt; -- Foreign key to the last `SampleAnnotation` table associated with this instance. Empty string `\"\"` if the dataset only contains 2D annotations.\n}\n</code></pre>"},{"location":"schema/table/#log","title":"Log","text":"<ul> <li>Filename: <code>log.json</code></li> </ul> <p>Log information on the data from which the data was collected.</p> <pre><code>log {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"logfile\":                &lt;str&gt; -- Path to the log file.\n  \"vehicle\":                &lt;str&gt; -- Name of the vehicle.\n  \"data_captured\":          &lt;str&gt; -- Data captured by the vehicle given as `YYYY-MM-DD-HH-MM-SS`.\n  \"location\":               &lt;str&gt; -- Location of the vehicle.\n}\n</code></pre>"},{"location":"schema/table/#map","title":"Map","text":"<ul> <li>Filename: <code>map.json</code></li> </ul> <pre><code>map {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"log_tokens\":             &lt;[str;N]&gt; -- List of foreign keys to the `Log` table associated with this map.\n  \"category\":               &lt;str&gt; -- Category of the map.\n  \"filename\":               &lt;str&gt; -- Relative path to the binary file of the map mask.\n}\n</code></pre>"},{"location":"schema/table/#sample","title":"Sample","text":"<ul> <li>Filename: <code>sample.json</code></li> </ul> <p>A sample is an annotated keyframe. The timestamp of a sample is the same as that of a LiDAR sample data.</p> <pre><code>sample {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"timestamp\":              &lt;int&gt; -- Unix timestamp in microseconds, which is the same as the `timestamp` field in the corresponding LiDAR `SampleData` table.\n  \"scene_token\":            &lt;str&gt; -- Foreign key to the `Scene` table associated with this sample.\n  \"next\":                   &lt;str&gt; -- Foreign key to the next `Sample` table associated with this sample. Empty string `\"\"` if this is the last sample.\n  \"prev\":                   &lt;str&gt; -- Foreign key to the previous `Sample` table associated with this sample. Empty string `\"\"` if this is the first sample.\n}\n</code></pre>"},{"location":"schema/table/#sampleannotation","title":"SampleAnnotation","text":"<ul> <li>Filename: <code>sample_annotation.json</code></li> </ul> <p>An annotation for 3D objects in a sample. All location data are given with respect to the global coordinate system.</p> <pre><code>sample_annotation {\n  \"token\":                  &lt;str&gt; -- Unique record identifier.\n  \"sample_token\":           &lt;str&gt; -- Foreign key to the `Sample` table associated with this annotation.\n  \"instance_token\":         &lt;str&gt; -- Foreign key to the `Instance` table associated with this annotation.\n  \"attribute_tokens\":       &lt;[str;N]&gt; -- Foreign keys to the `Attribute` table associated with this annotation.\n  \"visibility_token\":       &lt;str&gt; -- Foreign key to the `Visibility` table associated with this annotation.\n  \"translation\":            &lt;[float;3]&gt; -- Center location of the cuboid in meters as (x, y, z).\n  \"rotation\":               &lt;[float;4]&gt; -- Quaternion representing the orientation of the cuboid as (w, x, y, z).\n  \"size\":                   &lt;[float;3]&gt; -- Size of the cuboid in meters as (width, length, height).\n  \"velocity\":               &lt;option[[float;3]]&gt; -- Velocity of the cuboid in meters per second as (vx, vy, vz).\n  \"acceleration\":           &lt;option[[float;3]]&gt; -- Acceleration of the cuboid in meters per second squared as (ax, ay, az).\n  \"num_lidar_pts\":          &lt;int&gt; -- Number of lidar points within the cuboid.\n  \"num_radar_pts\":          &lt;int&gt; -- Number of radar points within the cuboid.\n  \"next\":                   &lt;str&gt; -- Foreign key to the `SampleAnnotation` table associated with the next annotation in the sequence. Empty string `\"\"` if this is the last annotation.\n  \"prev\":                   &lt;str&gt; -- Foreign key to the `SampleAnnotation` table associated with the previous annotation in the sequence. Empty string `\"\"` if this is the first annotation.\n  \"automatic_annotation\":   &lt;bool&gt; -- Indicates whether the annotation was automatically generated. Defaults to `false`.\n  \"autolabel_metadata\":     &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n}\n</code></pre>"},{"location":"schema/table/#sampledata","title":"SampleData","text":"<ul> <li>Filename: <code>sample_data.json</code></li> </ul> <p>A sensor data, such as image, point cloud, or radar return. If the <code>is_key_frame=True</code>, the timestamp should be very close to the associated sample's timestamp.</p> <pre><code>sample_data {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"sample_token\":             &lt;str&gt; -- Foreign key to the `Sample` table. Empty string `\"\"` if this is not a key frame.\n  \"ego_pose_token\":           &lt;str&gt; -- Foreign key to the `EgoPose` table.\n  \"calibrated_sensor_token\":  &lt;str&gt; -- Foreign key to the `CalibratedSensor` table.\n  \"filename\":                 &lt;str&gt; -- Relative path from a dataset root directory to the sensor data file.\n  \"fileformat\":               &lt;enum[\"jpg\", \"png\", \"pcd\", \"bin\", \"pcd.bin\"]&gt; -- File format of the sensor data file.\n  \"width\":                    &lt;int&gt; -- Width of the image in pixels.\n  \"height\":                   &lt;int&gt; -- Height of the image in pixels.\n  \"timestamp\":                &lt;int&gt; -- unix timestamp in microseconds.\n  \"is_key_frame\":             &lt;bool&gt; -- Indicates whether this is a key frame.\n  \"next\":                     &lt;str&gt; -- Foreign key to the `SampleData` table associated with the next data in the sequence. Empty string `\"\"` if this is the last data.\n  \"prev\":                     &lt;str&gt; -- Foreign key to the `SampleData` table associated with the previous data in the sequence. Empty string `\"\"` if this is the first data.\n  \"is_valid\":                 &lt;bool&gt; -- Indicates whether this data is valid. Defaults to `true`.\n  \"info_filename\":            &lt;option[str]&gt; -- Relative path to metadata-blob file.\n  \"autolabel_metadata\":       &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling applied to this entire sample_data item (e.g., image or scan).\n}\n</code></pre>"},{"location":"schema/table/#scene","title":"Scene","text":"<ul> <li>Filename: <code>scene.json</code></li> </ul> <p>A scene is a sequence of consecutive frames extracted from a log. In T4 format, only one scene is included in a single dataset.</p> <pre><code>scene {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"name\":                     &lt;str&gt; -- Name of the scene, given as `{PROJECT_NAME}_{SCENE_TOKEN}`.\n  \"description\":              &lt;str&gt; -- Description of the scene.\n  \"log_token\":                &lt;str&gt; -- Foreign key to the `Log` table associated with the log that contains this scene.\n  \"nbr_samples\":              &lt;int&gt; -- Number of samples in the scene.\n  \"first_sample_token\":       &lt;str&gt; -- Foreign key to the `Sample` table associated with the first data in the scene.\n  \"last_sample_token\":        &lt;str&gt; -- Foreign key to the `Sample` table associated with the last data in the scene.\n}\n</code></pre>"},{"location":"schema/table/#sensor","title":"Sensor","text":"<ul> <li>Filename: <code>sensor.json</code></li> </ul> <p>A description of sensor types.</p> <pre><code>sensor {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"channel\":                  &lt;str&gt; -- Channel of the sensor.\n  \"modality\":                 &lt;enum[\"camera\", \"lidar\", \"radar\"]&gt; -- Modality of the sensor.\n}\n</code></pre>"},{"location":"schema/table/#visibility","title":"Visibility","text":"<ul> <li>Filename: <code>visibility.json</code></li> </ul> <p>A description of annotation visibility status.</p> <p>Visibility level is classified into 4 bins below:</p> <ul> <li>full: The annotation is fully visible.</li> <li>most: The annotation is mostly visible, more than 50%.</li> <li>partial: The annotation is partially visible, more than 10% but less than 50%.</li> <li>none: The annotation is not visible.</li> </ul> <pre><code>visibility {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"level\":                    &lt;enum[\"full\", \"most\", \"partial\", \"none\"]&gt; -- Level of visibility of the annotation.\n  \"description\":              &lt;str&gt; -- Description of the visibility level.\n}\n</code></pre> Warning <p>Following old formats are also supported but deprecated:</p> <p> <pre><code>- v80-100 : full\n- v60-80  : most\n- v40-60  : partial\n- v0-40   : none\n</code></pre></p> <p>If input level does not satisfy any above cases, <code>VisibilityLevel.UNAVAILABLE</code> will be assigned.</p>"},{"location":"schema/table/#optional-tables","title":"Optional Tables","text":"<p>The following tables are optional, and skipped loading by <code>Tier4</code> class if not exists.</p>"},{"location":"schema/table/#lidarseg","title":"LidarSeg","text":"<ul> <li>Filename: <code>lidarseg.json</code></li> </ul> <p>Mapping between LiDAR segmentation annotations and <code>SampleData</code> corresponding to the LiDAR point cloud associated with a keyframe.</p> <pre><code>lidarseg {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"filename\":                 &lt;str&gt; -- Filename of the LiDAR segmentation annotation labels that is an array of unit8.\n  \"sample_data_token\":        &lt;str&gt; -- Foreign key to the `SampleData` table associated with the sample data.\n}\n</code></pre>"},{"location":"schema/table/#objectann","title":"ObjectAnn","text":"<ul> <li>Filename: <code>object_ann.json</code></li> </ul> <p>The annotation of a foreground object (car, bike, pedestrian, etc.) in an image. Each foreground object is annotated with a 2D box, a 2D instance mask and category-specific attributes.</p> <pre><code>object_ann {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"sample_data_token\":        &lt;str&gt; -- Foreign key to the `SampleData` table associated with the sample data.\n  \"instance_token\":           &lt;str&gt; -- Foreign key to the `Instance` table associated with the instance of the object.\n  \"category_token\":           &lt;str&gt; -- Foreign key to the `Category` table associated with the category of the object.\n  \"attribute_tokens\":         &lt;[str;N]&gt; -- Foreign keys to the `Attribute` table associated with the attributes of the object.\n  \"bbox\":                     &lt;[int;4]&gt; -- Bounding box coordinates in the format (xmin, ymin, xmax, ymax).\n  \"mask\":                     &lt;RLE&gt; -- Run length encoding of instance mask.\n  \"orientation\":              &lt;option[float]&gt; -- Orientation of the arrow shape within the bounding box, in radians. Present only for categories where `has_orientation` is true (e.g., traffic light arrows).\n  \"number\":                   &lt;option[int]&gt; -- The digit displayed within the bounding box. Present only for categories where `has_number` is true (e.g., numeric traffic lights).\n  \"automatic_annotation\":     &lt;bool&gt; -- Whether the annotation was automatically generated. Defaults to `false`.\n  \"autolabel_metadata\":       &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n}\n</code></pre>"},{"location":"schema/table/#surfaceann","title":"SurfaceAnn","text":"<ul> <li>Filename: <code>surface_ann.json</code></li> </ul> <p>The annotation of a background object (drivable surface) in an image. Each background object is annotated with a 2d semantic segmentation mask.</p> <pre><code>surface_ann {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"sample_data_token\":        &lt;str&gt; -- Foreign key to the `SampleData` table associated with the sample data.\n  \"category_token\":           &lt;str&gt; -- Foreign key to the `Category` table associated with the category of the surface.\n  \"mask\":                     &lt;RLE&gt; -- Run length encoding of instance mask.\n  \"automatic_annotation\":     &lt;bool&gt; -- Whether the annotation was automatically generated. Defaults to `false`.\n  \"autolabel_metadata\":       &lt;option[[AutolabelModel;N]]&gt; -- List of models used for autolabeling. Required if `automatic_annotation` is `true`.\n}\n</code></pre>"},{"location":"schema/table/#vehiclestate","title":"VehicleState","text":"<ul> <li>Filename: <code>vehicle_state.json</code></li> </ul> <p>This table provides comprehensive information about the vehicle's state at a given timestamp, including the status of doors, indicators, steering, and other relevant information.</p> <pre><code>vehicle_state {\n  \"token\":                    &lt;str&gt; -- Unique record identifier.\n  \"timestamp\":                &lt;int&gt; -- Unix timestamp in microseconds.\n  \"accel_pedal\":              &lt;option[float]&gt; -- Accelerator pedal position percentage.\n  \"brake_pedal\":              &lt;option[float]&gt; -- Brake pedal position percentage.\n  \"steer_pedal\":              &lt;option[float]&gt; -- Steering wheel position percentage.\n  \"steering_tire_angle\":      &lt;option[float]&gt; -- Steering tire angle in radians.\n  \"steering_wheel_angle\":     &lt;option[float]&gt; -- Steering wheel angle in radians.\n  \"shift_state\":              &lt;option[enum[\"PARK\", \"REVERSE\", \"NEUTRAL\", \"HIGH\", \"FORWARD\", \"LOW\", \"NONE\"]]&gt; -- Shift state of the vehicle.\n  \"indicators\":               &lt;option[Indicators]&gt; -- Indicator state of the vehicle.\n  \"additional_info\":          &lt;option[AdditionalInfo]&gt; -- Additional information about the vehicle state.\n}\n</code></pre>"},{"location":"tutorials/customize/","title":"Schema Customization","text":""},{"location":"tutorials/customize/#generate-with-a-new-token","title":"Generate with a New Token","text":"<p>You can crate a schema containing the specified table data with a new token using <code>new(...)</code> methods.</p> <pre><code>&gt;&gt;&gt; from t4_devkit.schema import Attribute\n&gt;&gt;&gt; from t4_devkit.common import serialize_dataclass\n&gt;&gt;&gt;\n&gt;&gt;&gt; # schema data except of the unique identifier token\n&gt;&gt;&gt; data = {\n...     \"name\": \"foo\",\n...     \"description\": \"this is re-generated attribute.\"\n... }\n&gt;&gt;&gt;\n&gt;&gt;&gt; attr1 = Attribute.new(data)\n&gt;&gt;&gt;\n&gt;&gt;&gt; # Also, it allows us to create a copy of the existing table data with a new token\n&gt;&gt;&gt; serialized = serialize_dataclass(attr1)\n&gt;&gt;&gt; attr2 = Attribute.new(serialized)\n&gt;&gt;&gt;\n&gt;&gt;&gt; attr1.token != attr2.token\nTrue\n&gt;&gt;&gt; attr1\nAttribute(token='b08701e5095fbd12a45e7f51b85ffc08', name='foo', description='this is re-generated attribute.')\n&gt;&gt;&gt; attr2\nAttribute(token='f40e605870aa29b1473ca6e65255c45e', name='foo', description='this is re-generated attribute.')\n</code></pre>"},{"location":"tutorials/customize/#customize-schema-classes","title":"Customize Schema Classes","text":"<p>You can customize schema classes on your own code, if you need for some reasons.</p> <p>For example, you might meet the error because of missing some mandatory fields but it is OK whatever the actual value is.</p> <p>In here, let's define a custom <code>Attribute</code> class, called <code>CustomAttribute</code>, in your workspace. This class suppresses runtime exception caused by missing <code>description</code> in <code>attribute.json</code>.</p> <p>Now you have the following workspace structure:</p> <pre><code>my_package\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 __init__.py\n\u2502   \u251c\u2500\u2500 custom_schema.py\n\u2502   \u2514\u2500\u2500 main.py\n\u2514\u2500\u2500 pyproject.toml\n</code></pre> <p>By editing <code>custom_schema.py</code>, you can define <code>CustomAttribute</code> overwriting <code>Attribute</code> as follows:</p> custom_schema.py<pre><code>from __future__ import annotations\n\nfrom attrs import define, field\n\nfrom t4_devkit.schema import SCHEMAS, SchemaName, SchemaBase\nfrom t4_devkit.common import load_json\n\n__all__ = [\"CustomAttribute\"]\n\n\n@define(slots=False)\n@SCHEMAS.register(SchemaName.ATTRIBUTE, force=True)\nclass CustomAttribute(SchemaBase):\n    \"\"\"Custom Attribute class ignoring if there is no `description` field.\n    Note that `description` field is mandatory in the original `Attribute` class.\n\n    `@SCHEMAS.register(SchemaName.ATTRIBUTE, force=True)` performs that\n    it forces to update the attribute table in the schema registry.\n    \"\"\"\n\n    name: str\n    description: str | None = field(default=None)\n</code></pre> <p>Note that <code>CustomAttribute</code> should be imported before instantiating <code>Tier4</code> class. Then modify <code>__init__.py</code> in order to import it automatically:</p> __init__.py<pre><code>from .custom_attribute import * # noqa\n</code></pre>"},{"location":"tutorials/initialize/","title":"Initialization","text":""},{"location":"tutorials/initialize/#initialize-tier4-class","title":"Initialize <code>Tier4</code> class","text":"<p><code>Tier4</code> class expects both following dataset directly structure with or without <code>&lt;VERSION&gt;</code> directory:</p> <ul> <li>With <code>&lt;VERSION&gt;</code> directory:</li> </ul> <pre><code>data/tier4/\n\u2514\u2500\u2500 &lt;VERSION&gt; ...version number\n    \u251c\u2500\u2500 annotation ...contains `*.json` files\n    \u251c\u2500\u2500 data\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_LEFT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_RIGHT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_LEFT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_RIGHT\n    \u2502\u00a0\u00a0 \u251c\u2500\u2500 LIDAR_CONCAT\n    \u2502\u00a0\u00a0 \u2514\u2500\u2500 ...Other sensor channels\n    ...\n</code></pre> <ul> <li>Without <code>&lt;VERSION&gt;</code> directory:</li> </ul> <pre><code>data/tier4/\n\u251c\u2500\u2500 annotation ...contains `*.json` files\n\u251c\u2500\u2500 data\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_LEFT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_BACK_RIGHT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_LEFT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 CAM_FRONT_RIGHT\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 LIDAR_CONCAT\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 ...Other sensor channels\n...\n</code></pre> <p>You can initialize a <code>Tier4</code> instance as follows:</p> <pre><code>&gt;&gt;&gt; from t4_devkit import Tier4\n\n&gt;&gt;&gt; t4 = Tier4(\"data/tier4/\", verbose=True)\n======\nLoading T4 tables in `annotation`...\nReverse indexing...\nDone reverse indexing in 0.007 seconds.\n======\n13 attribute\n7 calibrated_sensor\n8 category\n2524 ego_pose\n106 instance\n1 log\n1 map\n72 sample\n2390 sample_annotation\n2524 sample_data\n4 visibility\n7 sensor\n1 scene\n1326 object_ann\n0 surface_ann\n0 keypoint\nDone loading in 0.061 seconds.\n======\n</code></pre> <p>Note that if you doesn't specify <code>revision</code> parameter in construction, it searches the latest version of the dataset. By specifying <code>revision=&lt;VERSION&gt;</code>, you can load the specific version of the dataset.</p> <pre><code>&gt;&gt;&gt; t4 = Tier4(\"data/tier4/\", revision=\"2\", verbose=True)\n</code></pre>"},{"location":"tutorials/initialize/#access-to-schema-fields","title":"Access to Schema Fields","text":""},{"location":"tutorials/initialize/#scene","title":"<code>scene</code>","text":"<pre><code>&gt;&gt;&gt; my_scene = t4.scene[0]\n</code></pre>"},{"location":"tutorials/initialize/#sample","title":"<code>sample</code>","text":"<p><code>sample</code> is an annotated keyframe of a scene at a given timestamp.</p> <pre><code>&gt;&gt;&gt; first_sample_token = my_scene.first_sample_token\n&gt;&gt;&gt; my_sample = t4.get(\"sample\", first_sample_token)\n</code></pre> <p>You can access the <code>sample_data</code> associated with this <code>sample</code>. <code>sample.data</code> returns a <code>dict</code> object consists of <code>{str: &lt;SAMPLE_DATA_TOKEN (str)&gt;}</code>.</p> <pre><code>&gt;&gt;&gt; my_sample.data\n</code></pre>"},{"location":"tutorials/initialize/#sample_data","title":"<code>sample_data</code>","text":"<p><code>sample_data</code> is references to a family of data that is collected from specific sensors.</p> <pre><code>&gt;&gt;&gt; sensor = \"CAM_FRONT\"\n&gt;&gt;&gt; t4.get(\"sample_data\", my_sample.data[sensor])\n</code></pre>"},{"location":"tutorials/initialize/#sample_annotation","title":"<code>sample_annotation</code>","text":"<p><code>sample_annotation</code> refers to any 3D bounding box in a corresponding <code>sample</code>. All location data is given with respect to the global coordinate system. You can access the list of <code>sample_annotation</code> tokens with <code>sample.ann_3ds: list[str]</code>.</p> <pre><code>&gt;&gt;&gt; my_annotation_token = my_sample.ann_3ds[0]\n&gt;&gt;&gt; t4.get(\"sample_annotation\", my_annotation_token)\n</code></pre>"},{"location":"tutorials/initialize/#instance","title":"<code>instance</code>","text":"<p>Each annotated object is instanced to be tracked.</p> <pre><code>&gt;&gt;&gt; t4.instance\n</code></pre>"},{"location":"tutorials/initialize/#category","title":"<code>category</code>","text":"<p>A <code>category</code> is the object assignment of an annotation.</p> <pre><code>&gt;&gt;&gt; t4.category\n</code></pre>"},{"location":"tutorials/initialize/#attribute","title":"<code>attribute</code>","text":"<p>An <code>attribute</code> is a property of an instance that may change throughout different parts of a scene while <code>category</code> remains the same.</p> <pre><code>&gt;&gt;&gt; t4.attribute\n</code></pre>"},{"location":"tutorials/initialize/#visibility","title":"<code>visibility</code>","text":"<p><code>visibility</code> is defined as the fraction of pixels of a particular annotation that are visible over the 6 camera feeds.</p> <pre><code>&gt;&gt;&gt; t4.visibility\n</code></pre> <p>Warning</p> <p>Expected <code>level</code> values in <code>visibility</code> are as below:</p> <p> <pre><code>- full    : No occlusion for the object.\n- most    : Object is occluded, but by less than 50%.\n- partial : Object is occluded, but by more than 50%.\n- none    : Object is 90-100% occluded and no points/pixels are visible.\n</code></pre></p> <p>Following old formats are also supported but deprecated:</p> <p> <pre><code>- v80-100 : full\n- v60-80  : most\n- v40-60  : partial\n- v0-40   : none\n</code></pre></p> <p>If input level does not satisfy any above cases, <code>VisibilityLevel.UNAVAILABLE</code> will be assigned.</p>"},{"location":"tutorials/initialize/#sensor","title":"<code>sensor</code>","text":"<p>T4 dataset consists of several type of sensors. The supported sensor modalities and channels are defined in <code>t4_devkit/schema/tables/sensor.py</code>.</p> <pre><code>&gt;&gt;&gt; t4.sensor\n</code></pre>"},{"location":"tutorials/initialize/#calibrated_sensor","title":"<code>calibrated_sensor</code>","text":"<p><code>calibrated_sensor</code> consists of the definition of a calibration of a particular sensor based on a vehicle.</p> <pre><code>&gt;&gt;&gt; t4.calibrated_sensor\n</code></pre> <p>Note that the <code>translation</code> and <code>rotation</code> parameters are given with respect to the ego vehicle body frame.</p>"},{"location":"tutorials/initialize/#ego_pose","title":"<code>ego_pose</code>","text":"<p><code>ego_pose</code> contains information about the <code>translation</code> and <code>rotation</code> of the ego vehicle, with respect to the global coordinate system.</p> <pre><code>&gt;&gt;&gt; t4.ego_pose\n</code></pre>"},{"location":"tutorials/render/","title":"Visualization","text":""},{"location":"tutorials/render/#rendering-with-tier4","title":"Rendering with <code>Tier4</code>","text":"<p>If you want to visualize annotation results, <code>Tier4</code> supports some rendering methods as below.</p>"},{"location":"tutorials/render/#scene","title":"Scene","text":"<pre><code>&gt;&gt;&gt; t4.render_scene()\n</code></pre>"},{"location":"tutorials/render/#specific-instances","title":"Specific Instance(s)","text":"<pre><code>&gt;&gt;&gt; instance_token = t4.instance[0].token\n&gt;&gt;&gt; t4.render_instance(instance_token)\n</code></pre> <p>Note</p> <p>You can also render multiple instances at once:</p> <p> <pre><code>&gt;&gt;&gt; instance_tokens = [inst.token for inst in t4.instance[:3]]\n&gt;&gt;&gt; t4.render_instance(instance_tokens)\n</code></pre></p>"},{"location":"tutorials/render/#pointcloud","title":"PointCloud","text":"<pre><code>&gt;&gt;&gt; t4.render_pointcloud()\n</code></pre>"},{"location":"tutorials/render/#save-recording","title":"Save Recording","text":"<p>You can save the rendering result as follows:</p> <pre><code>&gt;&gt;&gt; t4.render_scene(scene_token, save_dir=&lt;DIR_TO_SAVE&gt;)\n</code></pre> <p>When you specify <code>save_dir</code>, viewer will not be spawned on your screen.</p>"},{"location":"tutorials/render/#rendering-with-rerunviewer","title":"Rendering with <code>RerunViewer</code>","text":"<p>If you want to visualize your components, such as boxes that your ML-model estimated, <code>RerunViewer</code> allows you to visualize these components. For details, please refer to the API references.</p> <p>To initialize <code>RerunViewer</code>, you can use the <code>ViewerBuilder</code> class:</p> <pre><code>&gt;&gt;&gt; from t4_devkit.viewer import ViewerBuilder\n# You need to specify `cameras` if you want to 2D spaces\n&gt;&gt;&gt; viewer = (\n        ViewerBuilder()\n        .with_spatial3d()\n        .with_spatial2d(cameras=[\"CAM_FRONT\", \"CAM_BACK\"])\n        .with_labels({\"car\": 1, \"pedestrian\": 2})\n        .build(app_id=\"foo\")\n    )\n\n# Timestamp in seconds\n&gt;&gt;&gt; seconds: int | float = ...\n</code></pre>"},{"location":"tutorials/render/#rendering-3d-boxes","title":"Rendering 3D boxes","text":"<pre><code># Rendering 3D boxes\n&gt;&gt;&gt; from t4_devkit.dataclass import Box3D\n&gt;&gt;&gt; box3ds = [Box3D(...)...]\n&gt;&gt;&gt; viewer.render_box3ds(seconds, box3ds)\n</code></pre> <p>It allows you to render boxes by specifying elements of boxes directly.</p> <pre><code># Rendering 3D boxes by specifying elements of boxes directly\n&gt;&gt;&gt; centers = [[i, i, i] for i in range(10)]\n&gt;&gt;&gt; frame_id = \"base_link\"\n&gt;&gt;&gt; rotations = [[1, 0, 0, 0] for _ in range(10)]\n&gt;&gt;&gt; sizes = [[1, 1, 1] for _ in range(10)]\n&gt;&gt;&gt; class_ids = [0 for _ in range(10)]\n&gt;&gt;&gt; viewer.render_box3ds(seconds, frame_id, centers, rotations, sizes, class_ids)\n</code></pre> <p></p>"},{"location":"tutorials/render/#rendering-2d-boxes","title":"Rendering 2D boxes","text":"<p>For 2D spaces, you need to specify camera names in the viewer constructor, and render images by specifying camera names:</p> <pre><code>&gt;&gt;&gt; import numpy as np\n&gt;&gt;&gt; from t4_devkit.dataclass import Box2D\n\n# Rendering an image\n&gt;&gt;&gt; image = np.zeros((100, 100, 3), dtype=np.uint8)\n&gt;&gt;&gt; viewer.render_image(seconds, \"camera1\", image)\n\n# Rendering 2D boxes\n&gt;&gt;&gt; box2ds = [Box2D(...)...]\n&gt;&gt;&gt; viewer.render_box2ds(seconds, \"camera1\", box2ds)\n</code></pre> <p>It allows you to render boxes by specifying elements of boxes directly:</p> <pre><code># Rendering 2D boxes by specifying elements of boxes directly\n&gt;&gt;&gt; rois = [[0, 0, 10 * i, 10 * i] for i in range(10)]\n&gt;&gt;&gt; viewer.render_box2ds(seconds, \"camera1\", rois, class_ids)\n</code></pre> <p></p>"},{"location":"tutorials/render/#rendering-point-cloud","title":"Rendering point cloud","text":"<pre><code>from t4_devkit.dataclass import LidarPointCloud\nfrom t4_devkit.viewer import PointCloudColorMode\n# Point cloud channel name\n&gt;&gt;&gt; lidar_channel = \"LIDAR_TOP\"\n# Load point cloud from file\n&gt;&gt;&gt; pointcloud = LidarPointCloud.from_file(&lt;PATH_TO_POINTCLOUD.pcd.bin&gt;)\n&gt;&gt;&gt; color_mode = PointCloudColorMode.DISTANCE\n&gt;&gt;&gt; viewer.render_pointcloud(seconds, lidar_channel, pointcloud, color_mode)\n</code></pre>"},{"location":"tutorials/render/#rendering-lidar-segmentation","title":"Rendering LiDAR segmentation","text":"<pre><code>from t4_devkit.dataclass import SegmentationPointCloud\nfrom t4_devkit.viewer import PointCloudColorMode\n# Point cloud channel name\n&gt;&gt;&gt; lidar_channel = \"LIDAR_TOP\"\n# Load point cloud and label from file\n&gt;&gt;&gt; pointcloud = SegmentationPointCloud.from_file(\"&lt;PATH_TO_POINTCLOUD.pcd.bin&gt;\", \"&lt;PATH_TO_LABEL.pcd.bin&gt;\")\n&gt;&gt;&gt; color_mode = PointCloudColorMode.SEGMENTATION\n&gt;&gt;&gt; viewer.render_pointcloud(seconds, lidar_channel, pointcloud, color_mode)\n</code></pre>"},{"location":"tutorials/render/#rendering-lanelet-map","title":"Rendering lanelet map","text":"<pre><code># Rendering lanelet map\n&gt;&gt;&gt; viewer.render_map(&lt;PATH_TO_LANELET.osm&gt;)\n</code></pre>"},{"location":"tutorials/sanity/","title":"Sanity Check","text":""},{"location":"tutorials/sanity/#sanity-check","title":"Sanity Check","text":""},{"location":"tutorials/sanity/#quick-start","title":"Quick Start","text":"<p><code>sanity_check(...)</code> function performs a series of sanity checks to ensure the integrity of the dataset.</p> <p>About the defined rules, please refer to requirement.md.</p> main.py<pre><code>from t4_devkit.common import save_json, serialize_dataclass\nfrom t4_devkit.sanity import sanity_check, print_sanity_result\n\n\nresult = sanity_check(\"&lt;path/to/dataset&gt;\")\n\n# display detailed results and summary\nprint_sanity_result(result)\n\n# save result to JSON file if you want\nsave_json(serialize_dataclass(result), \"result.json\")\n</code></pre>"},{"location":"tutorials/sanity/#how-to-add-new-checkers","title":"How to Add New Checkers","text":"<p>The following diagram shows the logic of the checkers:</p> <pre><code>flowchart LR\n    Start --&gt; A{Can skip?}\n    A --&gt; |Yes| B[Skip check and returns skipped report]\n    A --&gt; |No| C[Perform check]\n    C --&gt; D{Failed and --fix=True?}\n    D --&gt; |Yes| E[Fix issues]\n    E --&gt; F[Return report]\n    D --&gt; |No| F\n</code></pre> <p>All checkers must follow:</p> <ul> <li>Implement a class that inherits from <code>Checker</code> class.</li> <li>Its ID must be unique and belong to one of <code>RuleGroup</code> enum.</li> <li>Register the checker using <code>CHECKERS.register()</code> decorator.</li> <li>Override the <code>check(...) -&gt; list[Reason] | None</code> method to perform the specific check.</li> <li>[OPTIONAL] The following methods can be overridden if needed:</li> <li>Override <code>can_skip(...) -&gt; Maybe[Reason]</code> method to determine whether the checker can be skipped.</li> <li>Override <code>fix(...) -&gt; bool</code> method to fix the issue if possible.</li> </ul> str000.py<pre><code>from __future__ import annotations\n\nfrom typing import TYPE_CHECKING\n\nfrom t4_devkit.sanity.checker import Checker, RuleID, RuleName, Severity\nfrom t4_devkit.sanity.registry import CHECKERS\nfrom t4_devkit.sanity.result import Reason\n\nif TYPE_CHECKING:\n    from t4_devkit.sanity.context import SanityContext\n\n\n@CHECKERS.register()\nclass STR000(Checker):\n    \"\"\"This is a custom checker.\"\"\"\n\n    id = RuleID(\"STR000\")\n    name = RuleName(\"my-custom-checker\")\n    severity = Severity.ERROR\n    description = \"This is a custom checker.\"\n\n    def check(self, context: SanityContext) -&gt; list[Reason] | None:\n        # Return a list of reasons if the check fails, or None if it passes.\n        return None\n</code></pre>"}]}